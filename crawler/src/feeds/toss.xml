
<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>토스 기술 블로그, 토스 테크</title>
        <link>https://toss.tech</link>
        <description>토스 메이커들이 문제를 정의하고 해법을 찾아가는 이야기를 들려드립니다.</description>
        <lastBuildDate>Fri, 26 Dec 2025 17:03:27 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>토스팀</generator>
        <language>ko</language>
        <copyright>Viva Republica, All rights reserved.</copyright>
        <atom:link href="https://toss.tech/rss.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[LLM을 이용한 서비스 취약점 분석 자동화 #1]]></title>
            <link>https://toss.tech/article/vulnerability-analysis-automation-1</link>
            <guid>https://toss.tech/article/vulnerability-analysis-automation-1</guid>
            <pubDate>Wed, 24 Dec 2025 08:28:00 GMT</pubDate>
            <description><![CDATA[보안 분석가라면 누구나 한 번쯤 상상했을 ‘해줘’로 취약점 찾기. 그 경험을 공유해 드립니다.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2d2a360d-33e3-8080-a8ca-e347ed670d02" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요. 토스 Security Researcher 표상영입니다.</span></span></span></p><p id="2d2a360d-33e3-8054-969d-e7bad1502d1f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">요즘 LLM이 정말 다양한 분야에서 활용되고 있죠. 토스에서도 여러 업무에 LLM을 접목하며 효율성을 높이고 있는데요. 그중에서도 </span><span class="css-q3ktjb">LLM을 이용해 서비스 취약점 분석을 자동화한 경험</span><span class="css-1kxrhf3">을 공유해 보려고 합니다. 이번 글에서는 이 프로젝트를 진행하면서 마주했던 문제점과 그에 대한 해결책을 소개해 드리고, 이어서 2편에서 실제로 어떻게 구현했는지를 공유할 예정이에요.</span></span></span></p><p id="2d3a360d-33e3-80fe-b716-f4d36ce41cef" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2c6a360d-33e3-80f9-98da-cb49c4beb052" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">Google, Project Naptime</span></span></span></h2><p id="2c6a360d-33e3-80f5-976c-f9a6c8c23f56" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">구글에는 재미있는 프로젝트가 하나 있습니다.</span></span></span></p><p id="2c6a360d-33e3-808f-a3c3-c65589113178" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1odxvuk">“</span><span class="css-1odxvuk">LLM을 이용해 취약점 분석을 자동화하고 낮잠 시간을 만들자!”</span><span class="css-1kxrhf3">라는 목적의 Naptime(낮잠) 프로젝트가 바로 그것인데요.</span></span></span></p><figure id="2c6a360d-33e3-806b-87a3-fd0a33edead9" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/3db9d218-f990-4ae4-b2a7-021854ad6e39/image.png" alt="" class="css-1pgssrp"/><figcaption class="css-wgpbp3"><a target="_blank" rel="noreferrer noopener" class="css-114ityv" href="https://googleprojectzero.blogspot.com/2024/06/project-naptime.html">https://googleprojectzero.blogspot.com/2024/06/project-naptime.html</a><span class="css-jfs1hr"> / Naptime architecture</span></figcaption></figure><p id="2c6a360d-33e3-80b2-99fd-d3336b14c131" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">당시 ‘LLM이 자율적으로 소스코드를 분석하고 취약점을 찾는다’라는 것은 분석가들 머릿속에만 있는 상상 속의 무언가 였습니다. 저 또한 그런 생각을 갖고있던 찰나, 꽤 구체적인 아이디어와 함께 실제로 유의미한 결과를 도출한 Project Naptime 글을 흥미롭게 읽게 되었어요.</span></span></span></p><figure id="2c6a360d-33e3-80d6-8af7-e81fa861864b" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/6c250cde-a4d0-462e-a31b-712b2aab02c4/image.png" alt="" class="css-1pgssrp"/></figure><p id="2c6a360d-33e3-80fe-9030-fac9a3d67e78" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">글을 읽고 난 뒤, </span><span class="css-1odxvuk">‘정말 가능할까?’</span><span class="css-1kxrhf3">에서 </span><span class="css-1odxvuk">‘진짜 가능하구나!’</span><span class="css-1kxrhf3">라는 가능성을 확인하고, 곧 바로 </span><span class="css-1kxrhf3">길드(토스의 작은 프로젝트 그룹)</span><span class="css-1kxrhf3">를 만들고 길드원을 모으기 시작했습니다. 모든 팀원분들이 그랬지만, 새롭게 나오는 기술들로 공부해야할 것들은 너무 많았고 자원은 한정되어 있어서 리소스 절약이 정말 절실했거든요.</span></span></span></p><p id="2d3a360d-33e3-803d-992a-e509aa5636b6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2d2a360d-33e3-80f9-9b33-e84ca190679c" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">시작부터 만만치 않았던 여정</span></span></span></h2><p id="2d2a360d-33e3-8084-83ed-edab8ae69e73" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1odxvuk">&quot;LLM으로 취약점 분석? 간단하겠네!&quot;</span><span class="css-1kxrhf3"> 라고 생각하며 시작했지만, 현실은 녹록치 않았어요.</span></span></span></p><h3 id="2d2a360d-33e3-8099-9fc4-f50aac34b173" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">첫 번째 벽: 대용량 소스코드를 어떻게 넣을까?</span></span></span></h3><p id="2d2a360d-33e3-8021-a62c-e7b2950cdd3b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가장 먼저 부딪힌 문제는 대용량 소스코드를 LLM에 넣어주는 것이었어요. 토스의 서비스들은 대부분 상당한 규모의 소스코드를 가지고 있는데, 이 모든 코드를 LLM의 토큰 한계 안에 맞추는 것부터 쉽지 않았습니다.</span></span></span></p><p id="2d2a360d-33e3-8016-9092-cc3d5787522a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">처음에는 RAG(Retrieval Augmented Generation)를 시도해 봤어요. 코드를 벡터로 임베딩해서 필요한 부분만 가져오는 방식이었는데, 코드 간 연관관계를 제대로 파악하기 어려웠어요. 그래서 Repomix 같은 툴로 전체 소스코드를 압축해서 던져주는 것도 시도해 봤습니다. 하지만 결국 모든 시도가 토큰 문제로 실패했어요.</span></span></span></p><p id="2d2a360d-33e3-8057-8b47-d36ace26e7ab" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">설사 토큰 Context Size 안에 맞춘다고 해도 더 큰 문제가 있었어요. 바로 Hallucination이었습니다. 너무 많은 정보를 한 번에 처리하다 보니 LLM이 실제로는 없는 취약점을 만들어내거나, 코드의 흐름을 잘못 이해하는 경우가 빈번했거든요.</span></span></span></p><h3 id="2d2a360d-33e3-80bc-ad68-cece1e538068" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">해결책을 찾다: MCP로 자유롭게 소스코드 탐색하기</span></span></span></h3><p id="2d2a360d-33e3-808c-95cc-e894f0037ca1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">여러 논문과 레퍼런스를 찾아본 결과, LLM Agent가 자유롭게 소스코드를 참조할 수 있도록 하는 MCP(Model Context Protocol)를 만드는 방향으로 해결할 수 있다는 걸 알게 됐어요.</span></span></span></p><p id="2d2a360d-33e3-8023-8d7a-c1f16af11fc4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 위해 개발한 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">SourceCode Browse MCP</span></code><span class="css-1kxrhf3">는 다음과 같은 구조로 동작해요:</span></span></span></p><aside id="2d3a360d-33e3-80e3-a61a-efc3ae829bfa" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2d2a360d-33e3-8048-a709-fae4fe512853" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">tree-sitter</span><span class="css-1kxrhf3">: 소스코드의 구문 트리 분석</span></span></span></li><li id="2d2a360d-33e3-80a4-84b3-f31770fe1cc2" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">ctags</span><span class="css-1kxrhf3">: 함수와 변수의 정의 위치 인덱싱</span></span></span></li><li id="2d2a360d-33e3-806f-bff1-c2576c5bd780" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">ripgrep</span><span class="css-1kxrhf3">: 고속 텍스트 검색</span></span></span></li></ul></div></aside><p id="2d2a360d-33e3-80e7-b664-c1273d1aa6d8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 소스코드를 사전에 인덱싱 해두면, LLM이 필요할 때마다 MCP Tool Calling을 통해 </span><span class="css-1odxvuk">&quot;이 함수는 어디서 정의되지?&quot;</span><span class="css-1kxrhf3">, </span><span class="css-1odxvuk">&quot;이 변수는 어디서 사용되지?&quot;</span><span class="css-1kxrhf3"> 같은 정보들을 효율적으로 참조할 수 있게 만들 수 있었어요.</span></span></span></p><p id="2d2a360d-33e3-80c6-b6c3-eb5dad0a720d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2d2a360d-33e3-80cc-aac6-c7918f7a6029" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">두 번째 벽: 일관성 없는 결과와 정확도</span></span></span></h2><p id="2d2a360d-33e3-8025-a512-cd3b457ae200" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">MCP 덕분에 소스코드 참조 문제는 해결됐지만, 이제 정확도 문제가 발목을 잡았어요. 사용한 모델은 Claude-Sonnet-4 였는데, 취약점을 잘 찾긴 했지만 일관성이 없었거든요.</span></span></span></p><p id="2d2a360d-33e3-8059-b743-fd2eaf7ecd3c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들어 XSS 취약점이 총 10개 있으면, 어떨 때는 8개만 찾고 2개를 빼먹고, 어떨 때는 10개를 다 찾기도 하고, 심지어 9개를 찾았다가 다시 돌리면 7개만 찾기도 하는 등 결과에 일관성이 없었어요. 이렇게는 도저히 LLM을 신뢰할 수 없었죠.</span></span></span></p><h3 id="2d2a360d-33e3-8022-80fb-d1bd92b96fe9" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">SAST 도구와의 만남: CodeQL vs Semgrep</span></span></span></h3><p id="2d2a360d-33e3-80bf-a5ff-d14d77660608" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 문제를 해결하기 위해 SAST(Static Application Security Testing) 도구를 결합하기로 했습니다. 대표적인 오픈소스 SAST 도구로는 CodeQL과 Semgrep이 있습니다. 저는 평소 취약점 분석을 할 때, CodeQL을 애용하기 때문에 당연하게도 CodeQL을 사용하려고 했었는데요.</span></span></span></p><p id="2d2a360d-33e3-8092-b6f1-fffce407dfc8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">CodeQL</span><span class="css-1kxrhf3">의 경우 다음과 같은 한계가 있었어요:</span></span></span></p><aside id="2d3a360d-33e3-8069-a5f2-fa0764013e45" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2d2a360d-33e3-80b0-b2f9-fdbd9dca028e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">프로젝트를 빌드하는 과정이 반드시 필요</span></span></span></li><li id="2d2a360d-33e3-80b2-8970-d95f6f1dc079" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">항상 빌드가 성공되는 Reliable한 DevOps 환경 구축 필요</span></span></span></li><li id="2d2a360d-33e3-80a6-83af-f64fe37faf1e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">빌드 과정에서 상당한 Compute cost 발생</span></span></span></li><li id="2d2a360d-33e3-8084-ac63-ca80a8e829a1" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">무엇보다 </span><span class="css-q3ktjb">라이선스 문제</span><span class="css-1kxrhf3">가 가장 컸어요 (오픈소스 프로젝트가 아니면 유료)</span></span></span></li></ul></div></aside><p id="2d2a360d-33e3-802f-94c9-d2c4737411f7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Semgrep</span><span class="css-1kxrhf3">은 훨씬 가벼웠어요:</span></span></span></p><aside id="2d3a360d-33e3-807e-b4b8-e1736d158f85" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2d2a360d-33e3-802d-aff0-f20b10b5b371" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">빌드 과정 불필요</span></span></span></li><li id="2d2a360d-33e3-80e4-b29b-c33ec6b5742e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">적은 Compute cost</span></span></span></li><li id="2d2a360d-33e3-80b7-9cdd-c89dbcd1c4eb" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">CodeQL만큼의 Semantic Analysis는 불가능하지만, 저희 목적에는 문제 없었어요</span></span></span></li></ul></div></aside><p id="2d2a360d-33e3-8010-b1b3-cdc37163eb83" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">왜냐하면 제가 SAST 도구로 하려는 건 취약점 분석이 아니라 </span><span class="css-q3ktjb">모든 Source→Sink 경로를 수집</span><span class="css-1kxrhf3">하는 것이었거든요.</span></span></span></p><h3 id="2d2a360d-33e3-80eb-88b7-f15b226a5b30" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">핵심 아이디어: 모든 입력 경로를 빠짐없이 분석하기</span></span></span></h3><p id="2d2a360d-33e3-80c7-ab0c-e315567b3d47" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">취약점은 결국 신뢰할 수 없는 입력(Untrusted Input)으로부터 발생합니다. 그래서 다음과 같은 전략을 세웠어요:</span></span></span></p><aside id="2d3a360d-33e3-807e-9ed8-c5afb9796444" class="css-nv7vyi"><div class="css-1vn47db"><ol class="css-hokoge"><li id="2d2a360d-33e3-80e7-8144-c78ffb533ea3" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">SAST로 모든 Source(입력)에서 Sink(함수)로 도달하는 경로를 수집</span></span></span></li><li id="2d2a360d-33e3-808a-8c8e-c1204cbf2ca9" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">수집된 모든 경로를 LLM이 빠짐없이 분석하게 함</span></span></span></li><li id="2d2a360d-33e3-8013-810b-d9ebfb13ab08" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 하면 취약점을 누락하는 경우는 없을 거라고 판단</span></span></span></li></ol></div></aside><p id="2d2a360d-33e3-80a2-844a-e5e5f9046b8b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실제로 이 방식을 적용하니 항상 취약점을 놓치지 않고 찾아내는 결과를 얻을 수 있었어요!</span></span></span></p><p id="2d2a360d-33e3-8040-b61c-f14f964bd4f6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2d2a360d-33e3-80cd-8a4b-e1850696d6e2" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">세 번째 벽: 비용의 현실</span></span></span></h2><p id="2d2a360d-33e3-80e2-8844-d016cc2aa5d7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그런데 문제가 또 생겼어요. 모든 입력 경로를 다 분석하게 했더니, 분석할 필요가 없는 코드까지 분석하느라 쓸데없는 토큰이 너무 많이 소모되는 거예요.</span></span></span></p><p id="2d2a360d-33e3-8040-bb47-f508284af223" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들어 총 100개의 경로가 있으면 XSS가 발생할 수 있는 경로는 10개 뿐인데, 나머지 90개의 의미없는 경로도 분석하는 상황이었죠. 토큰은 곧 비용이니까 반드시 해결해야 하는 문제였어요.</span></span></span></p><h3 id="2d2a360d-33e3-80b9-8f42-f8235ec59ca3" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Multi-Agent로 효율성 높이기</span></span></span></h3><p id="2d2a360d-33e3-80df-a681-caf7127ee446" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 문제는 Multi-Agent 시스템으로 해결할 수 있었어요. 3개의 에이전트로 구성했습니다:</span></span></span></p><aside id="2d3a360d-33e3-80c0-a9ff-d9a069f48fda" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2d2a360d-33e3-80e0-81ed-d9bc7c5d6cce" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Supervisor</span><span class="css-1kxrhf3">: Discovery와 Analysis 에이전트에게 상황에 맞는 적절한 지시를 내리는 감독관</span></span></span></li><li id="2d2a360d-33e3-8049-9d12-e22bd1bdce3e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Discovery</span><span class="css-1kxrhf3">: 수집된 모든 경로 중 취약점 발생 가능성이 높은 경로만 선별하는 필터</span></span></span></li><li id="2d2a360d-33e3-8009-a7e8-dee99ca953cb" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Analysis</span><span class="css-1kxrhf3">: Discovery가 선별한 경로에 대해서만 실제 취약점 분석 수행</span></span></span></li></ul></div></aside><p id="2d2a360d-33e3-8025-919a-fde9a7333b74" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 구성하니 Discovery 에이전트가 거름망 역할을 해줘서, 실질적으로 취약점 분석이 필요한 경로만 Analysis 에이전트가 처리할 수 있었어요. 덕분에 비용도 줄이고 전체 분석 시간도 단축할 수 있었습니다.</span></span></span></p><p id="2d2a360d-33e3-807b-99f3-d11019c6d857" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2d2a360d-33e3-80c5-93f8-cc71ffa3daa3" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">네 번째이자 가장 큰 벽: 지속 가능성</span></span></span></h2><p id="2d2a360d-33e3-801d-adbf-e099b1ab271c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">여기까지는 기술적으로 성공적이었지만, 가장 중요한 문제가 남아있었어요. 바로 </span><span class="css-q3ktjb">지속 가능성</span><span class="css-1kxrhf3">이었죠.</span></span></span></p><p id="2d2a360d-33e3-8005-8374-f15ce7e5f0d0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스에는 수백 개의 서비스가 있어요. 계산해보니:</span></span></span></p><aside id="2d3a360d-33e3-8046-9cd8-caa99fc09b34" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2d2a360d-33e3-80f9-a03f-fe5cf82e7eb3" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하나의 프로젝트에서 하루 3번 취약점 분석 수행</span></span></span></li><li id="2d2a360d-33e3-801c-a6f6-cc9574c2a50f" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1회 비용이 300원이라고 가정</span></span></span></li><li id="2d2a360d-33e3-80c7-95d9-c5ce77cf2574" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">300개 프로젝트만 돌려도: </span><span class="css-q3ktjb">3 × 300 × 300 = 270,000원/일</span></span></span></li><li id="2d2a360d-33e3-8089-b977-cd58c055cf84" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">한 달이면 </span><span class="css-q3ktjb">810만원</span><span class="css-1kxrhf3">...</span></span></span></li></ul></div></aside><p id="2d2a360d-33e3-8009-b1bf-dc3b6ea5b6da" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1회 비용을 100원으로 줄인다고 해도 월 270만원이니, 결코 지속 가능한 비용이 아니었어요.</span></span></span></p><h3 id="2d2a360d-33e3-80b2-95ef-e09f0a984611" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Open Model로의 전환</span></span></span></h3><p id="2d2a360d-33e3-8009-bffd-f849ea58f049" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 문제를 해결하려면 </span><span class="css-q3ktjb">Cloud Model이 아닌 Open Model을 사용해야 했습니다.</span><span class="css-1kxrhf3"> OpenAI도 GPT-OSS 같은 오픈 모델을 공개하고 있고, 이런 모델을 직접 호스팅하면 LLM 비용이 발생하지 않거든요.</span></span></span></p><p id="2d2a360d-33e3-8063-a1aa-d7eb91fc6a17" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">물론 Cloud Model보다 성능이나 안정성은 떨어지기 때문에, 이를 보완하기 위한 추가적인 노력이 필요했어요.</span></span></span></p><h3 id="2d2a360d-33e3-80c7-b413-e925a6a3a36d" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">후보 모델 선별과 ROI 비교</span></span></span></h3><p id="2d2a360d-33e3-80ac-bb40-d4265f9ec2e1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">취약점 분석에 적합하고 MCP 사용이 가능한 모델을 찾아본 결과, 3개 모델로 압축할 수 있었어요:</span></span></span></p><ul class="css-uswsmm"><li id="2d2a360d-33e3-800c-b7d3-c02466ab281c" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Qwen3:30B</span></span></span></li><li id="2d2a360d-33e3-80ec-a4a3-e88d1f31ebb9" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">gpt-oss:20B</span></span></span></li><li id="2d2a360d-33e3-8087-aa87-e7ac821c9118" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">llama3.1:8B</span></span></span></li></ul><p id="2d2a360d-33e3-80fb-a8d0-f902808299ff" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실제 여러 유형의 취약점이 존재하는 샘플 프로젝트에서 3개의 IDOR 취약점을 찾는 테스트를 진행했어요. 결과는 다음과 같았습니다:</span></span></span></p><div data-table-wrapper="true" class="css-1m7s5mg"><div role="table" class="css-cj2e11"><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">모델</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">분석률</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">정탐률</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">오탐률</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">Input 토큰</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">Output 토큰</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1y26ms3">Qwen3:30B</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">100% (14/14)</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">100% (3/3)</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">35.7% (5/14)</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">20,925</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">2,569</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1y26ms3">gpt-oss:20B</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">57.1% (8/14)</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">100% (3/3)</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">0% (0/8)</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">51,558</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">4,396</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1y26ms3">llama3.1:8B</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">28.6% (4/14)</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">16.7% (0.5/3)</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">87.5% (3.5/4)</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">6,563</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">1,413</span></div></div></div></div><p id="2d2a360d-33e3-8001-b739-c027561b8d51" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">비용 순위 (적은 토큰 소모)</span></span></span></p><p id="2d2a360d-33e3-807a-a23f-cac21465de0e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ llama3.1:8B
2️⃣ Qwen3:30B
3️⃣ gpt-oss:20B</span></span></span></p><p id="2d2a360d-33e3-8086-8fea-eb8e8e626e8e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">정확도 순위</span></span></span></p><p id="2d2a360d-33e3-809a-8d00-fc3bec29cf0d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ Qwen3:30B
2️⃣ gpt-oss:20B
3️⃣ llama3.1:8B </span></span></span></p><p id="2d2a360d-33e3-804b-ae01-d3b63ed5ef06" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">여기서 </span><span class="css-q3ktjb">분석률</span><span class="css-1kxrhf3">은 모든 입력 경로에 대한 Coverage, </span><span class="css-q3ktjb">정탐률</span><span class="css-1kxrhf3">은 실제 취약점을 정확히 찾은 비율, </span><span class="css-q3ktjb">오탐률</span><span class="css-1kxrhf3">은 취약점이 아닌 것을 취약점으로 잘못 판단한 비율이에요.</span></span></span></p><p id="2d2a360d-33e3-8048-ba4b-f68f43e1cf17" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">발생 비용과 정확도를 종합적으로 고려했을 때 </span><span class="css-q3ktjb">Qwen3:30B</span><span class="css-1kxrhf3">가 가장 준수한 성능을 보였어요. gpt-oss는 정탐률과 오탐률에서 완벽한 결과를 보였지만, 커버리지가 떨어지고 MCP Tool Calling이 실패하는 경우가 잦았거든요.</span></span></span></p><p id="2d2a360d-33e3-80f6-befe-ed70707c4338" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Qwen3:30B 관련 논문이나 시장 평가를 보니 취약점 분석에서 좋은 성능을 보인다는 평가가 많아서 최종적으로 선택했어요.</span></span></span></p><p id="2d2a360d-33e3-80c7-a3fc-e5dfdba683a2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2d2a360d-33e3-8008-a2e4-ff1905128834" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">성능 보완 작업</span></span></span></h2><p id="2d2a360d-33e3-804c-8d83-e3b3e2f2e191" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Open Model은 아무래도 Cloud Model보다 성능이 떨어지기 때문에 보완하는 작업이 필요했어요:</span></span></span></p><aside id="2d3a360d-33e3-8095-9d86-e939723db68c" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2d2a360d-33e3-80a4-9b73-f4cdbe878d22" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">시스템 프롬프트와 Human Message를 더 엄격하고 체계적으로 개선</span></span></span></li><li id="2d2a360d-33e3-806a-9bef-d1b29f88fd81" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">기존 Cloud Model에 맡겼던 처리량보다 더 작은 task 단위로 분할해서 처리</span></span></span></li><li id="2d2a360d-33e3-80eb-9334-d45e4a93971d" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">다양한 예외 상황에 대한 처리 로직 강화</span></span></span></li></ul></div></aside><p id="2d2a360d-33e3-801f-b6d1-f40866ac39e8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2d2a360d-33e3-80eb-b7d2-e4d2c388f58c" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">우리가 이뤄낸 결과</span></span></span></h2><p id="2d2a360d-33e3-8005-b3a7-f2ffe97d5795" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 과정을 거쳐 최종적으로 </span><span class="css-q3ktjb">정확도 95% 이상의 LLM 취약점 분석 자동화</span><span class="css-1kxrhf3">를 구현할 수 있었어요. 처음에는 단순히 ‘LLM으로 취약점 찾기’라는 아이디어로 시작했지만, 실제로는:</span></span></span></p><aside id="2d3a360d-33e3-8084-b6df-c61565b70e5f" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2d2a360d-33e3-809e-ad46-f76258d5be92" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">대용량 소스코드 처리 문제</span></span></span></li><li id="2d2a360d-33e3-8083-b229-e9d3c4e9b2bc" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">일관성 없는 결과 문제</span></span></span></li><li id="2d2a360d-33e3-80da-9c5f-d26b3a0a7dac" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">비용 효율성 문제</span></span></span></li><li id="2d2a360d-33e3-8051-bd86-cff6711b4598" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">지속 가능성 문제</span></span></span></li></ul></div></aside><p id="2d2a360d-33e3-80e1-867d-c304ab19786d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 4단계의 벽을 차례대로 넘어야 했어요. 각 단계마다 기술적 해결책 뿐만 아니라 비용과 운영 측면까지 고려해야 했고, 때로는 성능을 일부 포기하더라도 실용성을 택해야 하는 선택의 순간들이 있었죠.</span></span></span></p><p id="2d3a360d-33e3-8057-9cb4-fef9858f5172" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실제로 어떻게 이 프로젝트를 구현했는지에 대한 더 자세한 내용은, 2편에서 이어서 소개해 드릴게요. 많은 기대 부탁드립니다!</span></span></span></p><p id="2d2a360d-33e3-80d3-8c07-f79f6bb5657f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2d2a360d-33e3-8094-a82f-c0afb6a18d20" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">마치며</span></span></span></h2><p id="2d2a360d-33e3-8048-a569-d493b2d96449" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이번 프로젝트를 통해 배운 가장 중요한 교훈은 &quot;기술적으로 가능한 것&quot;과 &quot;실제로 운영 가능한 것&quot; 사이에는 큰 차이가 있다는 점이었어요. LLM 기술 자체는 충분히 성숙했지만, 이를 실제 서비스에 적용하려면 비용, 성능, 안정성, 지속 가능성을 모두 고려한 종합적인 설계가 필요했거든요.</span></span></span></p><p id="2d2a360d-33e3-8076-8779-fb76fe6f5a77" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">앞으로도 토스에서는 이런 실용적인 AI 활용 사례들을 더 많이 만들어갈 예정이에요. 기술은 결국 사람을 위해 존재하는 것이니까, 화려한 기술보다는 정말 도움이 되는 기술을 만드는 데 계속 집중하려고 합니다.</span></span></span></p><p id="2d2a360d-33e3-8048-834a-cd7ba198b159" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">긴 글 읽어주셔서 감사합니다.</span></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[AST로 Outdated 없는 퍼널 문서 만들기]]></title>
            <link>https://toss.tech/article/ast-funnel-visualization</link>
            <guid>https://toss.tech/article/ast-funnel-visualization</guid>
            <pubDate>Wed, 24 Dec 2025 05:31:00 GMT</pubDate>
            <description><![CDATA[소스코드 기반으로 복잡한 퍼널 이동을 시각화한 경험을 공유드립니다.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2caa360d-33e3-80bb-892c-fc16086c6393" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요, 토스코어 Business Onboarding Team 프론트엔드 개발자 조성륜입니다.</span></span></span></p><p id="2caa360d-33e3-80e4-ac94-d6effdadc472" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스팀에 합류하고 처음 받은 과제는 판매자 입점 퍼널을 이해하는 것이었습니다. 판매자 입점 퍼널은 </span><span class="css-q3ktjb">판매자가 토스페이에 가입하는 과정</span><span class="css-1kxrhf3">을 말해요.</span></span></span></p><blockquote id="2caa360d-33e3-805b-acda-c2058682b15d" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">&quot;이 페이지 다음에 어디로 가요?&quot;
&quot;음... 조건에 따라 달라요. 코드 보시면...&quot;</span></span></span></blockquote><p id="2caa360d-33e3-8090-b056-ce4451a585ed" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">39개의 페이지 파일을 하나씩 열어보며 며칠을 보냈습니다. 파일을 열 때마다 이런 코드가 나왔어요.</span></span></span></p><p id="2caa360d-33e3-803f-8fa0-e9ade02bf8d3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">39개 페이지가 82개의 서로 다른 조건으로 연결되어 있었습니다. 한 페이지에서 평균 2개 이상의 분기가 있는 셈이죠. 판매자 본인이 직접 신청하는지(대표자), 위임받은 사람이 신청하는지(대리인), 개인사업자인지 법인사업자인지, 본인인증 결과가 어떤지에 따라 경로가 달라졌습니다.</span></span></span></p><p id="2caa360d-33e3-80c1-9f91-e719f00f1457" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그리고 생각했어요.</span></span></span></p><blockquote id="2caa360d-33e3-8076-853c-e99013ce016e" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">&quot;어차피 코드에 다 있는 정보인데, 자동으로 문서를 만들 수 없을까?&quot;</span></span></span></blockquote><p id="2caa360d-33e3-8066-8621-c6c7ba5e48a5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 글에서는 코드를 분석해서 </span><span class="css-q3ktjb">&#x27;절대 Outdated 되지 않는 퍼널 문서&#x27;</span><span class="css-1kxrhf3">를 만든 경험을 공유합니다.</span></span></span></p><p id="2cea360d-33e3-8050-9292-ebc9358edb9e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2caa360d-33e3-8074-8b05-dc8df1152806" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">&quot;그 문서는 아직 최신화 안되어 있어요&quot;</span></span></span></h2><p id="2caa360d-33e3-80a7-977a-c6e62b8a40dc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">팀에 합류하고 가장 먼저 한 일은 기존 문서를 찾아보는 것이었습니다. ‘판매자 입점 퍼널 플로우’라는 문서가 있었어요. 페이지 간 연결을 화살표로 그린 다이어그램이었죠. &quot;오, 이거 보면 되겠다!&quot; 싶었습니다.</span></span></span></p><p id="2caa360d-33e3-804a-8c35-d98242406f9b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그런데 막상 코드를 보니 뭔가 이상했습니다.</span></span></span></p><blockquote id="2caa360d-33e3-80fb-9e1a-e708a3aa04be" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">&quot;문서에는 A 다음에 B로 가는데, 코드에서는 C로 가네요?&quot;
&quot;아, 그 문서는 아직 최신화 안되어 있어요. 코드를 보셔야 해요.&quot;</span></span></span></blockquote><p id="2caa360d-33e3-80e3-a1ad-ca413d9a7076" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">알고 보니 </span><span class="css-q3ktjb">3개월 전에 마지막으로 수정</span><span class="css-1kxrhf3">된 문서였습니다. 그 사이에 퍼널 구조가 여러 번 바뀌었지만, 문서는 업데이트되지 않은 거예요. 그래서 제가 직접 플로우차트를 다시 그려보기로 했습니다. 코드를 하나씩 읽으면서 문서에 정리했어요.</span></span></span></p><p id="2caa360d-33e3-80d2-8740-e98e659015d0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 금방 한계에 부딪혔습니다.</span></span></span></p><p id="2caa360d-33e3-8009-be88-e53c867e87c1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1. 조건부 분기를 표현하기 어려웠습니다</span></span></span></p><p id="2caa360d-33e3-80c2-9316-dac07cc8fe47" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">‘대표자이면서 개인사업자일 때’는 A로, ‘대리인이면서 법인일 때’는 B로 가는 건 그림으로 그리기 복잡했습니다. 화살표에 조건을 다 적으면 다이어그램이 읽을 수 없을 정도로 지저분해졌어요.</span></span></span></p><p id="2caa360d-33e3-80cb-92fe-ee834c8fee40" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2. 제가 그린 문서도 금방 Outdated 됐습니다</span></span></span></p><p id="2caa360d-33e3-8099-9a59-e6719167c81f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">열심히 그렸는데, 3일 뒤에 다른 팀원이 퍼널에 새 페이지를 추가했습니다. 제 문서는 이미 현실과 달라져 있었어요. 매번 코드가 바뀔 때마다 문서를 수정하는 건 현실적으로 불가능했습니다.</span></span></span></p><p id="2caa360d-33e3-8070-a904-d302137973dd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결국 같은 문제가 반복되는 거였죠. </span><span class="css-q3ktjb">수기로 작성한 문서는 결국 Outdated 됩니다.</span></span></span></p><figure id="2caa360d-33e3-8063-9012-e3a7a695a199" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/bafab48a-3e2b-41e0-8437-c35d099d0011/1224_tech_inner_1.png" alt="" class="css-1pgssrp"/></figure><p id="2cea360d-33e3-80dd-976f-e1aa43147fb7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2caa360d-33e3-803b-8e6d-e95373d8182d" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">런타임 vs 정적 분석</span></span></span></h2><p id="2caa360d-33e3-80e2-8b6d-cf7db96e5ddd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">코드에서 Navigation 정보를 추출하는 방법은 크게 두 가지입니다.</span></span></span></p><div data-table-wrapper="true" class="css-1m7s5mg"><div role="table" class="css-1emlqs7"><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">방식</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">설명</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">장점</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">단점</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1y26ms3">런타임 분석</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">실제로 코드를 실행하면서 어떤 경로로 가는지 기록</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">실제 동작 그대로</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">한 번에 한 경로만, 모든 케이스 실행 필요</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1y26ms3">정적 분석</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">코드를 텍스트로 읽어서 AST로 파싱</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">모든 경로를 한 번에, 빠르고 안전</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">동적 로직 파악 어려움</span></div></div></div></div><p id="2caa360d-33e3-804d-8b64-e91fe30b45af" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 </span><span class="css-q3ktjb">정적 분석</span><span class="css-1kxrhf3">을 선택했습니다.</span></span></span></p><aside id="2cea360d-33e3-8000-b00f-d6facf77cd15" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2caa360d-33e3-80ce-b538-c08eb5803cfb" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">🔍 </span><span class="css-q3ktjb">모든 경로를 한 번에 찾을 수 있습니다</span><span class="css-1kxrhf3">: 런타임에는 조건에 따라 한 경로만 실행되지만, 정적 분석은 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">if</span></code><span class="css-1kxrhf3">문 안의 모든 분기를 찾을 수 있어요.</span></span></span></li><li id="2caa360d-33e3-8031-b2fd-d39b090c5deb" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">⚡ </span><span class="css-q3ktjb">빠르고 안전합니다</span><span class="css-1kxrhf3">: 실제로 코드를 실행할 필요 없이, 소스코드만 읽으면 됩니다.</span></span></span></li><li id="2caa360d-33e3-80b0-bd9e-ccd1cec762eb" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">📍 </span><span class="css-q3ktjb">정확한 위치를 알 수 있습니다</span><span class="css-1kxrhf3">: &quot;이 Navigation은 applicant.tsx의 157번째 줄에 있어요&quot; 같은 정보를 얻을 수 있습니다.</span></span></span></li></ul></div></aside><p id="2caa360d-33e3-80e6-b6b8-c1ccb7875d00" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">AST(Abstract Syntax Tree)는 코드를 트리 구조로 표현한 것입니다. TypeScript 컴파일러가 코드를 이해하는 방식과 동일해요. </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">ts-morph</span></code><span class="css-1kxrhf3"> 라이브러리를 사용해서 소스코드를 AST로 파싱했습니다.</span></span></span></p><figure id="2caa360d-33e3-806f-9f72-eb1a05522608" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/452d93a7-f936-4c5d-9d2d-ef0db2439a65/1224_tech_inner_3.png" alt="" class="css-1pgssrp"/></figure><p id="2caa360d-33e3-8016-942b-e49ea784ecd3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2caa360d-33e3-8052-9858-d9018a5ddc46" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">코드에서 퍼널 흐름을 추출하기까지</span></span></span></h2><p id="2caa360d-33e3-80a3-9529-eb5cfadd7c8b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">‘코드를 읽어서 Navigation을 추출한다’는 아이디어는 간단하지만, 실제로 구현하려면 여러 단계가 필요합니다. 하나씩 풀어가 볼게요.</span></span></span></p><h3 id="2caa360d-33e3-8032-b310-c912c24e66cd" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Step 1. 분석할 페이지 파일 찾기</span></span></span></h3><p id="2caa360d-33e3-8028-bd19-ee9e7f6fa875" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">먼저 39개의 페이지 파일을 찾아야 합니다. Next.js 프로젝트에서 페이지는 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">src/pages/</span></code><span class="css-1kxrhf3"> 디렉토리에 있고, 각 페이지의 진입점은 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">index.tsx</span></code><span class="css-1kxrhf3">나 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">universal.tsx</span></code><span class="css-1kxrhf3"> 파일입니다.</span></span></span></p><p id="2caa360d-33e3-8044-99e7-f3ad8129d772" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">components/</span></code><span class="css-1kxrhf3">나 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">hooks/</span></code><span class="css-1kxrhf3"> 폴더는 페이지가 아니니까 제외합니다. </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">_app.tsx</span></code><span class="css-1kxrhf3"> 같은 특수 파일도 제외하고요. 이렇게 하면 순수하게 </span><span class="css-q3ktjb">페이지 컴포넌트</span><span class="css-1kxrhf3">만 남습니다.</span></span></span></p><h3 id="2caa360d-33e3-80ed-8934-dfbf130e1c9e" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Step 2. Navigation Edge 데이터 구조 설계</span></span></span></h3><p id="2caa360d-33e3-8019-91fc-c68640a790c8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">코드를 분석하기 전에, </span><span class="css-q3ktjb">어떤 정보를 추출할지</span><span class="css-1kxrhf3"> 먼저 정해야 했습니다. 처음에는 단순하게 ‘A 페이지에서 B 페이지로 간다’만 저장하려고 했어요.</span></span></span></p><p id="2caa360d-33e3-8028-b4d6-d7b5f4c310e2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그런데 이것만으로는 부족했습니다. 다이어그램을 봐도 </span><span class="css-q3ktjb">왜 이 경로로 가는지</span><span class="css-1kxrhf3">, </span><span class="css-q3ktjb">어떤 조건일 때 가는지</span><span class="css-1kxrhf3"> 알 수 없었어요. 결국 코드를 다시 찾아가야 했죠.</span></span></span></p><p id="2caa360d-33e3-8028-95ab-cdf3b97a600e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">고민 끝에 </span><span class="css-q3ktjb">Navigation의 맥락 정보</span><span class="css-1kxrhf3">까지 함께 저장하기로 했습니다.</span></span></span></p><p id="2caa360d-33e3-80e6-8e5e-cdb32951c8d5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">각 필드를 이렇게 설계한 이유가 있습니다:</span></span></span></p><div data-table-wrapper="true" class="css-1m7s5mg"><div role="table" class="css-crnt2r"><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">필드</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">왜 필요한가</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">method</span></code></div><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">push</span></code><span class="css-1mjnzsq">는 뒤로가기 가능, </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">replace</span></code><span class="css-1mjnzsq">는 불가능. 사용자 경험에 영향을 주므로 구분 필요</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">condition</span></code></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">&quot;대표자일 때만 이 경로로 간다&quot; 같은 분기 조건을 알아야 퍼널 로직 이해 가능</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">queryParams</span></code></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">다음 페이지에 어떤 상태를 전달하는지 파악 가능</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">lineNumber</span></code></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">다이어그램에서 코드로 바로 점프할 수 있음</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">sourceType</span></code></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">페이지 직접 호출인지 훅 내부 호출인지 구분해야 디버깅이 쉬움</span></div></div></div></div><p id="2caa360d-33e3-8099-aaba-d6eafb78f677" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 구조가 이후 모든 분석의 기반이 됩니다.</span></span></span></p><figure id="2caa360d-33e3-8025-9e41-ff8e3f0d64f4" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/cdaddef7-9778-4707-ba72-624f37a9c5d5/1224_tech_inner_2.png" alt="" class="css-1pgssrp"/></figure><h3 id="2caa360d-33e3-8017-9032-d2d7e2b1cbd6" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Step 3. 페이지에서 Navigation 패턴 추출하기</span></span></span></h3><p id="2caa360d-33e3-80a7-aec8-f166760a2aa0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이제 각 페이지 파일을 AST로 파싱해서 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">router.push()</span></code><span class="css-1kxrhf3">, </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">router.replace()</span></code><span class="css-1kxrhf3"> 같은 Navigation 호출을 찾습니다.</span></span></span></p><p id="2caa360d-33e3-805f-8131-ca2965fac8ed" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">핵심은 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">getDescendantsOfKind(SyntaxKind.CallExpression)</span></code><span class="css-1kxrhf3">입니다. 파일 전체에서 </span><span class="css-q3ktjb">모든 함수 호출</span><span class="css-1kxrhf3">을 찾아온 뒤, 그중에서 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">router.push()</span></code><span class="css-1kxrhf3">나 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">router.replace()</span></code><span class="css-1kxrhf3"> 패턴인지 확인합니다.</span></span></span></p><p id="2caa360d-33e3-80e9-99f7-d2d3a5c5093c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">조건문(</span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">condition</span></code><span class="css-1kxrhf3">)은 어떻게 추출할까요? Navigation 노드를 찾으면 </span><span class="css-q3ktjb">AST를 부모 방향으로 거슬러 올라가면서</span><span class="css-1kxrhf3"> 가장 가까운 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">if</span></code><span class="css-1kxrhf3">문이나 삼항 연산자를 찾습니다.</span></span></span></p><p id="2caa360d-33e3-804e-97c0-ebcc6edfbccb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 하면 </span><span class="css-q3ktjb">어떤 조건일 때 이 경로로 가는지</span><span class="css-1kxrhf3">까지 알 수 있어요.</span></span></span></p><figure id="2caa360d-33e3-80f1-80b5-f0412028cc4d" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/039553cc-1f2d-4e27-9212-22cc635e715e/1224_tech_inner_4.png" alt="" class="css-1pgssrp"/></figure><h3 id="2caa360d-33e3-801f-8f6e-d03f49ee7877" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Step 4. 커스텀 훅 안에 숨어있는 Navigation 찾기</span></span></span></h3><p id="2caa360d-33e3-80a7-954d-eb0d26605b87" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">페이지 파일만 분석하면 놓치는 Navigation이 있습니다. 로직이 커스텀 훅으로 분리된 경우예요.</span></span></span></p><p id="2caa360d-33e3-809b-a4c8-c7ed4d0f0c41" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">페이지 컴포넌트만 분석하면 이 Navigation을 놓치게 됩니다. 그래서 </span><span class="css-q3ktjb">페이지가 import하는 훅을 역추적</span><span class="css-1kxrhf3">하는 방식을 사용했습니다.</span></span></span></p><p id="2caa360d-33e3-802c-a2ca-cfcf752da8a2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 찾은 훅 파일을 다시 AST로 파싱해서 Navigation 호출이 있는지 확인합니다.</span></span></span></p><p id="2caa360d-33e3-80d9-bedd-ec6fb1cf2499" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">훅에서 Navigation을 찾으면, 해당 훅을 사용하는 페이지에서 나가는 edge로 기록합니다. 출처도 함께 기록해서 나중에 ‘이 Navigation은 훅에서 온 것’임을 알 수 있게 했어요.</span></span></span></p><h3 id="2caa360d-33e3-8041-ab1c-f8a6bc73fa83" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Step 5. URL 상수를 실제 경로로 변환하기</span></span></span></h3><p id="2caa360d-33e3-8033-8e6d-cda066e3ee57" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">여기까지 하면 Navigation edge들이 추출되는데, 문제가 있습니다. 도착지가 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">URLS.FUNNEL.PAY_METHOD</span></code><span class="css-1kxrhf3"> 같은 </span><span class="css-q3ktjb">상수 형태</span><span class="css-1kxrhf3">예요.</span></span></span></p><p id="2caa360d-33e3-80a1-95d5-f92065c295d1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 URL 상수 파일을 AST로 파싱해서 </span><span class="css-q3ktjb">상수 → 실제 경로</span><span class="css-1kxrhf3"> 매핑 테이블을 만듭니다.</span></span></span></p><h3 id="2caa360d-33e3-8030-80f4-d39ffd1d0145" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Step 6. 그래프 구축하기</span></span></span></h3><p id="2caa360d-33e3-80c1-9026-e1541a760228" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이제 모든 edge를 모아서 그래프를 만들 차례입니다. 이 과정에서 </span><span class="css-q3ktjb">진입점</span><span class="css-1kxrhf3">과 </span><span class="css-q3ktjb">이탈점</span><span class="css-1kxrhf3">도 자동으로 분류합니다.</span></span></span></p><h3 id="2caa360d-33e3-8049-8de0-d8169e25009a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Step 7. Mermaid 다이어그램 생성하기</span></span></span></h3><p id="2caa360d-33e3-80cc-8e50-c7f3412372fd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">마지막으로 그래프를 Mermaid 문법의 플로우차트로 변환합니다.</span></span></span></p><p id="2caa360d-33e3-8019-be64-d528e2941650" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">push</span></code><span class="css-1kxrhf3">는 단일 화살표(</span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">--&gt;</span></code><span class="css-1kxrhf3">), </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">replace</span></code><span class="css-1kxrhf3">는 이중 화살표(</span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">==&gt;</span></code><span class="css-1kxrhf3">)로 구분합니다. 브라우저 히스토리에 남는지 여부가 다르니까, 시각적으로도 구분해주는 거예요.</span></span></span></p><p id="2cea360d-33e3-8070-ad3d-e83bacedfe52" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2caa360d-33e3-8042-a2f6-f17a08b2c353" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">완성된 다이어그램, 그리고 효과</span></span></span></h2><p id="2caa360d-33e3-80e7-9657-c58908610437" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">최종적으로 생성되는 다이어그램 예시입니다.</span></span></span></p><figure id="2d1a360d-33e3-80dd-87e8-eed203ab585a" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/a5543037-7f52-40d4-94c1-8275eea7bb8d/1224_tech_inner_5.png" alt="" class="css-1pgssrp"/></figure><aside id="2cea360d-33e3-80a0-a81a-f5920ff9ecda" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2caa360d-33e3-80d8-a5af-f293748b81c1" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">진입점(파란색)에서 시작해서 조건에 따라 분기</span></span></span></li><li id="2cea360d-33e3-8007-b064-ef2ffd63fd93" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이탈점(빨간색)에 도달하는 과정을 한눈에</span></span></span></li><li id="2cea360d-33e3-80f3-a5a1-e6a6ecb9c0a1" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">화살표 라벨에 조건문과 쿼리 파라미터 표시</span></span></span></li><li id="2cea360d-33e3-80ab-bc59-f29e5a69121f" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이중 화살표(</span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">==&gt;</span></code><span class="css-1kxrhf3">)는 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">replace</span></code><span class="css-1kxrhf3">, 단일 화살표(</span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">-&gt;</span></code><span class="css-1kxrhf3">)는 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">push</span></code></span></span></li></ul></div></aside><p id="2caa360d-33e3-8008-a323-e4780d959b1f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="2caa360d-33e3-801c-9480-f6fca900b717" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/1a21f1d1-ed74-4908-9e71-e80f1cc8fbe9/Untitled_diagram-2025-12-13-141426_(5).png" alt="" class="css-1pgssrp"/></figure><p id="2caa360d-33e3-80ba-868a-f4be23c283f9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2caa360d-33e3-80bc-ab9f-f3b51855cf0c" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">무엇이 바뀌었나</span></span></span></h3><p id="2caa360d-33e3-804f-86ae-d34fc9511c77" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1. 신규 입사자 온보딩 시간 단축</span></span></span></p><p id="2caa360d-33e3-8084-819a-fcc38468aa4f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">‘판매자 입점 퍼널이 어떻게 돌아가는지’를 설명할 때, 이제 다이어그램 하나면 충분합니다. 39개 파일을 읽을 필요 없이, 전체 흐름을 한눈에 보여줄 수 있어요.</span></span></span></p><p id="2caa360d-33e3-80cf-a329-e5917069abf7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2. 영향 범위 파악이 쉬워짐</span></span></span></p><p id="2caa360d-33e3-80f5-9995-f2602428cb39" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">&quot;이 페이지를 수정하면 어디에 영향을 주지?&quot;라는 질문에 바로 답할 수 있습니다. 다이어그램에서 해당 노드에서 뻗어나가는 화살표만 보면 되니까요. 예를 들어 신청자 정보 페이지에서는 6개의 서로 다른 경로가 있고, 각각 어떤 조건일 때 실행되는지 한눈에 파악할 수 있어요.</span></span></span></p><p id="2caa360d-33e3-80e7-a8f4-ef7bef0c96d4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">3. 데드엔드 발견</span></span></span></p><p id="2caa360d-33e3-8064-84e4-f1c6be39dc82" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이탈점이 아닌데 나가는 edge가 없는 페이지(데드엔드)를 자동으로 찾을 수 있습니다. 실제로 개발 중에 실수로 Navigation을 빼먹은 페이지를 발견하기도 했어요.</span></span></span></p><p id="2caa360d-33e3-808b-997e-db7caea5299c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">4. 코드 변경과 문서 동기화</span></span></span></p><p id="2caa360d-33e3-80e9-b663-d5a21ad4cc46" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">코드를 변경하면, 스크립트를 다시 실행하는 것만으로 문서가 자동으로 업데이트됩니다. 더 이상 &quot;문서가 Outdated 됐는지&quot; 걱정할 필요가 없어요.</span></span></span></p><p id="2cea360d-33e3-8076-b120-f65a2a59024d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2caa360d-33e3-80db-89fc-e6ad32a4e993" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">마치며</span></span></span></h3><p id="2caa360d-33e3-8046-a989-fe0f6f2b750c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">신규 입사자로서 처음 마주한 39개의 페이지 파일들. &quot;이 페이지는 어디로 연결되지?&quot;를 파악하는 데만 며칠이 걸렸습니다. 하지만 그 경험이 이 도구를 만드는 출발점이 되었어요.</span></span></span></p><p id="2caa360d-33e3-80f2-9f44-ca7660f4013c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">신규 입사자의 시선이 오히려 도움이 됐습니다.</span><span class="css-1kxrhf3"> 팀원들에게는 익숙한 것들이, 처음 보는 사람에게는 명확한 Pain Point로 보이거든요. 그 불편함을 ‘원래 그런 거니까’로 넘기지 않고, 실제 코드베이스를 활용해 해결책을 만들 수 있었습니다.</span></span></span></p><p id="2caa360d-33e3-80e6-a19a-d5cb4d58c920" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문서화는 항상 &quot;중요하지만 급하지 않은&quot; 일로 밀려나기 쉽습니다. AST를 활용하면 코드가 변경될 때마다 자동으로 동기화되는, </span><span class="css-q3ktjb">절대 Outdated 되지 않는 문서</span><span class="css-1kxrhf3">를 만들 수 있어요.</span></span></span></p><p id="2caa360d-33e3-80c0-a251-caa73165a667" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">비슷한 고민이 있으시다면, 꼭 퍼널이 아니더라도 정적 분석으로 해결할 수 있는 문제가 많습니다. 라우팅 구조, 컴포넌트 의존성, API 호출 패턴 등 코드에 있는 정보를 자동으로 추출하고 시각화 해보세요.</span></span></span></p><p id="2caa360d-33e3-80e1-b8f3-fbca0cf94c1c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 글을 읽고 궁금한 점이나 비슷한 경험이 있으시다면 댓글로 공유해주세요!</span></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[세금 환급 자동화 : AI-driven UI 테스트 자동화 일지]]></title>
            <link>https://toss.tech/article/ai-driven-ui-test-automation</link>
            <guid>https://toss.tech/article/ai-driven-ui-test-automation</guid>
            <pubDate>Wed, 24 Dec 2025 02:53:00 GMT</pubDate>
            <description><![CDATA[QA가 코드를 거의 치지 않아도, 자동화 시스템은 완성될 수 있을까?
AI에게 99%를 맡긴다면, 품질을 지킬 수 있을까?]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2caa360d-33e3-807e-870d-d313841a017a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요, 토스인컴 QA Manager 정수호입니다.</span></span></span></p><p id="2caa360d-33e3-808b-8be4-d3313beb0421" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스인컴의 세금환급 서비스는 복잡합니다. 연말정산, 현금영수증, 세금비서, 숨은환급찾기 네 가지 서비스가 각각 다른 UX와 인증 방식을 사용하고, 공제 항목만 해도 의료비·인적공제·전월세·주담대·중소기업 감면 등 수십 가지가 넘어요. 여기에 실험 그룹, 약관 종류, 홈택스 스크래핑 서버 상태까지 더해지면 테스트해야 할 플로우는 금세 수십 가지 조합으로 늘어나죠.</span></span></span></p><p id="2caa360d-33e3-80e8-8231-cb88688fc613" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2caa360d-33e3-8093-a605-f382dd4a9b25" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2025년 7월, 저는 이 모든 것을 혼자 커버해야 하는 상황에 놓였습니다. </span></span></span></p><p id="2caa360d-33e3-802e-adbe-e803451bcb6b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">자동화가 필요하다는 건 모두가 알고 있었지만, 현실적인 문제가 남았어요. E2E 테스트 하나를 만드는 데 4~8시간이 걸리고, 40개를 만들려면 160~300시간이 필요했습니다. UI나 정책이 바뀔 때마다 테스트를 다시 손봐야 했고, 혼자 만들고 운영하고 회고까지 해야 했죠.</span></span></span></p><p id="2caa360d-33e3-807c-a002-fd56ddaac984" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2caa360d-33e3-8182-aef2-ceeb64f39b5d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 저는 조금 다른 질문을 던졌습니다.</span></span></span></p><blockquote id="2caa360d-33e3-8127-818b-d122bb29cb61" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“QA가 코드를 직접 치지 않아도 된다면 어떨까?”
</span><span class="css-q3ktjb">“AI를 진짜 팀원처럼 활용해서, 99%를 맡기면 어떨까?”</span></span></span></blockquote><p id="2caa360d-33e3-81ac-9178-cacd62573c80" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 글은 그 질문을 2025년 7월부터 11월까지 </span><span class="css-q3ktjb">진짜 서비스 환경에서 </span><span class="css-1kxrhf3">5개월 동안 실험한 이야기입니다. 결론부터 말하면, AI 3명 + 사람 1명이 함께 4~5명 규모의 자동화 팀이 낼 만큼의 결과를 만들었어요.</span></span></span></p><p id="2cba360d-33e3-802b-a82b-f2b9e5528adb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2caa360d-33e3-8077-a8b9-e61a29538943" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">왜 AI였을까?</span></span></span></h2><p id="2caa360d-33e3-80a0-af37-db1e8fe47735" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">세금 환급 서비스 자동화는 일반적인 웹 서비스보다 난이도가 훨씬 높았습니다. 단순히 단계가 많기 때문이 아니라, </span><span class="css-q3ktjb">각 단계가 서로 다른 시스템·정책·외부 연동에 의존하며 동시에 움직이기 때문</span><span class="css-1kxrhf3">이에요.</span></span></span></p><h3 id="2caa360d-33e3-8006-b70e-ebfcece06f83" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1. 플로우 자체가 복잡했습니다</span></span></span></h3><p id="2caa360d-33e3-80d0-99fa-de103df3998e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">환급 플로우는 평균 15~20단계를 넘어갑니다. 그 자체로도 길지만, 더 큰 문제는 </span><span class="css-q3ktjb">각 단계가 서로 다른 시스템 특성</span><span class="css-1kxrhf3">을 가진다는 점이었어요.</span></span></span></p><aside id="2caa360d-33e3-8034-81dd-c2d66dca81bf" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2caa360d-33e3-8088-a2dc-ef0bbab00799" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">로그인 → 내부 인증 시스템</span></span></span></li><li id="2caa360d-33e3-80ad-978d-c61a50b71647" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">공제 선택 → 정책 엔진</span></span></span></li><li id="2caa360d-33e3-8002-8931-eb8553884c25" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">스크래핑 → 외부 공공기관 API</span></span></span></li><li id="2caa360d-33e3-80f7-90f1-f6f385faaf85" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">환급 금액 → 엔진 계산 결과</span></span></span></li><li id="2caa360d-33e3-80f8-912a-c5fced0e6f56" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결제 → 페이 연동</span></span></span></li></ul></div></aside><p id="2caa360d-33e3-8025-ac6a-ee9dea321459" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 모든 과정이 한 번에 이어지는 </span><span class="css-q3ktjb">장거리 릴레이</span><span class="css-1kxrhf3">처럼 작동합니다. 단 한 단계라도 타이밍이 어긋나거나 외부 시스템 상태가 달라지면 전체 플로우가 실패할 수 있어요. 게다가 UI는 React 기반입니다. 사용자에게는 자연스러운 애니메이션이나 오버레이가 E2E 테스트 입장에서는 </span><span class="css-q3ktjb">클릭 미스, 전환 실패, 대기 타임아웃</span><span class="css-1kxrhf3">으로 이어지곤 해요.</span></span></span></p><p id="2caa360d-33e3-8011-a696-caa0ed8e6347" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 자동화 관점에서는 </span><span class="css-181w7b3">‘</span><span class="css-ptbvf1">정상 케이스를 한 번 구현하는 것보다, 매일 안정적으로 반복 실행하게 만드는 것’</span><span class="css-1kxrhf3">이 훨씬 어려운 일이었습니다.</span></span></span></p><h3 id="2caa360d-33e3-80a8-a337-d8cbde1881e8" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2. UI와 정책이 ‘자주 그리고 크게’ 바뀌었습니다</span></span></span></h3><p id="2caa360d-33e3-8082-8baa-c5b5cf8b876e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">외부에서 보면 가벼운 UI 수정처럼 느껴질 수 있지만, 자동화에서는 매우 큰 변경입니다.
예를 들어:</span></span></span></p><aside id="2cba360d-33e3-80db-afd2-ed3731fa64b8" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2caa360d-33e3-8032-8b21-ff9ca3a0f0ce" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">버튼 문구가 ‘공제 수정하기’ → ‘입력한 정보 수정하기’로 바뀐다</span></span></span><div class="css-1vn47db"><p id="2caa360d-33e3-80a3-9aaf-d04f5a96416e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">→ 자동화는 해당 버튼을 찾지 못하고 시나리오가 즉시 중단됩니다.</span></span></span></p></div></li><li id="2cba360d-33e3-8006-9e7a-e207464d25eb" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">질문이 하나 추가된다</span></span></span><div class="css-1vn47db"><p id="2cba360d-33e3-80c5-a264-e11983ba14fd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">→ 예상하지 못한 화면이 등장하고 전체 플로우가 달라집니다.</span></span></span></p></div></li><li id="2cba360d-33e3-8096-a5a3-f1e69dd4c56a" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">스크래핑 UI가 개편된다</span></span></span><div class="css-1vn47db"><p id="2cba360d-33e3-8083-8d16-ffbcc31f8458" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">→ 대기 방식, 전환 타이밍, DOM 구조까지 모두 다시 설계해야 합니다.</span></span></span></p></div></li></ul></div></aside><p id="2caa360d-33e3-80d8-a28d-e70f92277ef7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">즉, </span><span class="css-q3ktjb">사람에게는 사소해 보이는 UI 변화가</span><span class="css-1kxrhf3">, 자동화에게는 </span><span class="css-q3ktjb">시나리오 전체를 다시 구성해야 하는 큰 변경</span><span class="css-1kxrhf3">으로 다가오죠. 실제로 7월부터 11월까지 내부 변경 내역을 보면 난이도가 체감됩니다.</span></span></span></p><aside id="2caa360d-33e3-8057-be3e-efafed0431a8" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2caa360d-33e3-80ee-8463-c0518b6432af" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">7월: 스크래핑 단계 UI 개편</span></span></span></li><li id="2caa360d-33e3-8084-a422-ea1fcd747000" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">8월: 많은 실험을 통한 일단위 문구변경 ex) &#x27;입력한 정보 수정하기&#x27; → &#x27;공제 수정&#x27; 문구 변경</span></span></span></li><li id="2caa360d-33e3-8006-93ab-e84bf8497ec5" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">9월: 프론트엔드 리팩토링 및 컴포넌트 대규모 업데이트</span></span></span></li><li id="2caa360d-33e3-8029-8918-dea9ad901cf2" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">10월: 월세 공제 질문 추가</span></span></span></li><li id="2caa360d-33e3-8027-8c1c-fc9b8e1e6da7" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">11월: 세금비서·현금영수증·더 낸 연말정산 받기 서비스 별로 다르게 약관 개선</span></span></span></li></ul></div></aside><p id="2caa360d-33e3-8014-8a5a-fabc1138fe8f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 변화들은 개발자에게는 금방 고칠 수 있는 UI 수정일지 몰라도, 자동화 테스트는 </span><span class="css-q3ktjb">셀렉터, 대기 전략, 분기 흐름을 모두 다시 손봐야 하는 수준</span><span class="css-1kxrhf3">이었습니다. 그래서 하드코딩 된 테스트는 매번 흔들릴 수밖에 없었어요.</span></span></span></p><h3 id="2caa360d-33e3-813f-8146-ca5e16f72230" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3. 불안정한 환경</span></span></span></h3><p id="2caa360d-33e3-8160-97aa-f3a98d73e446" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실험 그룹에 따라 화면이 달라지고, 스크래핑 탭이 열렸다 닫혔다 하며 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">Target closed</span></code><span class="css-1kxrhf3">가 발생하고, 도메인도 환경마다 달랐습니다. 이런 상황에서 35개의 시나리오를 모두 자동화로 커버하려면 </span><span class="css-q3ktjb">사람 중심의 개발 방식으로는 절대 불가능했어요. </span><span class="css-1kxrhf3">그래서 선택했습니다.</span></span></span></p><blockquote id="2caa360d-33e3-8111-aff5-d5aa68a13352" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“AI가 코드를 짜고,
사람은 문제 정의와 품질 검증에 집중한다.”</span></span></span></blockquote><p id="2cba360d-33e3-804b-a087-dc305c052304" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2caa360d-33e3-811e-b403-e5d79ffb816a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">우리가 사용한 AI 도구들</span></span></span></h3><p id="2caa360d-33e3-812d-85fc-cde37d2c519f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">AI를 하나만 쓴 건 아니었습니다. 각 도구는 서로 다른 강점을 가지고 있었어요.</span></span></span></p><p id="2caa360d-33e3-81c7-87a8-cce98085c3cd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1️⃣ Claude Sonnet 4.5 (Claude Code)
</span><span class="css-1kxrhf3">메인 개발자 역할을 맡았어요. 테스트 코드, 유틸 함수, 리팩토링, 문서화까지 대부분을 담당했습니다. 그리고 Claude를 세 가지 </span><span class="css-q3ktjb">페르소나</span><span class="css-1kxrhf3">로 나눠 일했습니다.</span></span></span></p><aside id="2d3a360d-33e3-80c5-b817-e0a80e2dbcd8" class="css-nv7vyi"><div class="css-1vn47db"><ol class="css-hokoge"><li id="2cba360d-33e3-80e6-b861-e66cb8b4f337" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">SDET</span><span class="css-1odxvuk">(Software Development Engineer in Test)</span><span class="css-q3ktjb"> Agent</span><span class="css-1kxrhf3"> — 테스트 설계 및 아키텍처</span></span></span></li><li id="2cba360d-33e3-8059-a7b8-c9f453559953" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Documentation Specialist</span><span class="css-1kxrhf3"> — 문서 구조화 및 일지 자동 생성</span></span></span></li><li id="2cba360d-33e3-800a-b823-e5b3fd6aa3db" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Git Master</span><span class="css-1kxrhf3"> — 커밋/PR/변경 요약</span></span></span></li></ol></div></aside><p id="2caa360d-33e3-81b7-83e2-c821f31e710b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2️⃣ Cursor
</span><span class="css-1kxrhf3">IDE 안의 페어 프로그래머처럼, type 에러와 import 문제를 바로바로 해결해줬습니다.</span></span></span></p><p id="2caa360d-33e3-817a-ac2c-d78f4ee47ae2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">3️⃣ Codex
</span><span class="css-1kxrhf3">코드 분석과 비교에 강했습니다. “이 테스트 두 개의 차이는 무엇인가?” 같은 질문에 아주 강했어요.</span></span></span></p><p id="2cba360d-33e3-8066-ad46-f8fddb1089fc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2caa360d-33e3-81a5-88ae-cf690b7c8774" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">AI 팀원들 – 실제로는 이렇게 일했다</span></span></span></h2><h3 id="2caa360d-33e3-8176-9358-c959c37908cd" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">🤖 SDET Agent - 테스트 설계와 아키텍처 담당</span></span></span></h3><p id="2caa360d-33e3-81f9-bac9-cf150b6e5f16" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1) Page Object Model 도입 (7월 말)</span></span></span></p><p id="2caa360d-33e3-814a-8d0a-db0d97cb9b90" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">테스트가 5개쯤 되었을 때, 코드가 복잡해지기 시작했습니다.</span></span></span></p><blockquote id="2caa360d-33e3-817d-af93-c9639cca2f39" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">나: “셀렉터가 너무 많고 중복돼. 유지보수가 걱정돼.”
SDET Agent: “Page Object Model로 바꿔볼까요?”</span></span></span></blockquote><p id="2caa360d-33e3-812c-9d28-fd67319f8899" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그리고 10분 뒤 Claude는 이런 파일을 만들어줬습니다.</span></span></span></p><p id="2caa360d-33e3-8111-9de9-f15ca8e8e2e6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이후로 셀렉터 변경은 </span><span class="css-q3ktjb">딱 한 곳만 고치면 끝</span><span class="css-1kxrhf3">이었어요. 일지에도 이렇게 남아 있습니다.</span></span></span></p><blockquote id="2caa360d-33e3-81dd-9603-c3e6b7b0fb0e" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“중복 셀렉터 스트레스가 사라졌다.” — </span><span class="css-1odxvuk">8월 자동화 일지</span></span></span></blockquote><p id="2cba360d-33e3-8082-9f88-c8c2f58450e8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2cba360d-33e3-8069-9bfb-f21d454ae5b0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2) 약관(동의) 플로우 자동 정리 (9월 12일)</span></span></span></p><p id="2cba360d-33e3-80a2-ad25-ef69343be701" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1odxvuk">“세금비서에서 약관 한 줄이 추가되면서 기존 자동화가 모두 멈췄어요.”</span></span></span></p><p id="2cba360d-33e3-80bc-967b-f2d157fa8cf0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문제는 약관이 서비스마다, 유입 경로마다 다르다는 점이었습니다. 숨은환급금찾기 / 세금비서 / 현금영수증 / 더낸 연말정산 돌려받기 서비스는 </span><span class="css-q3ktjb">약관 개수, 순서, 명칭까지 전부 달라요.</span></span></span></p><p id="2cba360d-33e3-8004-bcd3-ccf6787f584e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">AI에게 요청했습니다.</span></span></span></p><blockquote id="2cba360d-33e3-804d-8f17-c2a6303645ca" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">나: “서비스별로 약관 구조를 자동으로 감지해서 처리하는 유틸을 만들어줘.”</span></span></span></blockquote><p id="2cba360d-33e3-807a-a480-e1b69d7fdb33" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Claude가 제안한 내용은 다음과 같아요.</span></span></span></p><aside id="2cba360d-33e3-8078-8d15-f9e936a13302" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2cba360d-33e3-80e5-bbde-dad61f977c01" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">URL 기반 서비스 타입 감지</span></span></span></li><li id="2cba360d-33e3-80ce-9285-ffd427f31fe7" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">checkbox</span></code><span class="css-1kxrhf3"> 개수에 따른 신/구 유저 구분</span></span></span></li><li id="2cba360d-33e3-804c-85fa-d6784f385be3" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">서비스별 필수 약관 목록 자동 매칭</span></span></span></li><li id="2cba360d-33e3-8017-b324-d1482cd77274" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“모두 동의하기” 버튼이 없는 경우의 fallback</span></span></span></li></ul></div></aside><p id="2cba360d-33e3-802d-bbd9-ec0849ad01e7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결과적으로 하나의 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">clickInitialConsent()</span></code><span class="css-1kxrhf3"> 함수만 유지하면 네 가지 서비스의 약관 변화가 모두 자동으로 반영되도록 만들 수 있었어요. 이후 약관 변경이 여러 차례 있었지만, 테스트는 </span><span class="css-q3ktjb">단 한 번도 중단되지 않았습니다.</span></span></span></p><p id="2cba360d-33e3-80b4-af4a-ff3f84d880f5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2caa360d-33e3-812c-9f35-cd881b308b0d" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">📝 Documentation Specialist - 문서와 일지 관리 담당</span></span></span></h3><p id="2caa360d-33e3-8144-aa83-d5fb80502bac" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저녁이면 저는 AI에게 한 줄만 입력했습니다.</span></span></span></p><p id="2caa360d-33e3-819f-b7e6-cd813951f716" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1odxvuk">“오늘 커밋 기반으로 일지 정리해줘.”</span></span></span></p><p id="2caa360d-33e3-81bf-b27f-c647d6890729" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그러면 다음과 같은 완성된 회고가 나옵니다.</span></span></span></p><blockquote id="2caa360d-33e3-814a-9086-c740c30161f9" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">📅 2025-11-24</span></span></span><div class="css-1k9y0sc"><ul class="css-uswsmm"><li id="2caa360d-33e3-81ac-87a3-f710a0c2d67e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">신규 테스트 3개 추가 (탈퇴, 홈택스 가입, 연금공제 미공제)</span></span></span></li><li id="2caa360d-33e3-81a0-8a96-f7c200536d66" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">clickButton</span></code><span class="css-1kxrhf3"> Fallback 기본 활성화</span></span></span></li><li id="2caa360d-33e3-818f-bdb7-ebed9114da7a" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">월세 공제 로직 수정</span></span></span></li><li id="2caa360d-33e3-8114-bf65-d5926ed5d457" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">v3.3.0 기준 테스트 35개 통과</span></span></span></li><li id="2caa360d-33e3-814b-8957-ee594387c25c" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문서(</span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">CLAUDE_CONTEXT.md</span></code><span class="css-1kxrhf3">, </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">QA_AUTOMATION_GUIDE.md</span></code><span class="css-1kxrhf3">) 최신화 완료</span></span></span></li></ul></div></blockquote><p id="2caa360d-33e3-8137-835a-c939cb93e0b5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이전에는 30~40분씩 들여 쓰던 일지를 이제는 </span><span class="css-q3ktjb">1~2분 검토만 하면 작성을 마칠 수 있게 되었어요.</span></span></span></p><p id="2d1a360d-33e3-80a9-8eac-e0792b03c4ee" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문서로 기록을 남기니</span><span class="css-q3ktjb"> 이후에 같은 부분에서 막히면 손쉽게 해결을 할 수 있었어요.</span><span class="css-1kxrhf3"> 또 한</span><span class="css-q3ktjb"> 팀원에게 전파</span><span class="css-1kxrhf3">도 쉬워졌습니다.</span></span></span></p><p id="2cba360d-33e3-802c-a990-da72d60928cb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2caa360d-33e3-8163-a154-fafe518ece72" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">✍️ Git Master - 커밋·PR 코파일럿</span></span></span></h3><p id="2caa360d-33e3-8136-beec-c1696a31091b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">초반에는 흔한 커밋 메시지를 사용했습니다.</span></span></span></p><p id="2caa360d-33e3-8191-9410-d35528c23f38" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 지금은 대부분 이런 메시지예요.</span></span></span></p><p id="2caa360d-33e3-8163-babc-f40940a3c124" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">6개월이 지나니 커밋 히스토리만 봐도 </span><span class="css-q3ktjb">팀의 발자국</span><span class="css-1kxrhf3">이 또렷하게 보였습니다.</span></span></span></p><p id="2cba360d-33e3-80be-b2c3-ca5c4bef5bf9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2caa360d-33e3-8119-8a0c-cc83981c7f14" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">💬 내부 메신저로 이어진 AI–사람–테스트 루프</span></span></span></h3><p id="2caa360d-33e3-8167-a19f-d570f82d0d66" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">AI가 코드만 짠 건 아니에요. </span><span class="css-q3ktjb">테스트 결과와 데이터도 내부 메신저를 통해 주고받는 구조</span><span class="css-1kxrhf3">를 만들었습니다. 매 테스트가 끝나면, 자동으로 이런 메시지가 떨어져요.</span></span></span></p><ul class="css-uswsmm"><li id="2caa360d-33e3-8104-bcd0-e17e5e3529df" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결과, 실행시간, 환경, 실행시각, 테스트 UserNo(테스트 고유 ID), 관련 티켓 브랜치 등</span></span></span></li></ul><figure id="2caa360d-33e3-815d-8b52-e5b5bdf6ac34" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/61ff5b08-3579-4a90-a6c9-a4b19fb4ad90/1223_tech_inner_1.png" alt="" class="css-1pgssrp"/></figure><p id="2caa360d-33e3-8157-a1e3-dff979eae959" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2caa360d-33e3-81c2-9882-dd0e6ab442ac" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">테스트가 실패하면 메시지는 조금 달라집니다.</span></span></span></p><ul class="css-uswsmm"><li id="2caa360d-33e3-81f2-aeff-c2191985b64c" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">에러메시지, 실패 단계, 실패 단계 관련 로그를 추적할 수 있도록 EventID, 실패단계 로그 등</span></span></span></li></ul><figure id="2caa360d-33e3-811a-83f4-e1eff563be22" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/11a8a248-6163-4ad9-bc94-a87bdfc54551/1223_tech_inner_3_(1).png" alt="" class="css-1pgssrp"/></figure><p id="2caa360d-33e3-8142-820b-e7c33790ea2a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2caa360d-33e3-81a5-9ee3-f81ab1a57e89" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">여기서 중요하게 볼 점은 </span><span class="css-q3ktjb">어디서 어떻게 테스트가 실패하느냐</span><span class="css-1kxrhf3">였어요. 그래서 해당 실패 스레드의 댓글로 </span></span></span></p><ul class="css-uswsmm"><li id="2caa360d-33e3-81f8-aec6-fbc3d1046ffc" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">테스트 리포트 </span></span></span></li><li id="2caa360d-33e3-8198-ae54-f1ddb54260e0" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">테스트 실패 지점 스크린샷</span></span></span></li></ul><p id="2caa360d-33e3-81ff-b3c0-db4d53e38034" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 오도록 AI에게 요청했고 반영이 되었습니다.</span></span></span></p><figure id="2caa360d-33e3-812f-8911-f97ce86449b4" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/36724d9b-18b0-4fd6-b5b6-fc6aeee9c7ae/1223_tech_inner_2.png" alt="" class="css-1pgssrp"/></figure><p id="2caa360d-33e3-81ec-8fa2-cfa071d5cb3d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">더 재밌는 점은 내부 메신저에서 바로 논의가 시작된다는 점이었어요.</span></span></span></p><blockquote id="2caa360d-33e3-8150-8358-c8eceb4e6672" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">QA: “배포 후 13번 테스트가 깨지고 있어요. 의료비 공제 쪽 확인 부탁드려요”</span></span></span></blockquote><p id="2caa360d-33e3-81e2-98a3-c1f5cb8e0255" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">테스트 결과도 마찬가지였습니다. 테스트 진행 단계 및 오류 로그등 </span><span class="css-q3ktjb">사람이 이해하기 좋은 형태의 테스트 데이터 리포트</span><span class="css-1kxrhf3">가 바로 도착하죠.</span></span></span></p><figure id="2caa360d-33e3-8158-9112-f1893c8729a1" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/9ad4d7a7-fa42-40e3-8c07-440c69602c16/스크린샷_2025-12-02_오후_2.17.12.png" alt="" class="css-1pgssrp"/></figure><aside id="2cba360d-33e3-80fd-8309-d326b5a1118e" class="css-nv7vyi"><div class="css-1vn47db"><ol class="css-hokoge"><li id="2caa360d-33e3-81b6-9488-c7af0ccd3275" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">테스트 결과와 데이터를 내부 메신저에서 확인하고</span></span></span></li><li id="2cba360d-33e3-80c7-b7ea-e906a9a62a17" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이상한 부분이 있으면 AI에게 “이 케이스만 다시 분석해줘”라고 요청하고</span></span></span></li><li id="2cba360d-33e3-80fc-9d2b-da109bfa8fab" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">AI가 제안한 수정 코드를 적용하고</span></span></span></li><li id="2cba360d-33e3-80fd-93fe-cf3ba0e4bfea" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">다시 내부 메신저으로 결과를 받는 루프</span></span></span></li></ol></div></aside><p id="2caa360d-33e3-8193-ae2f-d57b1a077906" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">코드를 치는 시간보다 </span><span class="css-q3ktjb">내부 메신저에서 AI와 대화하는 시간이 더 많아진</span><span class="css-1kxrhf3"> 경험이었습니다.</span></span></span></p><p id="2cba360d-33e3-80c7-988b-e074e08b2bfd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2caa360d-33e3-812f-8950-f905b065c87d" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">시간순 개발 스토리</span></span></span></h2><p id="2cba360d-33e3-8073-9562-e1369ed9c69b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">올해 7월부터 지금까지 시간순으로 개발 여정에 대해 좀 더 자세히 들여다 볼게요.</span></span></span></p><h3 id="2caa360d-33e3-81f1-a8b4-fa858a20effc" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">7월 — 파일럿 시작</span></span></span></h3><p id="2caa360d-33e3-8198-a322-d3ebbfbd9308" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">현금영수증/의료비/신용카드 등 핵심 테스트 5개를 제작했고, Page Object Model을 도입하며 테스트 유틸 함수 틀을 완성했습니다.</span></span></span></p><h3 id="2caa360d-33e3-8197-a413-e7b44630b90c" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">8월 — 문서화 &amp; React 타이밍 이슈 해결</span></span></span></h3><p id="2caa360d-33e3-81ee-9904-d5ad209639d9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">스크린 상에는 버튼이 이미 렌더링되어 있는데, Playwright는 지속적으로 아래 오류를 내며 클릭을 거부했습니다.</span></span></span></p><p id="2caa360d-33e3-81a9-af3c-d32a7b2d8413" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">UI는 보이는데 클릭이 안 되는, React 기반 서비스에서 간헐적으로 나타나는 전형적인 플로우였어요. 문제를 추적해보니, DOM이 렌더링된 시점과 </span><span class="css-q3ktjb">이벤트 핸들러가 바인딩되는 시점</span><span class="css-1kxrhf3"> 사이에 미묘한 비동기 갭이 존재했습니다.</span></span></span></p><aside id="2cba360d-33e3-80be-8b93-c7566ca84d80" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2caa360d-33e3-8183-b93f-f0219377361e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">DOM은 준비됨</span></span></span></li><li id="2cba360d-33e3-8023-8e4c-f482dc2762a6" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">CSS 레이아웃도 완료됨</span></span></span></li><li id="2cba360d-33e3-80a4-8a90-d23c75818e35" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 React의 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">useEffect</span></code><span class="css-1kxrhf3"> 내부 로직으로 인해 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">onClick</span></code><span class="css-1kxrhf3"> 핸들러가 실제로 등록되기까지 </span><span class="css-q3ktjb">수 ms ~ 수백 ms 지연</span></span></span></li></ul></div></aside><p id="2caa360d-33e3-81a4-875c-ccf68ad8e9ed" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Playwright는 “보이는 요소”만을 기준으로 클릭을 시도하기 때문에 이벤트 핸들러가 아직 바인딩되지 않은 상태에서는 </span><span class="css-q3ktjb">렌더는 끝났는데 상호작용은 아직 불가한 상태</span><span class="css-1kxrhf3">가 만들어졌습니다.</span></span></span></p><p id="2cba360d-33e3-804b-8d6b-f9b2aac6f0e0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2caa360d-33e3-812e-8fbb-ca7662b25883" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Claude는 먼저 문제를 이렇게 정리해줬습니다.</span></span></span></p><blockquote id="2caa360d-33e3-814a-b48a-cfba848f2bfe" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“React에서는 ‘보인다(Visible)’와 ‘클릭 가능(Interactable)’이 반드시 같은 시점이 아닙니다.
Playwright가 클릭을 시도할 때 이벤트 핸들러가 아직 바인딩되지 않은 상태입니다.
</span><span class="css-q3ktjb">UI 안정화(visual ready)와 상호작용 준비(interaction ready)를 분리해 기다릴 필요가 있습니다.</span><span class="css-1kxrhf3">”</span></span></span></blockquote><p id="2caa360d-33e3-8184-8459-d3d11486720c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그리고 아래와 같은 </span><span class="css-q3ktjb">표준화된 인터랙션 준비(Interaction Readiness) 전략</span><span class="css-1kxrhf3">을 제안했어요.</span></span></span></p><p id="2cba360d-33e3-802c-8864-e7b8c337b971" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2caa360d-33e3-813d-8f87-ccd0dd03195b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣</span><span class="css-q3ktjb"> DOM → React → 이벤트 핸들러 순서로 안정화 대기 (예시)</span></span></span></p><p id="2caa360d-33e3-8192-9a0c-db730e8917ae" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">단순 sleep이 아니라, 단계별로 UI 안정성을 확보하는 구조입니다.</span></span></span></p><p id="2caa360d-33e3-8149-ad78-fcc295a64379" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣</span><span class="css-q3ktjb"> 상호작용 fallback 전략 (예시)</span></span></span></p><p id="2caa360d-33e3-8172-ba41-fccaa0456544" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">‘한 번 클릭 → 안 되면 강제 클릭 → 그래도 안 되면 네이티브 입력(Enter)’ 같은 전략이 아니라, </span><span class="css-q3ktjb">위험하지 않은 순서</span><span class="css-1kxrhf3">로 정리된 fallback입니다.</span></span></span></p><p id="2caa360d-33e3-817c-8fa2-d366b009df00" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3️⃣</span><span class="css-q3ktjb"> 최종 결합된 Click API (예시)</span></span></span></p><p id="2caa360d-33e3-8199-a1f9-c36350e5bcb3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 전략을 적용하면서 16번·17번 테스트에서 반복적으로 발생하던 클릭 실패는 완전히 사라졌습니다.</span></span></span></p><aside id="2cba360d-33e3-8049-a0a7-c0bb88273c26" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2caa360d-33e3-817d-9756-c9b168601d49" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기존 성공률: </span><span class="css-q3ktjb">약 70%</span></span></span></li><li id="2cba360d-33e3-80f1-be85-e157ff57f387" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">개선 후 성공률: </span><span class="css-q3ktjb">100%</span></span></span></li><li id="2cba360d-33e3-80fe-89f3-f0ae0b0ef499" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">코드 복잡도는 ↓</span></span></span></li><li id="2cba360d-33e3-8079-95c6-f91764f230e0" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">UI 안정성은 ↑</span></span></span></li></ul></div></aside><p id="2caa360d-33e3-8189-849d-c28ec5ee09c0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">특히 핵심은 ‘랜덤하게 25초 기다리기’ 같은 접근이 아니라, </span><span class="css-q3ktjb">React UI의 특성을 고려해 ‘상호작용 가능’ 상태를 직접 감지한 것</span><span class="css-1kxrhf3">이었어요. 문제 자체는 단순해 보였지만, 그 단순함의 본질까지 AI가 정확히 짚어준 순간이기도 했습니다.</span></span></span></p><p id="2cba360d-33e3-8020-84ae-f9fb22bbf8f0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2caa360d-33e3-81bf-8a57-d1e63ea3c1a3" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">9월 — 대규모 리팩토링 &amp; 테스트 격리</span></span></span></h3><p id="2caa360d-33e3-815d-bd72-db4c5c5c920a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2,147줄짜리 파일을 3개 파일로 분리했고, 23개 테스트 import를 자동 수정했으며, userNo 충돌 이슈를 완전히 해결했습니다. ‘자동화가 돌아간다’에서 ‘자동화 품질을 관리할 수 있다’ 단계로 올라간 시기였어요.</span></span></span></p><p id="2caa360d-33e3-81a9-b678-e68f177fb443" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2caa360d-33e3-8156-9f12-fd368cab5c9a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">10월 — 약관 시스템 재설계</span></span></span></h3><p id="2caa360d-33e3-8116-bd45-f3935b333c8b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">서비스가 여러 개로 늘어나면서 약관은 폭발적으로 복잡해졌습니다. Claude는 다음과 같이 제안했어요.</span></span></span></p><aside id="2cba360d-33e3-8056-81bd-ffbd7911f80f" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2caa360d-33e3-8123-b175-e6d559395999" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">모든 약관을 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">consentOptions.ts</span></code><span class="css-1kxrhf3">로 중앙 관리</span></span></span></li><li id="2cba360d-33e3-8034-a418-d528cb6d889d" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">URL 기반 서비스 타입 자동 감지</span></span></span></li><li id="2cba360d-33e3-801b-af7d-c25277c8aac4" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">내부 메신저 알림에 동의 내역을 이모지로 표시</span></span></span></li></ul></div></aside><p id="2caa360d-33e3-810d-9bc9-c2b28993816d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그 결과 3일만에 약관의 정합성을 확인하는 시스템이 만들어졌습니다. 이후 약관 추가는 </span><span class="css-q3ktjb">설정 파일 한 줄 수정</span><span class="css-1kxrhf3">이면 끝나게 되었어요.</span></span></span></p><p id="2cba360d-33e3-80c1-b299-ff96be39ac26" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2caa360d-33e3-8108-b9f7-f18bb45f29c7" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">11월 — 35개 테스트 완성 &amp; 운영 모드 진입</span></span></span></h3><p id="2caa360d-33e3-812c-ab9e-d1a257870910" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">탈퇴, 홈택스 가입, 연금공제 미공제 테스트를 추가했고, clickButton 기본 Fallback을 활성화했으며, 문서와 코드를 동기화했습니다(v3.3.0). 이때 일지에는 이렇게 적혀 있었어요.</span></span></span></p><blockquote id="2caa360d-33e3-81c2-bad9-ca774e130e45" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“이제는 테스트를 ‘추가’하는 단계가 아니라, 안정적으로 ‘운영’하는 단계에 도달했다.”</span></span></span></blockquote><p id="2cba360d-33e3-803f-b4ae-fa7c61f2f441" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><h2 id="2caa360d-33e3-813a-9c22-fbc46e82e13a" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">AI와 함께 일해본다는 것</span></span></span></h2><p id="2caa360d-33e3-81b8-bfe6-d868a39d399f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">5개월 동안 저는 아래 네 가지에 거의 모든 시간을 썼습니다.</span></span></span></p><aside id="2cba360d-33e3-8058-8efb-f03f2f971b93" class="css-nv7vyi"><div class="css-1vn47db"><ol class="css-hokoge"><li id="2caa360d-33e3-8118-9fa1-ffea9613b6d4" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문제 정의</span></span></span></li><li id="2cba360d-33e3-80c3-8547-de357f5c6f3b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">요구사항 정리</span></span></span></li><li id="2cba360d-33e3-804d-9d60-d4144fbd8e04" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">AI에게 맥락과 제약 설명</span></span></span></li><li id="2cba360d-33e3-808b-9be1-f705c68038f7" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결과물 검토·승인</span></span></span></li></ol></div></aside><p id="2caa360d-33e3-81fe-bad9-d33cee029c18" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">코드를 직접 친 시간은 10%도 되지 않았어요. 대신 AI가 짜온 코드와 설계의 </span><span class="css-q3ktjb">방향을 잡아주는 역할</span><span class="css-1kxrhf3">을 했죠. 그래서 스스로에게 이런 질문을 하게 됩니다.</span></span></span></p><blockquote id="2caa360d-33e3-8122-8ede-d77441ed8ec6" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">코드를 잘 치는 사람</span><span class="css-1kxrhf3">보다 </span><span class="css-q3ktjb">AI와 함께 문제를 해결할 수 있는 사람</span><span class="css-1kxrhf3">이 앞으로 더 중요한 건 아닐까?</span></span></span></blockquote><p id="2cba360d-33e3-8063-9dec-d2e3a876f8cf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><h2 id="2caa360d-33e3-81e8-8470-d758879dd0cd" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">AI-driven 테스트 자동화</span></span></span></h2><p id="2caa360d-33e3-81bc-bee8-ec50305f4e37" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">AI가 QA를 대체할까요? 저는 그렇게 생각하지 않습니다. 하지만 AI가 QA의 역량을 </span><span class="css-q3ktjb">증폭시키는 시대</span><span class="css-1kxrhf3">는 이미 시작됐다고 믿어요. 세금 환급처럼 복잡한 도메인에서도, AI는 충분히 팀원 역할을 해냈습니다.</span></span></span></p><p id="2caa360d-33e3-81bb-918d-e87621f72638" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그리고 지난 5개월을 거치며 저에게 남은 가장 큰 인사이트는 이것입니다.</span></span></span></p><blockquote id="2caa360d-33e3-81a5-bb57-f49bc88941ee" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“AI가 좋은 품질의 속도를 만든다면,
QA는 그 속도가 향해야 할 ‘방향’을 만드는 사람이다.”</span></span></span></blockquote><p id="2bda360d-33e3-80fc-9d60-c073a58f6711" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2cba360d-33e3-802c-a47a-fd84d34fe6a7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[토스의 AI 기술력, 세계 최고 권위 NeurIPS 2025에서 인정받다: FedLPA 연구]]></title>
            <link>https://toss.tech/article/neurIPS-FedLPA</link>
            <guid>https://toss.tech/article/neurIPS-FedLPA</guid>
            <pubDate>Tue, 23 Dec 2025 08:52:00 GMT</pubDate>
            <description><![CDATA[AI/ML 분야 세계 최고 권위 학회인 NeurIPS 2025에 게재된 연구 내용과 이 연구가 토스에 미칠 수 있는 비즈니스 임팩트, 그리고 학회 참여에 대한 소회를 공유합니다.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2cda360d-33e3-80b3-b6dc-e531deda2906" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요, 토스 Face Modeling Team의 ML Engineer 이진우입니다.</span></span></span></p><p id="2cea360d-33e3-801b-82fc-ce9474b01a61" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">영광스럽게도 AI/ML 분야의 세계 최고 권위 학회인 NeurIPS 2025에 제 연구가 게재 되었습니다. 저의 연구 내용과 이 연구가 토스에 미칠 수 있는 비즈니스 임팩트, 그리고 학회 참여에 대한 소회를 공유하고자 합니다.</span></span></span></p><p id="2cea360d-33e3-803f-9254-e798e276fcd0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2cda360d-33e3-8011-bab5-d5f1623a02d5" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">NeurIPS가 어떤 곳인가요?</span></span></span></h3><p id="2cda360d-33e3-80f9-9ba8-d2d178209f30" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">NeurIPS(Neural Information Processing Systems)</span><span class="css-1kxrhf3">는 매년 12월 개최되는 </span><span class="css-q3ktjb">세계 최대 규모의 기계학습(Machine Learning) 학회</span><span class="css-1kxrhf3">입니다. 전 세계 AI 연구자들이 한 해 동안 이룬 최고의 성과들이 모이는 곳으로, 이곳에 논문이 채택되었다는 것은 해당 기술이 세계적으로 인정받았다는 가장 확실한 증거가 됩니다. 토스는 이번 연구를 통해 글로벌 테크 기업들과 어깨를 나란히 하는 AI 기술력을 증명했습니다.</span></span></span></p><p id="2cea360d-33e3-802e-8c23-e576619373b3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2cda360d-33e3-80f1-b730-f78438d0dc19" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">서울대 비전랩과의 시너지</span></span></span></h3><p id="2cda360d-33e3-8034-b028-e63ad297c243" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이번 성과는 혼자만의 힘으로 이룬 것이 아닙니다. </span><span class="css-q3ktjb">서울대학교 Computer Vision Lab의 한보형 교수님</span><span class="css-1kxrhf3"> 팀과 긴밀히 협업한 결과물인데요. 한보형 교수님과는 이전 </span><span class="css-q3ktjb">Neural Architecture Search(NAS)</span><span class="css-1kxrhf3"> 연구부터 꾸준히 기술적 교류를 이어오고 있었습니다. 이번에도 새로운 연구 주제를 치열하게 고민하던 중, 교수님께서 소개해주신 </span><span class="css-q3ktjb">김지호 학생</span><span class="css-1kxrhf3">과 의기투합하게 되었고, &#x27;현실적인 연합학습(Federated Learning)&#x27;이라는 난제를 함께 풀어나가며 </span><span class="css-q3ktjb">FedLPA</span><span class="css-1kxrhf3">라는 값진 결실을 맺을 수 있었습니다.</span></span></span></p><p id="2cda360d-33e3-807e-9d41-deb23568736f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 이 연구를 통해, 1) 데이터는 흩어져 있고, 2) 라벨은 부족하며, 3) 분포는 불균형한 현실 세계의 문제를 정면으로 돌파했습니다.</span></span></span></p><p id="2cea360d-33e3-804c-a816-ef9ed18c3623" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2cda360d-33e3-80bc-9729-f0459a3a7c53" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">페이스페이, 국경을 넘어 호주에 진출한다면?</span></span></span></h2><p id="2cda360d-33e3-803b-8121-c337d4fc1a98" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스의 자랑인 &#x27;페이스페이&#x27;를 호주 시장에 런칭한다고 상상해 봅시다. 최고의 사용자 경험을 위해서는 호주 사용자들의 얼굴 데이터로 AI 모델을 정교하게 학습시켜야 합니다. 하지만 현실적인 장벽이 존재합니다.</span></span></span></p><blockquote id="2cda360d-33e3-8065-aa07-f42bf425032d" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">&quot;호주 사용자의 생체 데이터는 호주 밖으로 반출될 수 없다.&quot;</span></span></span></blockquote><p id="2cda360d-33e3-806f-875d-fe8b889e1c2e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">각국의 개인정보 보호법과 데이터 주권(Data Sovereignty) 문제 때문에 데이터를 한국 서버로 가져와서 학습하는 기존 방식은 불가능합니다. 바로 이때 필요한 기술이 </span><span class="css-q3ktjb">연합 학습(Federated Learning)</span><span class="css-1kxrhf3">입니다.</span></span></span></p><h3 id="2cda360d-33e3-801e-a933-f68c1ec21714" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">연합 학습(</span><span class="css-1kxrhf3">Federated Learning)이란?</span></span></span></h3><p id="2cda360d-33e3-8053-843b-ea6f88c6f5d6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">데이터를 서버로 모으는 대신, </span><span class="css-q3ktjb">&#x27;모델이 데이터가 있는 곳으로 가는&#x27;</span><span class="css-1kxrhf3"> 기술입니다. 사용자의 스마트폰(Client) 내에서 AI가 학습하고, 오직 </span><span class="css-q3ktjb">학습된 결과(Weights)</span><span class="css-1kxrhf3">만 암호화되어 서버로 전송됩니다. 사용자의 민감한 원본 데이터는 절대 기기 밖을 나가지 않으므로 개인정보 보호와 AI 학습이라는 두 마리 토끼를 잡을 수 있습니다.</span></span></span></p><p id="2cea360d-33e3-80bc-95dc-ec8b542c8609" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2cda360d-33e3-80b4-a35f-e79e843e5fb1" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">기존 기술의 한계: &quot;현실은 실험실과 다르다&quot;</span></span></span></h2><p id="2cda360d-33e3-80f3-8336-c98eb138de4c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 기존의 연합학습 기술을 실제 비즈니스에 바로 적용하기에는 치명적인 맹점이 있었습니다.</span></span></span></p><p id="2cda360d-33e3-8098-830b-c361086f4f0c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ </span><span class="css-q3ktjb">‘모든 사용자는 비슷할 것이다’라는 착각:</span><span class="css-1kxrhf3"> 기존 연구들은 한국 사용자와 호주 사용자의 데이터 분포(얼굴형, 조명 환경, 결제 패턴 등)가 비슷하다고 가정했습니다. 하지만 실제로는 국가별, 지역별, 클라이언트별로 데이터 특성이 완전히 다릅니다(</span><span class="css-q3ktjb">Non-IID</span><span class="css-1kxrhf3">).</span></span></span></p><p id="2cda360d-33e3-80c7-a33b-e21624f8c424" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣ </span><span class="css-q3ktjb">‘새로운 것은 없다’는 가정:</span><span class="css-1kxrhf3"> 서비스 운영 중에는 우리가 미리 알지 못했던 새로운 인종적 특성이나, 새로운 형태의 부정 결제 패턴(Novel Class)이 끊임없이 등장합니다. 기존 기술은 &#x27;내가 아는 범주&#x27;만 학습하도록 설계되어 있어, 이런 새로운 변화에 대응하지 못했습니다.</span></span></span></p><p id="2cda360d-33e3-80b4-8ea3-f4d3e9471e79" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결국, 기존 기술을 그대로 도입하면 호주 사용자에게는 한국 사용자만큼의 인식 정확도를 제공하지 못하거나, 새로운 데이터 패턴을 학습하지 못해 성능이 도태되는 문제가 발생합니다.</span></span></span></p><p id="2cea360d-33e3-8080-971f-ccee7b7e5d0b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2cda360d-33e3-8086-a47a-cb990694970a" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">FedLPA는 어떻게 학습하나요?</span></span></span></h2><p id="2d2a360d-33e3-8039-9d3c-f1f278dc6c25" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">FedLPA는 저희가 개발한 알고리즘으로, Local Prior Alignment를 활용한 Federated Learning, Federated Generalized Category Discovery의 약자입니다. 여기서 Generalized Category Discovery(GCD)는 기계 학습 분야의 중요한 과제로, </span><span class="css-q3ktjb">레이블이 지정된 일부 데이터(Seen Classes)와 레이블이 지정되지 않은 대규모 데이터셋을 함께 활용하여 레이블이 없는 데이터 내의 모든 이미지를 알려진 클래스와 완전히 새로운(Novel) 클래스 모두로 분류하는 것을 목표</span><span class="css-1kxrhf3">로 합니다.</span></span></span></p><p id="2cda360d-33e3-8096-8164-c3eeb6dbcbed" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">FedLPA가 기존 연구의 한계를 뛰어넘을 수 있었던 비결은 </span><span class="css-q3ktjb">&#x27;데이터의 구조를 그래프로 파악하고, 이를 모델 학습에 동적으로 반영하는 3단계 파이프라인&#x27;</span><span class="css-1kxrhf3"> 덕분입니다. 논문에서는 이 과정을 통해 서버의 개입 없이 클라이언트 스스로 데이터의 분포(Local Prior)를 찾아냅니다.</span></span></span></p><p id="2cda360d-33e3-80cd-980a-e3bfe93e3aba" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그 구체적인 과정을 하나씩 뜯어보겠습니다.</span></span></span></p><figure id="2cda360d-33e3-80a1-9d2e-d66f9aa40f7d" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/b0e8dac0-1925-40fa-a8f5-9d66100e6a4d/스크린샷_2025-10-23_오전_10.57.15.png" alt="" class="css-1pgssrp"/><figcaption class="css-wgpbp3"><span class="css-jfs1hr">FedLPA의 전체 학습 구조: 그래프를 만들고, 클러스터를 찾고, 모델을 정렬합니다.</span></figcaption></figure><p id="2cda360d-33e3-80b6-893d-c369e0234dd2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2cda360d-33e3-80f0-bf4e-c30fdb214731" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Step 1. 신뢰도 기반 로컬 구조 발견 (Confidence-guided Local Structure Discovery, CLSD)</span></span></span></h3><p id="2cda360d-33e3-80c6-9c2c-d31bda58c9d6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">첫 번째 단계는 각 클라이언트가 가진 데이터들 사이의 &#x27;관계&#x27;를 정의하는 것입니다. 단순히 이미지의 특징(Feature)만 비교하는 것이 아니라, 더 정교한 </span><span class="css-q3ktjb">유사도 그래프(Similarity Graph)</span><span class="css-1kxrhf3">를 구축합니다.</span></span></span></p><ul class="css-uswsmm"><li id="2cda360d-33e3-8094-bc2f-f2c1722f3990" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">초기 그래프 생성:</span><span class="css-1kxrhf3"> 먼저 모델이 추출한 특징 벡터(Feature Vector)를 이용해 데이터 간의 유사도를 계산하고 연결합니다.</span></span></span></li><li id="2cda360d-33e3-807f-875e-dd1ef790b2d7" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">신뢰도 기반 정제 (Confidence-guided Refinement):</span><span class="css-1kxrhf3"> 여기서 중요한 점은 </span><span class="css-q3ktjb">&#x27;확실한 정보&#x27;</span><span class="css-1kxrhf3">를 적극 활용한다는 것입니다. 라벨이 있는 데이터(Labeled Data)는 물론이고, 라벨이 없는 데이터 중에서도 모델이 &quot;이건 확실히 A다&quot;라고 높은 확률로 예측한 데이터(High-confidence samples)를 선별합니다.</span></span></span></li><li id="2cda360d-33e3-805e-8b3b-cbcd6c559a77" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">그래프 강화:</span><span class="css-1kxrhf3"> 이렇게 선별된 데이터들의 예측 결과(Pseudo-labels)를 이용해 그래프의 연결 강도를 조정합니다. 같은 클래스로 예측된 데이터끼리는 더 강하게 연결하고, 다른 클래스는 끊어내어 그래프의 품질을 높입니다.</span></span></span></li></ul><h3 id="2cda360d-33e3-8088-9732-f62b6bc3cb59" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Step 2. 인포맵 클러스터링 (InfoMap Clustering)</span></span></span></h3><p id="2cda360d-33e3-80f7-b696-d50f1f961806" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래프가 준비되었다면, 이제 그 안에서 </span><span class="css-q3ktjb">&#x27;숨겨진 범주&#x27;</span><span class="css-1kxrhf3">를 찾아낼 차례입니다. 저희는 여기서 </span><span class="css-q3ktjb">InfoMap</span><span class="css-1kxrhf3">이라는 커뮤니티 탐지 알고리즘을 사용합니다.</span></span></span></p><ul class="css-uswsmm"><li id="2cda360d-33e3-801d-88d7-d036341b5221" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">왜 InfoMap인가요?</span><span class="css-1kxrhf3"> 기존 방법론들은 &quot;새로운 범주가 5개일 거야&quot;라고 사람이 미리 정해줘야 했습니다. 하지만 InfoMap은 그래프 상에서 확률적 랜덤 워크(Random Walk)를 통해 데이터들이 자연스럽게 뭉치는 그룹(Community)을 찾아냅니다.</span></span></span></li><li id="2cda360d-33e3-8020-ab2e-e00c5b66763b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">자동 범주 추정:</span><span class="css-1kxrhf3"> 이 과정을 거치면 클라이언트는 서버의 도움 없이도 </span><span class="css-q3ktjb">&quot;내 데이터 안에는 대략 K개의 범주가 있구나&quot;</span><span class="css-1kxrhf3">라는 것을 스스로 발견하게 됩니다. 즉, 미지의 데이터가 들어와도 유연하게 대처할 수 있는 기반이 마련되는 것이죠.</span></span></span></li></ul><h3 id="2cda360d-33e3-802c-9f18-d7f58ae4c0cb" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Step 3. 로컬 사전 확률 정렬 (Local Prior Alignment, LPA)</span></span></span></h3><p id="2cda360d-33e3-8023-abae-f4e367b1fd2c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">마지막 단계는 발견된 구조를 모델 학습에 적용하는 것입니다. 여기서 FedLPA의 핵심 아이디어인 </span><span class="css-q3ktjb">동적 사전 정렬(Dynamic Prior Alignment)</span><span class="css-1kxrhf3">이 등장합니다.</span></span></span></p><ul class="css-uswsmm"><li id="2cda360d-33e3-80d1-bd70-fbc49860bc7c" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">자가 증류 (Self-distillation):</span><span class="css-1kxrhf3"> 모델은 앞서 발견된 클러스터의 중심(Prototypes)을 기준으로 데이터를 다시 예측합니다. 이때 데이터의 증강된 뷰(View)들이 서로 일관된 예측을 하도록 유도하여 학습의 안정성을 높입니다.</span></span></span></li><li id="2cda360d-33e3-806c-a9fa-e74191241c22" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">LPA 정규화 (Regularizer):</span><span class="css-1kxrhf3"> 가장 중요한 부분입니다. 모델이 배치를 학습할 때, 예측 결과의 분포가 앞서 Step 2에서 파악한 </span><span class="css-q3ktjb">&#x27;실제 데이터의 분포(Empirical Prior)&#x27;</span><span class="css-1kxrhf3">와 일치하도록 강제합니다.</span></span></span></li><li id="2cda360d-33e3-8008-9677-c484c65aa3fa" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">효과:</span><span class="css-1kxrhf3"> 만약 데이터가 불균형해서 특정 클래스만 잔뜩 있다면, 일반적인 모델은 그 클래스로만 예측하려는 편향을 보입니다. 하지만 LPA는 &quot;이 배치의 실제 분포는 저렇지 않아!&quot;라고 알려주며 모델이 균형 잡힌 학습을 하도록 가이드합니다.</span></span></span></li></ul><p id="2cda360d-33e3-80bf-b8bd-ec4bc52a6022" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">요약하자면,</span><span class="css-1kxrhf3">
FedLPA는 ① 확실한 데이터로 지도를 그리고(Graph), ② 그 지도에서 스스로 구역을 나눈 뒤(Clustering), ③ 그 구역 정보에 맞춰 모델을 교정(Alignment)하는 과정을 반복합니다. 이 덕분에 전 세계 어디서든, 어떤 데이터 분포를 가진 사용자든 일관되게 높은 성능의 AI 서비스를 경험할 수 있게 되는 것입니다.</span></span></span></p><p id="2cea360d-33e3-8046-82fb-cadea53eeba4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2cda360d-33e3-8039-aadb-fb4f17f55cc4" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">토스의 비즈니스, 이렇게 달라집니다</span></span></span></h2><p id="2cda360d-33e3-80a2-a6c3-c7f4b9e54bca" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 연구 성과는 단순한 학술적 기여를 넘어, 토스의 비즈니스 확장성과 안정성에 직접적인 임팩트를 줄 수 있습니다.</span></span></span></p><p id="2cda360d-33e3-8029-80fb-cf7e51b8224d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1. 규제 리스크 없는 글로벌 진출 가속화</span><span class="css-1kxrhf3">
각국의 금융 및 개인정보 규제가 강화되더라도, FedLPA를 통해 데이터를 현지에 둔 채로 고성능 글로벌 모델을 구축할 수 있습니다. 이는 토스가 동남아, 유럽 등 새로운 시장에 진출할 때 </span><span class="css-q3ktjb">기술적 진입 장벽을 제거</span><span class="css-1kxrhf3">하는 강력한 무기가 될 수 있습니다.</span></span></span></p><p id="2cda360d-33e3-801f-98cf-f9aa57059de7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2. 초개인화된 금융 서비스 (Hyper-personalization)</span><span class="css-1kxrhf3">
사용자마다 제각각인 금융 생활 패턴을 중앙 서버의 획일화된 기준이 아닌, 개별 사용자의 로컬 환경에 맞춰 학습합니다. 이를 통해 이상거래탐지(FDS) 시스템은 전 세계 어디서나 발생할 수 있는 신종 사기 수법을 실시간으로 학습하여 방어하고, 신용평가 모델(CSS)은 각국의 특수성을 반영하여 더 많은 사용자에게 금융 기회를 제공할 수 있습니다.</span></span></span></p><p id="2cda360d-33e3-800f-9aaf-dbc8d2116672" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">3. 유지보수 비용 절감 및 운영 효율화</span><span class="css-1kxrhf3">
새로운 유형의 데이터가 발생할 때마다 사람이 일일이 개입하여 라벨링하고 재학습시키는 과정을 획기적으로 줄일 수 있습니다. FedLPA는 새로운 패턴을 스스로 감지하고 학습하므로, 모델 업데이트 주기를 단축하고 운영 효율성을 극대화합니다.</span></span></span></p><p id="2cea360d-33e3-8001-8f15-f55ac19e94a6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2cda360d-33e3-805b-8019-d34a37be1d04" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">NeurIPS 2025 현장 참가 후기</span></span></span></h2><p id="2cda360d-33e3-804b-a989-ece325759493" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">지난 12월, 연구 결과를 발표하기 위해 미국 샌디에고에서 열린 NeurIPS 2025 현장에 다녀왔습니다. 전 세계 AI 연구자들의 열기로 가득했던 그곳에서의 경험을 짧게 적어봅니다.</span></span></span></p><h3 id="2cda360d-33e3-804b-8a6c-fc4677df4c56" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3시간 동안 쉴 새 없었던 포스터 세션</span></span></span></h3><figure id="2cda360d-33e3-805b-bd8c-d700638cb5a2" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/f1531e9c-9643-434d-9919-c55914734024/IMG_3621.jpg" alt="" class="css-1pgssrp"/></figure><p id="2cda360d-33e3-80b4-9f61-eb34b1e8b71b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희 발표 세션은 그야말로 &#x27;핫&#x27;했습니다. 총 3시간 동안 진행된 포스터 세션 내내 하이퍼커넥트, 네이버, LG 같은 국내 기업 연구자분들 뿐만 아니라, 해외 유수의 대학 학생들과 글로벌 테크 기업 관계자들의 발길이 끊이지 않았습니다. 한국어와 영어를 쉴 새 없이 오가며 목이 쉴 정도로 열띤 설명을 이어갔습니다.</span></span></span></p><p id="2d2a360d-33e3-8076-a3a2-ce15ac62d669" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2cda360d-33e3-8061-b669-e8664550d4c6" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">&quot;그래서 토스는 이걸 어디에 쓰나요?&quot;</span></span></span></h3><p id="2cda360d-33e3-8067-b81b-f3e4034192bb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">현장에서 가장 많이 받은 질문은 단연 </span><span class="css-q3ktjb">실제 서비스 적용</span><span class="css-1kxrhf3">에 관한 것이었습니다.
저는 한국에서 이미 </span><span class="css-q3ktjb">토스 페이스페이(Face Pay)</span><span class="css-1kxrhf3">가 성공적으로 운영되고 있다는 점을 강조하며, </span><span class="css-q3ktjb">&quot;이 알고리즘은 얼굴 데이터를 국경 밖으로 가져가기 어려운 글로벌 환경에서 토스의 AI 서비스를 가능하게 하는 핵심 Key가 될 것&quot;</span><span class="css-1kxrhf3">이라고 설명해 드렸습니다. 많은 분들이 연구의 기술적 우수성 뿐만 아니라, 명확한 비즈니스 Use Case가 있다는 점에 큰 관심을 보여주셨습니다.</span></span></span></p><p id="2d2a360d-33e3-8099-afb9-fa2341a6f2c7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2cda360d-33e3-8006-9999-f249a7520ca9" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">인상 깊었던 다른 연구들</span></span></span></h3><p id="2cda360d-33e3-8062-9c67-cfef999d69b0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">학회장은 영감의 보고였습니다. 특히 한양대에서 연구한 &#x27;Non-Adaptive Adversarial Face Generation&#x27;이라는 주제의 연구가 기억에 남았습니다. 우리가 흔히 쓰는 얼굴 인식 모델은 얼굴을 수학적인 공간(고차원 구) 위의 한 점으로 변환해서 누군지를 구별하는데, 이 연구는 이 수학적 공간 안에서 </span><span class="css-q3ktjb">&#x27;인종&#x27;, &#x27;성별&#x27;, &#x27;나이&#x27; 같은 속성들이 끼리끼리 모여있는 특정 구역(Subsphere)</span><span class="css-1kxrhf3">이 있다는 점을 발견했습니다.</span></span></span></p><p id="2cda360d-33e3-8000-8147-f600b1f2f1bf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 원리를 이용하면, </span><span class="css-q3ktjb">AI에게는 여전히 &#x27;철수&#x27;로 인식되지만, 사람 눈에는 &#x27;미국인 여성&#x27;이나 &#x27;노인&#x27;으로 보이는 가짜 얼굴</span><span class="css-1kxrhf3">을 만들어낼 수 있습니다. 보안 시스템의 허점을 기하학적 원리로 찾아낸 매우 흥미로운 연구였습니다. 토스의 얼굴 인증 보안을 더 강력하게 만드는 데에도 참고할 만한 중요한 인사이트였습니다.</span></span></span></p><div class="css-1lyd0tt"><div class="css-31l7gp"><figure id="2cda360d-33e3-80ab-9545-cad938898682" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/d1f2018e-10fb-4e75-88f1-d2926fb3cc7b/IMG_3280_(1).jpg" alt="" class="css-1pgssrp"/></figure></div><div class="css-31l7gp"><figure id="2cda360d-33e3-80dd-aff3-e79b5096677b" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/3de56cae-0d4e-499d-9521-f48bc94a6204/IMG_3285_(1).jpg" alt="" class="css-1pgssrp"/></figure></div></div><p id="2cea360d-33e3-80e6-964a-c6f5e87b4fc2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2cea360d-33e3-8074-b8d6-e5f76abfe4ce" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">마치며</span></span></span></h2><p id="2cea360d-33e3-8062-a3a4-c04e409936de" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">세계 최고 권위의 AI 학회인 NeurIPS에 토스의 연구를 발표할 수 있었던 것은 정말 영광이었습니다. 학회장에서 만난 전 세계 연구자들과 나눈 대화, 그들의 연구에서 얻은 인사이트는 앞으로 토스의 AI 기술을 더 발전시킬 수 있는 귀중한 자산이 되었습니다.</span></span></span></p><p id="2cea360d-33e3-8070-94a9-ee845965ded3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이번 경험을 통해 연구자로서 더 성장할 수 있었고, 앞으로도 계속해서 실제 비즈니스 문제를 해결하는 의미 있는 연구를 이어가고 싶다는 의지가 생겼습니다. 특히 FedLPA 같은 기술이 토스 페이스 페이를 넘어 토스의 다양한 금융 서비스에 적용되어, 전 세계 사용자들에게 더 안전하고 편리한 경험을 제공할 수 있기를 기대합니다.</span></span></span></p><p id="2cea360d-33e3-804f-ba50-d30cd9ea5e67" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스는 앞으로도 학계와의 협업을 통해 세계 수준의 AI 기술을 개발하고, 이를 실제 서비스에 적용하는 데 집중할 예정입니다. 토스 페이스 페이와 토스의 기술 발전에 많은 관심 부탁드립니다.</span></span></span></p><p id="2cea360d-33e3-80cd-b018-c020222613f3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[고객은 절대 기다려주지 않는다: 빠른 데이터 서빙으로 고객 만족도를 수직 상승 시키는 법]]></title>
            <link>https://toss.tech/article/payments-legacy-7</link>
            <guid>https://toss.tech/article/payments-legacy-7</guid>
            <pubDate>Tue, 16 Dec 2025 01:30:00 GMT</pubDate>
            <description><![CDATA[토스페이먼츠 데이터 엔지니어링 팀이 50억 건의 데이터를 1초 이내로 조회하는 시스템을 구축한 이야기를 들려드려요.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2aaa360d-33e3-80d6-8858-e46fa2d0133c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요, 토스페이먼츠 Data Engineer 이세찬입니다. </span></span></span></p><p id="2aaa360d-33e3-8008-aab7-da17fb70900e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2020년 8월, PG 사업을 인수하며 출범한 토스페이먼츠는 이후 가파른 성장세를 보였습니다. 2022년 대비 2024년, 거래 건수 기준으로 약 2배 증가했죠. 하지만 이런 폭발적인 성장은 우리에게 새로운 도전을 안겨주었습니다. 바로 &quot;어떻게 하면 늘어나는 데이터를 안정적이고 빠르게 서빙할 수 있을까?&quot;라는 문제였어요.</span></span></span></p><p id="2c6a360d-33e3-8096-97e4-dee3a271a7f1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-801f-bc11-ff514631b1a3" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">모놀리식에서 MSA로: 첫 번째 도전</span></span></span></h3><p id="2aaa360d-33e3-801f-8314-d212eccf6369" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2020년 8월 이후, 토스페이먼츠는 더 나은 개발 환경을 위해 MSA(Microservices Architecture) 환경으로 전환을 시작했습니다. 하지만 애플리케이션 레벨의 분리는 이루어졌어도, DB 레벨의 분리까지는 도달하지 못했습니다.</span></span></span></p><p id="2aaa360d-33e3-8043-b57c-d438692834f8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">모놀리식 구조에서는 모든 도메인이 하나의 시스템과 DB에서 돌아갔습니다. 결제, 정산 등 도메인별 원장 조회는 크게 문제되지 않았어요. DB 내부에서 원장 간 JOIN으로 해결하거나, 원장 자체가 통합 관리되어 데이터 조회가 단순한 쿼리로 가능했기 때문이에요. 하지만 MSA 환경으로 전환하면서 상황은 완전히 달라졌습니다.</span></span></span></p><p id="2c6a360d-33e3-8064-aff5-ebdef6e4d8ce" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-804f-9840-d14b5fb72342" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Elasticsearch로 해결한 첫 번째 검색 니즈</span></span></span></h3><p id="2c6a360d-33e3-80d0-81a2-d3b86a811aa9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2021년, 가맹점의 거래내역 확인, 환불, 정산 등을 위한 새로운 제품이 출시되었습니다. 그러면서 검색에 대한 니즈가 커졌어요. 당시 우리의 해결책은 명확했습니다. 검색에 필요한 필드들을 Elasticsearch(ES)에 색인하여 문제를 해결했죠.</span></span></span></p><p id="2c6a360d-33e3-8056-8c00-c0b01b002fd1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 이것만으로는 충분하지 않았습니다. 거래량은 계속 늘어났고, 단순 검색을 넘어 복잡한 집계 연산과 실시간 조회가 필요해졌어요.</span></span></span></p><p id="2c6a360d-33e3-809c-a3ce-c9cf311c9033" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-805c-9f89-c05978ba4546" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">CQRS 아키텍처 도입: 명령과 조회의 분리</span></span></span></h3><p id="2c6a360d-33e3-8044-8a9b-f160edcfedce" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2024년 6월, 중요한 전환점이 찾아왔습니다. 거래 승인 원장이 </span><span class="css-q3ktjb">기존 Oracle에서 MySQL로 완전히 마이그레이션</span><span class="css-1kxrhf3">되었고, 이를 계기로 </span><span class="css-q3ktjb">CQRS(Command Query Responsibility Segregation) 아키텍처</span><span class="css-1kxrhf3">를 본격적으로 도입하게 되었어요. 이전까지는 읽기(DB Read)와 쓰기(DB Write)를 단순히 분리하는 수준이었지만, 우리가 만들고자 한 것은 그보다 훨씬 발전된 구조였습니다.</span></span></span></p><p id="2c6a360d-33e3-80f4-9cf3-d6a01bbc1b78" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">다음과 같은 요구사항을 동시에 충족할 수 있는 시스템을 필요로 했습니다.</span></span></span></p><aside id="2c6a360d-33e3-80b8-af5e-e6e224cb1809" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b5a360d-33e3-8027-aee2-db0b29f46608" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">수평 확장성(Scalability)</span><span class="css-1kxrhf3"> — 데이터 증가에 따라 자유롭게 확장 가능할 것</span></span></span></li><li id="2b5a360d-33e3-808f-970b-efb3d72f4f20" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Sub-second 수준의 빠른 집계 연산 성능</span><span class="css-1kxrhf3"> — 실시간 분석이 가능할 것</span></span></span></li><li id="2b5a360d-33e3-8065-993e-d5eae86187e3" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">RDB로는 구현이 어려운 OLAP 쿼리 지원</span><span class="css-1kxrhf3"> — 복합 집계를 안정적으로 처리할 것</span></span></span></li></ul></div></aside><p id="2b5a360d-33e3-80d2-9cb7-d85022f05285" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 세 가지 목표를 모두 충족할 수 있는 해답이 바로 </span><span class="css-q3ktjb">Apache Druid</span><span class="css-1kxrhf3">였어요.</span></span></span></p><p id="2b5a360d-33e3-809a-8d9f-da78af16b65f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-806c-a4b5-e50e57e890e7" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">왜 Apache Druid였을까?</span></span></span></h2><h3 id="2aaa360d-33e3-80b1-b709-f8d0dd764186" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ 시계열 데이터에 최적화</span></span></span></h3><p id="2aaa360d-33e3-808f-b052-f0a6f6ec6940" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">거래 내역은 본질적으로 </span><span class="css-q3ktjb">시계열 데이터</span><span class="css-1kxrhf3">입니다. 금액 합산 집계와 같은 OLAP성 쿼리에서 Druid는 매우 유리했습니다.</span></span></span></p><h3 id="2aaa360d-33e3-80a8-9084-f86c37b26200" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣ 낮은 러닝 커브</span></span></span></h3><p id="2aaa360d-33e3-8033-8dba-c44497a4858e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">DSL도 있지만 </span><span class="css-q3ktjb">Druid SQL</span><span class="css-1kxrhf3">을 통해 누구나 쉽게 구현할 수 있어요. 기존 SQL 지식만 있으면 빠르게 적응할 수 있었습니다.</span></span></span></p><h3 id="2aaa360d-33e3-8071-94d4-d9cb8abbba00" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3️⃣ 자동 인덱싱의 강력함</span></span></span></h3><p id="2aaa360d-33e3-80f2-b649-c7b0460b0cb6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">모든 컬럼이 bitmap index화</span><span class="css-1kxrhf3">됩니다. 심지어 컬럼이 nested JSON이라도 모든 key가 bitmap index 처리돼요. 이는 사용자나 운영자 입장에서 별도 가이드 없이도 어느 정도 성능을 보장받을 수 있다는 의미였습니다.</span></span></span></p><h3 id="2aaa360d-33e3-80ed-abf4-f0cebbf96a68" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">4️⃣ 비용 효율적인 아키텍처</span></span></span></h3><p id="2aaa360d-33e3-8063-9ffc-e5b3ebe29413" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Cloud-native 아키텍처</span><span class="css-1kxrhf3">이며, Computing과 Storage가 분리된 구조로 비용 측면에서 저렴하게 운영이 가능해 보였습니다.</span></span></span></p><p id="2c6a360d-33e3-8097-b719-d9843aa3decc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-8075-b2ec-e75d29f3d93c" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Druid 도입의 성과</span></span></span></h3><p id="2aaa360d-33e3-8070-94b3-ef8eefa05255" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">읽기와 쓰기가 분리되면서 놀라운 일이 일어났습니다. 승인 플랫폼 팀의 컴퓨팅/휴먼 리소스를 쓰지 않고도, 데이터 조회팀에서 </span><span class="css-q3ktjb">수십억 건의 데이터를 저지연으로</span><span class="css-1kxrhf3"> 부담 없이 조회하고 집계할 수 있게 되었어요.</span></span></span></p><p id="2aaa360d-33e3-801d-9eff-eee0c6b33fe2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이로 인한 결과는 아래와 같습니다.</span></span></span></p><aside id="2c6a360d-33e3-8081-8f88-f5e8a12c1ce3" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2aaa360d-33e3-8036-a389-f74ba4ac3c58" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">실시간성 보장</span><span class="css-1kxrhf3">: 사장님들이 페이지를 새로고침할 때마다 실시간 매출 확인 가능</span></span></span></li><li id="2aaa360d-33e3-80ee-ac00-e0cb6f3e34c5" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">쉬운 개발 환경</span><span class="css-1kxrhf3">: SQL 기반으로 누구나 쉽게 개발 가능</span></span></span></li><li id="2aaa360d-33e3-807f-9b6d-f9c0048f0331" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">빠른 응답 속도</span><span class="css-1kxrhf3">: 수십억 건의 데이터도 빠르게 조회</span></span></span></li></ul></div></aside><p id="2b5a360d-33e3-807d-95f7-e0b72947e0ff" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-8082-b02c-d72e08e8699f" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">MSA 환경에서의 진짜 조회 니즈</span></span></span></h2><p id="2aaa360d-33e3-809f-b6ff-d1aaa3d60e58" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 여기서 끝이 아니었습니다. 실제 고객들이 원한 것은 단순한 데이터 조회를 훨씬 넘어서는 것이었어요.</span></span></span></p><h3 id="2aaa360d-33e3-8045-b1ca-f30ffce8f804" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">고객들의 실제 요구사항</span></span></span></h3><p id="2b5a360d-33e3-80a2-984e-f1d4078f23f6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ </span><span class="css-q3ktjb">넓은 기간 조회</span><span class="css-1kxrhf3"> — “몇 개월, 혹은 몇 년치 데이터를 한 번에 보고 싶어요.”
2️⃣ </span><span class="css-q3ktjb">특정 조건 검색</span><span class="css-1kxrhf3"> — “모든 결제 내역 중 특정 구매자 이름이 포함된 거래를 찾고 싶어요.”
3️⃣ </span><span class="css-q3ktjb">정렬과 집계</span><span class="css-1kxrhf3"> — “정렬, 페이지네이션, 집계 결과를 한눈에 보고 싶어요.”
4️⃣ </span><span class="css-q3ktjb">도메인 간 결합</span><span class="css-1kxrhf3"> — “결제부터 매입, 정산까지 특정 거래 건의 모든 단계를 연결해서 보고 싶어요.”</span></span></span></p><p id="2b5a360d-33e3-8046-b337-e1ef9d54d188" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이러한 요구사항들은 단순한 조회 쿼리로는 처리하기 어려운 복잡한 조회 패턴을 동반했습니다. 대규모 범위 조회, 문자열 검색, 정렬과 페이징 및 집계 연산, 다중 테이블 조인이 필요했어요. 문제는, 이러한 요청을 그대로 원장 테이블에서 수행할 경우 </span><span class="css-q3ktjb">대량의 데이터 스캔, 성능 저하, 비효율적인 쿼리 실행</span><span class="css-1kxrhf3">이 불가피하다는 점이었습니다. 실시간 응답 속도를 유지하기가 점점 어려워졌고, 결국 저희는 이 문제를 해결하기 위해 더 효율적인 데이터 처리 아키텍처와 성능 최적화 전략을 새롭게 설계해야 했어요.</span></span></span></p><p id="2b5a360d-33e3-80eb-9d5c-cf8ee9f3d517" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-809f-8a31-cee5b94fc111" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">실시간 데이터 가공: CDC vs 메시지 발행</span></span></span></h2><p id="2aaa360d-33e3-8053-825b-dbd45bba4023" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">데이터 결합을 위해 많은 테이블을 각 도메인의 DB로부터 옮겨와야 했습니다.</span></span></span></p><h3 id="2aaa360d-33e3-808e-bc71-eea9bb39c41f" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">CDC의 단점</span></span></span></h3><p id="2aaa360d-33e3-805d-99a3-c5043f1b620f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">CDC를 사용하면 도메인 팀과의 의존성은 끊을 수 있지만, 조회 친화적인 역정규화 테이블을 만들기 위해 데이터팀에서 승인팀의 도메인 로직 일부를 들고 있어야 했어요. 결제 승인팀의 수단별 원장은 20개 이상으로 매우 복잡했습니다. 시스템 의존성은 낮아지지만 도메인 의존성이 높아지는 문제가 있었어요.</span></span></span></p><h3 id="2aaa360d-33e3-80cc-9e76-e8181e8462d3" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">메시지 발행 방식의 선택</span></span></span></h3><p id="2b5a360d-33e3-807d-aebb-d16b7a77aeeb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 </span><span class="css-q3ktjb">메시지 발행(Message Publishing) 방식</span><span class="css-1kxrhf3">을 채택했습니다. 완성된 데이터는 각 도메인 팀에서 직접 발행하며, 이를 통해 데이터팀의 도메인 의존성을 감소시키고, 시스템 의존성을 Kafka로 단순화할 수 있었어요. JsonArray 형태를 제외한 데이터 발행 시 Druid의 Bitmap Index가 자동으로 생성되어 효율적인 질의가 가능했습니다.</span></span></span></p><p id="2b5a360d-33e3-8089-9aca-d14b26eb1f29" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Druid의 핵심 장점은 </span><span class="css-q3ktjb">모든 컬럼이 Bitmap Index로 처리되는 구조적 특성</span><span class="css-1kxrhf3">에 있습니다. 이로 인해 별도 조치 없이도 JSON 필드 단위로 테이블화가 용이하며, 일정 수준 이상의 조회 성능이 자연스럽게 보장되었어요.</span></span></span></p><p id="2b5a360d-33e3-80ed-b0a2-c6fa1ee44fa1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-80c1-9376-e844783bd36b" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">AWS 환경에서의 비용 최적화</span></span></span></h2><h3 id="2aaa360d-33e3-80e4-a854-ee537261da81" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Computing과 Storage 분리의 장점</span></span></span></h3><p id="2aaa360d-33e3-8096-abc3-f53021d1b4b4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1️⃣ 저렴한 스토리지 비용</span></span></span></p><p id="2b5a360d-33e3-8091-bdb5-f73c3b9e6d54" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">AWS EBS와 같은 고가의 네트워크 스토리지를 사용할 필요가 없습니다. 모든 데이터는 S3에 안전하게 저장되고, 쿼리 수행에는 고성능 로컬 스토리지를 가진 인스턴스를 활용해요. 테스트 결과, 네트워크 스토리지 대비 로컬 스토리지는 최대 9배 이상 빠른 읽기와 쓰기 성능을 보였어요.</span></span></span></p><p id="2aaa360d-33e3-8052-af08-d762539fef3d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2️⃣ 가용영역 분산의 용이성</span></span></span></p><p id="2b5a360d-33e3-80e6-9e3e-c44656c869d2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">네트워크 스토리지 의존성을 제거하면서 가용 영역(AZ) 단위로의 분산 배치가 훨씬 유연해졌습니다. 결과적으로 장애 발생 시에도 더 유연하게 복구할 수 있는 고가용성(HA) 환경을 확보할 수 있었어요.</span></span></span></p><p id="2aaa360d-33e3-8006-ade2-d044af11b681" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">3️⃣ Spot Instance 활용</span></span></span></p><p id="2b5a360d-33e3-80d4-b641-f9260441b2ba" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">데이터가 S3에 안전하게 보관되어 있기 때문에 각 장비의 로컬에 많은 데이터를 보유하고 있을 필요가 없습니다. 이런 특성을 활용해, 개발과 테스트 환경에서는 Spot Instance를 적극 활용하고 있어요. 이를 통해 더 저렴한 비용으로 서비스를 운영하면서도 일부 노드가 무너지는 상황에서의 서비스 안정성에 대한 평가를 자연스럽게 할 수 있는 환경을 마련했습니다.</span></span></span></p><p id="2c6a360d-33e3-8013-8c88-f5cc669f22b2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b5a360d-33e3-80c1-93cd-e1b8999b061f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이러한 구조적 최적화를 통해 월 약 5천만 원 이상의 클라우드 비용 절감 효과를 달성했습니다. 비용 효율성과 성능, 안정성을 모두 확보한 셈이죠.</span></span></span></p><p id="2b5a360d-33e3-80ce-87b9-f6e8af1d3867" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-804e-ba91-cdc8c31533f0" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">Druid 운영의 도전 과제들</span></span></span></h2><p id="2aaa360d-33e3-80d3-847d-cb023cfda9c2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">장점이 많았지만, 단점도 분명했습니다.</span></span></span></p><h3 id="2aaa360d-33e3-8052-afb8-da9c9eee1a9c" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ 과거 데이터 재적재의 어려움 문제</span></span></span></h3><p id="2b5a360d-33e3-80e0-bd81-cb7b1325eabe" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2001년부터 메시지 발행이 시작된 2024년 직전까지, 모든 결제 수단의 과거 데이터를 조합해 역정규화 테이블을 생성해야 했어요. 특히 무반납 가상계좌의 경우, 최초 발급 시점부터 현재까지의 모든 이력을 보관해야 했기 때문에 데이터량이 방대했습니다. 데이터를 만드는 과정도 복잡했지만, 무엇보다 데이터 정합성을 100% 확보하는 과정이 가장 큰 난관이었죠.</span></span></span></p><h3 id="2aaa360d-33e3-80a0-8dda-d8cf0f87d131" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣ 멱등성 처리 문제</span></span></span></h3><p id="2b5a360d-33e3-80c4-9332-f98cb5e99b3f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">또 다른 문제는 멱등성(idempotency) 처리의 부재였어요. 메시지 중복 발행이나 거래 상태 변경이 발생할 경우, 조회 시점마다 해당 거래의 최종 상태를 정확히 반영해야 했습니다. 이를 위해 보정 내역과 무효화 내역을 별도로 적재한 뒤, 매번 Merge on Read 방식으로 조인하여 최신 상태를 계산해야 했어요. 이 구조는 쿼리를 복잡하게 만들었고, 개발자가 해당 로직을 일부 놓칠 경우 존재하지 않는 데이터가 노출되는 위험도 있었습니다. 결국 이러한 한계들은 Druid의 유지 보수성과 신뢰성 확보에 지속적인 부담으로 작용했습니다.</span></span></span></p><p id="2b5a360d-33e3-80e5-acaa-f30b8646c7a0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-806b-8c75-edc8b238af31" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3️⃣ 데이터 파편화 문제</span></span></span></h3><figure id="2b4a360d-33e3-80da-82bb-e8d158a6f0bc" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/15fd0432-1a7b-4ef4-88e7-2116f1c258a7/스크린샷_2025-11-24_오전_7.34.13.png" alt="" class="css-1pgssrp"/></figure><p id="2c6a360d-33e3-8056-b3e9-fedacc078fde" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">취소 거래 테이블의 경우, 승인 거래와의 연계 조회를 위해 원 승인일자 기준으로 동일하게 파티셔닝되어 있었어요. 예를 들어, 일주일 전에 발생한 거래가 환불될 경우, 취소 거래는 현재 시점에 발생하더라도 데이터는 원 승인일자(즉, 일주일 전 파티션)에 적재됩니다. 이로 인해 데이터가 시점별로 분산되어 테이블 단위의 파편화(Fragmentation)가 발생하고, 조회 시 더 많은 컴퓨팅 자원이 소모되어 성능 저하가 나타났어요.</span></span></span></p><p id="2c6a360d-33e3-8022-afd5-f663aca86829" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 문제를 해결하기 위해 60초 주기 파편화 탐지 프로세스를 도입했어요. 해당 프로세스는 파편화된 테이블을 자동으로 식별한 후, Compaction 작업을 주기적으로 수행함으로써 데이터 세트를 지속적으로 정리하고 통합했습니다. 이를 통해 조회 성능을 안정적으로 극대화할 수 있었어요.</span></span></span></p><p id="2b5a360d-33e3-80f8-b9b6-d91850cf2428" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-8095-b311-edb9397cb02f" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">4️⃣ 복잡한 아키텍처를 가진 시스템 운영의 어려움 문제</span></span></span></h3><figure id="2b5a360d-33e3-8087-9b0c-ea1b525bd913" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/76f2b763-ac70-44a9-b4f9-6b310ddc05a9/251213-tech-inner-2_(1).png" alt="" class="css-1pgssrp"/></figure><p id="2aaa360d-33e3-803a-9401-cdd3865067f3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Druid는 구성요소가 많고 알아야 할 점이 많았는데요,</span></span></span></p><aside id="2c6a360d-33e3-800b-a876-eabbb65d1aa0" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2aaa360d-33e3-8071-bec1-ffb875df2897" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Zookeeper</span><span class="css-1kxrhf3">: 세그먼트 관리 및 노드 상태 관리</span></span></span></li><li id="2aaa360d-33e3-8002-a864-ce1616ed0c22" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Broker</span><span class="css-1kxrhf3">: 메타데이터 기반 쿼리 라우팅</span></span></span></li><li id="2aaa360d-33e3-80f7-b1d1-d6092de5eb14" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Historical</span><span class="css-1kxrhf3">: 세그먼트 데이터 보유</span></span></span></li><li id="2aaa360d-33e3-8080-800f-e9a25a855603" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">MiddleManager</span><span class="css-1kxrhf3">: 세그먼트 재정렬, 입수 작업(peon) 담당</span></span></span></li><li id="2aaa360d-33e3-8032-92b6-f9179ee8dd9c" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Coordinator/Overlord</span><span class="css-1kxrhf3">: 세그먼트 분배, compact 작업 결정</span></span></span></li><li id="2aaa360d-33e3-8023-af1c-fe3b43979122" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Router</span><span class="css-1kxrhf3">: 브로커에 쿼리 전달</span></span></span></li></ul></div></aside><p id="2aaa360d-33e3-8084-b47a-f6222499bb5f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">모든 서비스를 알고 튜닝하고 필요에 따라 각 서비스를 스케일링해야 해야하며, 시스템 </span><span class="css-q3ktjb">운영 난이도가 높았습니다.</span></span></span></p><p id="2b5a360d-33e3-8058-bf07-e630098f47c3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-8075-95b2-db6e1bf3f6e8" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실제 장애 사례</span></span></span></h3><p id="2b5a360d-33e3-8067-81ae-f6607effe13d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">한 번은 파편화된 대량의 데이터를 한꺼번에 적재하는 과정에서 문제가 발생했습니다. 데이터 적재 시 생성된 수많은 세그먼트(segment) 정보가 Zookeeper로 한꺼번에 전달되면서, Zookeeper 트랜잭션 로그의 디스크 공간이 가득 차고, 결국 Druid 전체가 다운되는 장애가 발생한 것이죠.</span></span></span></p><h3 id="2b5a360d-33e3-8076-b11f-e564a0038ed8" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">해결</span></span></span></h3><p id="2b5a360d-33e3-8049-9996-edaf7cca9e64" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희의 해결 방법은 다음과 같았어요. Zookeeper 트랜잭션 로그 보존 주기(retention)를 조정하여 로그 축적을 방지했고, 데이터 전송 과정에서 압축을 적용해 트래픽과 로그 크기를 최소화했습니다. 이후 유사한 상황에서도 안정적으로 데이터가 적재되도록 구조를 개선했어요.</span></span></span></p><p id="2b5a360d-33e3-8077-a37c-f2244393f1b4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">또한, Druid가 조인 문법을 지원하긴 하지만 </span><span class="css-q3ktjb">시스템 구조상 조인 기능이 매우 제한적</span><span class="css-1kxrhf3">이라는 점도 확인했어요.</span></span></span></p><p id="2b5a360d-33e3-80ab-86be-fd5bc3d5d17c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">PG 비즈니스가 생각보다 복잡한 자료구조를 가지고 있기 때문에 많은 양의 테이블에 대한 조인 처리는 필수적이었는데, </span><span class="css-1kxrhf3">PG </span><span class="css-1kxrhf3">비즈니스에서의 여러 도메인 데이터 결합 문제를 풀어나감에 있어서는 Druid가 지원하는 테이블 조인 개수의 한계는 우리의 비즈니스 문제를 푸는데 문제가 되었어요.</span></span></span></p><p id="2c6a360d-33e3-8068-8ef0-c95795838577" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-800b-83a6-ff622718ea77" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">검색의 필수성: Elasticsearch와의 협업</span></span></span></h2><p id="2b5a360d-33e3-8074-9de3-f0483277ba95" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">대고객 서비스에서는 검색 요건이 필수적이에요. 5년이 넘는 기간 동안 축적된 50억 건에서 100억 건에 이르는 방대한 데이터 중 일부 단서만을 기반으로 특정 거래를 신속하게 찾아내는 것이 중요합니다. 단일 시스템으로도 해당 문제를 해결하는 것은 가능해요. 그러나 고속의 검색 성능을 안정적으로 보장하기는 어려워요.</span></span></span></p><h3 id="2aaa360d-33e3-80fb-ba99-f600101258ab" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하이브리드 아키텍처</span></span></span></h3><figure id="2b5a360d-33e3-80c8-86ef-dc5a8405f959" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/d7aac14c-ea99-4663-8332-cc3fb2ae3f4c/스크린샷_2025-11-24_오후_6.57.44.png" alt="" class="css-1pgssrp"/></figure><p id="2aaa360d-33e3-804a-8551-c9cfa857102f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희의 해결책은 명확했습니다.</span></span></span></p><aside id="2c6a360d-33e3-8046-aedd-ca85761ff1dc" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b5a360d-33e3-8077-8e7d-d3a884dae388" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">검색이 필요한 필드는 Elasticsearch에 저장</span></span></span></li><li id="2b5a360d-33e3-800e-b571-dcb701e85f49" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">검색 기능은 Elasticsearch에 위임</span></span></span></li><li id="2b5a360d-33e3-8002-a80e-cd5343b4df31" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">조회 처리는 Druid에서 수행</span></span></span></li></ul></div></aside><p id="2b5a360d-33e3-8036-a54c-cf26e4e712de" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 구조를 통해 </span><span class="css-q3ktjb">Druid의 데이터 스캔 범위를 최소화</span><span class="css-1kxrhf3">하였으며, 결과적으로 불필요한 연산을 줄이고 조회 성능을 안정적으로 개선할 수 있었어요.</span></span></span></p><p id="2c6a360d-33e3-80f2-bb62-d4e85ba659e3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-8023-921b-fafecdb979a0" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">Rollup으로 집계 성능 극대화</span></span></span></h2><p id="2b5a360d-33e3-8091-acaa-d01f1580ba57" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠 제품에서 제공하는 여러 뷰 중 일부는 집계형 데이터를 포함하며, 동시에 실시간 조회 성능을 요구합니다. 기존에는 특정 기간의 거래 데이터를 조회하기 위해 여러 Druid 테이블을 UNION ALL로 합친 뒤 최종 집계를 수행했어요. 이 방식은 원천 데이터를 유지한 채 실시간 조회가 가능했지만, 데이터 규모가 커질수록 스캔 비용이 급격히 증가하여 성능 저하가 발생했습니다.</span></span></span></p><h3 id="2aaa360d-33e3-809a-b716-f45d86fc115f" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Druid Rollup 기능</span></span></span></h3><p id="2aaa360d-33e3-806f-8977-fdaee0c69881" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Rollup</span><span class="css-1kxrhf3">은 동일한 차원(Dimension) 값을 가지는 데이터를 </span><span class="css-q3ktjb">자동으로 집계(Aggregation)하여 저장</span><span class="css-1kxrhf3">하는 방식이에요. 쿼리 실행 시 별도의 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">GROUP BY</span></code><span class="css-1kxrhf3">와 같은 집계 연산을 수행할 필요 없이, </span><span class="css-q3ktjb">미리 실시간으로 집계된 데이터를 즉시 조회</span><span class="css-1kxrhf3">할 수 있습니다. 조회해야 하는 데이터 스캔이 줄어들면서 조회 성능이 향상되죠.</span></span></span></p><figure id="2b4a360d-33e3-808b-8325-f871558e3030" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/14adbf03-1312-4fc5-93d5-4e1e8bb720f5/스크린샷_2025-11-24_오전_7.38.57.png" alt="" class="css-1pgssrp"/></figure><h3 id="2aaa360d-33e3-8079-9ec6-ce35d192fa20" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">성과</span></span></span></h3><p id="2b5a360d-33e3-805d-9e27-f8da3da63a1e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Rollup 적용 전후의 성능 차이는 매우 뚜렷했어요. 적용 이전에는 수십억 건에 달하는 원천 데이터를 직접 조회해야 했기 때문에, 평균 응답 시간이 수십 초에 이르렀습니다. 반면, Rollup을 적용한 이후에는 같은 쿼리가 평균 0.5~1초 수준으로 단축되었어요. 결과적으로 최대 99%의 성능 향상을 확인할 수 있었으며, 이는 데이터 접근 경로 단축과 사전 집계 구조의 효율성이 결합된 결과였습니다.</span></span></span></p><p id="2b5a360d-33e3-80cd-9fcd-f7d01a2b6aac" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-809e-b548-df555c29bdab" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">도메인 간 데이터 결합의 필요성 </span></span></span></h3><p id="2aaa360d-33e3-80a1-a390-dfe10c4e7d6e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">제품이 고도화되면서 사장님들의 요구사항은 점점 더 복잡해졌습니다. 예를 들어, 결제와 매입, 정산 같은 타 도메인 간 데이터 결합에 대한 수요가 있었어요. 각 도메인 간 데이터 결합이 불가피한 상황이 왔죠. 요구사항을 충족하기 위해서는 서로 다른 데이터베이스의 데이터를 결합해야 하는 상황이 발생한 것입니다. 토스페이먼츠 결제의 Lifecycle을 한눈에 볼 수 있는 더 큰 범위의 통합 원장이 필요하게 됐습니다. 실제 구매가 얼마였고, 실제 순이익이 얼마인지 알 수 있어야 했어요.</span></span></span></p><p id="2b5a360d-33e3-80b5-a2f5-c65bace5e999" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b5a360d-33e3-80f1-8d0c-ebe36671cb18" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">StarRocks 도입: 새로운 전환점</span></span></span></h2><p id="2b5a360d-33e3-803f-bf02-c98e53f19e18" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 점점 복잡해지는 원장 데이터 구조 속에서, Druid가 가진 멱등성 처리 한계와 조인 제약을 넘어서기 위해 새로운 방향을 고민했습니다. 그 결과, 데이터 일관성을 지키면서도 빠르고 유연한 조회가 가능한 StarRocks를 도입하게 됐어요. 이 결정은 단순히 시스템을 교체하는 수준이 아니라, 데이터 서빙 구조 전반을 &#x27;통합과 실시간성 중심&#x27;으로 재설계한 전환점이었습니다.</span></span></span></p><h3 id="2b5a360d-33e3-80b8-bfd1-e90f0ee56499" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">왜 StarRocks였을까</span></span></span></h3><p id="2b5a360d-33e3-8089-9abf-d2b8355b6c54" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">StarRocks를 선택한 이유는 다음과 같아요.</span></span></span></p><p id="2b5a360d-33e3-8092-a810-ea10c69f69b8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">첫째, </span><span class="css-q3ktjb">Druid의 한계를 보완</span><span class="css-1kxrhf3">할 수 있었습니다. 멱등성 처리가 안정적으로 지원되기 때문에 중복 데이터나 불안정한 이벤트를 관리하기 훨씬 수월해졌어요.</span></span></span></p><p id="2b5a360d-33e3-802a-984d-f37588bf3bdd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">둘째, </span><span class="css-q3ktjb">분석 시스템과의 일관성</span><span class="css-1kxrhf3">을 확보할 수 있었습니다. StarRocks는 기존 분석 인프라와 구조적으로 유사한 형태를 가지고 있어, 데이터 흐름을 단순화하고 </span><span class="css-q3ktjb">유지 보수 부담을 크게 줄일 수 있었습니다.</span></span></span></p><p id="2b5a360d-33e3-80c2-bcf8-f0dc7a2388da" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">셋째, </span><span class="css-q3ktjb">조인(Join) 성능이 압도적으로 높았어요. </span><span class="css-1kxrhf3">이 덕분에 여러 도메인의 데이터를 쉽게 결합해볼 수 있었습니다.</span></span></span></p><h3 id="2aaa360d-33e3-80ae-a480-f4d475c73b19" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">멱등성 처리의 강력함</span></span></span></h3><p id="2aaa360d-33e3-8071-bbdf-fd192402f3f5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">멱등성 처리가 되면 장점이 매우 많아집니다. CDC(Change Data Capture) 기반 메시지를 활용해 원장 테이블을 그대로 실시간 복제할 수 있고, 중복 메시지가 들어오더라도 재처리가 간단해요. 이 구조 덕분에 데이터 정합성을 유지하기 쉬워졌고, 테이블 설계 시 Append Only 제약을 고려하지 않아도 되어 개발자 입장에서 훨씬 자유로운 설계가 가능해졌습니다. 결국, 시스템 복잡도는 낮추면서도 신뢰성과 안정성을 동시에 확보하게 됐죠.</span></span></span></p><h3 id="2aaa360d-33e3-802f-ab87-dfc8936be779" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">분석 시스템과의 통일성</span></span></span></h3><p id="2b5a360d-33e3-80b6-9a25-c1293891962a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Druid 시절에는 Spark나 Trino를 통해 여러 원장 테이블을 조합하고, 그 결과를 S3에 저장한 뒤 다시 Druid로 불러오는 번거로운 과정이 필요했습니다. StarRocks로 전환한 이후에는 훨씬 단순해졌어요. 여러 카탈로그(Catalog)를 쉽게 연결할 수 있고, Hive 카탈로그에서의 작업 결과를 StarRocks 카탈로그로 바로 가져올 수 있습니다. 또 모든 필드를 비트맵 인덱스로 처리하지 않아 데이터 적재 속도도 훨씬 빨라졌어요.</span></span></span></p><h3 id="2aaa360d-33e3-8046-b3ba-d6a8f524db73" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">단순한 아키텍처</span></span></span></h3><p id="2aaa360d-33e3-80fe-a66d-dd41fe1949de" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">StarRocks는 Druid와 달리 </span><span class="css-q3ktjb">매우 단순한 구조</span><span class="css-1kxrhf3">를 가지고 있습니다:</span></span></span></p><figure id="2b4a360d-33e3-8033-aae5-d62de0e881fb" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/8aa4b3c8-1b47-40ca-b278-0076f20e9e48/251213-tech-inner-1_(1).png" alt="" class="css-1pgssrp"/></figure><ul class="css-uswsmm"><li id="2b5a360d-33e3-8045-8995-dbce857f83c5" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">FE (Frontend)</span><span class="css-1kxrhf3">: 메타정보를 관리하고, 쿼리를 라우팅합니다.</span></span></span></li><li id="2b5a360d-33e3-806a-84e9-def80572f2ec" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">CN (Computing Node)</span><span class="css-1kxrhf3">: S3에서 내려받은 핫 캐시(hot cache)를 보유한 계산 노드로, 실제 연산을 수행합니다.</span></span></span></li></ul><p id="2b5a360d-33e3-8026-b745-fd4ccdbc1910" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 구조는 S3 기반의 공유형 구조(shared architecture)로 이루어져 있는데요. 구조가 단순하여 </span><span class="css-q3ktjb">유지 보수가 용이하고</span><span class="css-1kxrhf3">, </span><span class="css-q3ktjb">수평 확장이 자유로워요.</span></span></span></p><h3 id="2aaa360d-33e3-80a8-93c9-f21581db6b8a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">유연한 JOIN 지원</span></span></span></h3><p id="2b5a360d-33e3-8068-ad77-ed9fc87e5cba" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">과거 </span><span class="css-q3ktjb">Druid</span><span class="css-1kxrhf3"> 환경에서는 JOIN 제약으로 인해 역정규화(denormalization)된 테이블 구조를 유지해야 했습니다. 반면, </span><span class="css-q3ktjb">StarRocks</span><span class="css-1kxrhf3">에서는 다음과 같은 개선이 이루어졌어요.</span></span></span></p><aside id="2c6a360d-33e3-8026-9ec9-d797eef6bfd4" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b5a360d-33e3-8027-b5b1-cdeb3acb58c1" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">CDC(Change Data Capture)를 활용하여 </span><span class="css-q3ktjb">MySQL 원본 테이블의 스키마를 그대로 유지</span></span></span></li><li id="2b5a360d-33e3-8025-95a1-f4e136154e2f" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">필요한 형태의 </span><span class="css-q3ktjb">통합 원장을 SQL JOIN을 통해 요청 시 즉시 조회</span><span class="css-1kxrhf3"> 가능</span></span></span></li><li id="2b5a360d-33e3-8082-8b9d-c67fec936499" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">데이터 모델링의 제약이 적은 </span><span class="css-q3ktjb">유연한 개발 환경</span><span class="css-1kxrhf3"> 제공</span></span></span></li></ul></div></aside><p id="2b5a360d-33e3-80f0-9345-e1ba91472720" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 통해 데이터 일관성을 유지하면서도, 복잡한 조인 쿼리를 유연하게 처리할 수 있는 구조를 확보했습니다.</span></span></span></p><p id="2c6a360d-33e3-809e-bddf-f0231bc597be" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-8027-83c5-edb47f7419fb" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">StarRocks 성능 최적화 전략</span></span></span></h2><h3 id="2aaa360d-33e3-80fa-9179-c7a992f470e7" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ Colocation Group: 조인 성능 극대화</span></span></span></h3><p id="2aaa360d-33e3-80d2-9ce0-c368ced268c6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">대규모 테이블 간 조인 연산에서 가장 큰 성능 병목은 네트워크 간 데이터 이동(Shuffle)입니다.</span></span></span></p><figure id="2b4a360d-33e3-8099-ad7b-ded0c665c645" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/c8e5007d-4265-4fa9-954a-9fc6f8ad495f/스크린샷_2025-11-24_오전_7.46.24.png" alt="" class="css-1pgssrp"/></figure><h3 id="2aaa360d-33e3-8072-bdb1-fb1b01172be0" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Colocation Group이란?</span></span></span></h3><p id="2b5a360d-33e3-80c2-a40a-fcce930cab67" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Colocation Group은 두 개 이상의 테이블을 특정 컬럼(예: 거래 ID)을 기준으로 동일한 해시 알고리즘을 적용해 데이터를 분산 저장하는 방식이에요. 이를 통해 동일한 값을 갖는 데이터가 반드시 동일한 노드 및 동일한 버킷(Bucket)에 위치하도록 강제합니다. 이 구조는 조인(Join) 연산 시 데이터의 네트워크 이동을 최소화하여 성능을 향상시키는 역할을 해요. 즉, 조인 연산이 노드 내부에서만 수행되므로 추가적인 네트워크 전송이 불필요하게 되는 것이죠.</span></span></span></p><h3 id="2aaa360d-33e3-8000-b4a9-e40f7583738a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">성능 테스트 결과</span></span></span></h3><aside id="2c6a360d-33e3-80e8-8cf3-fc4f2e5a882a" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">테스트 환경</span></span></span></h4><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b5a360d-33e3-8054-a4b5-dd24d7f7d354" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">A 테이블: 약 10억 건</span></span></span></li><li id="2b5a360d-33e3-801f-806d-ebe27c31d511" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">B 테이블: 약 8억 건</span></span></span></li></ul><p id="2b5a360d-33e3-80ef-aa36-d9ba9abde2d5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">결과</span></span></span></p><ul class="css-uswsmm"><li id="2b5a360d-33e3-80be-a02f-d405e50ee89a" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Colocation Group 미적용 시: 평균 </span><span class="css-q3ktjb">13초</span></span></span></li><li id="2b5a360d-33e3-80a6-a267-ea34522202fe" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Colocation Group 적용 시: 평균 </span><span class="css-q3ktjb">2초</span></span></span></li><li id="2b5a360d-33e3-8035-94a5-cf620824bab4" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">약 84.6%의 성능 개선</span><span class="css-1kxrhf3">을 확인</span></span></span></li></ul></div></aside><p id="2b5a360d-33e3-804e-a85c-eb3289d4e629" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 실험 결과를 통해 Colocation Group 적용이 </span><span class="css-q3ktjb">대규모 조인 연산의 처리 효율을 크게 향상</span><span class="css-1kxrhf3">시킴을 확인했습니다.</span></span></span></p><h3 id="2aaa360d-33e3-8019-b7fd-e8ffa942e569" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">주의사항</span></span></span></h3><p id="2b5a360d-33e3-8077-8041-f8a101e18678" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Colocation Group</span><span class="css-1kxrhf3">을 적용할 때에는 다음 사항에 유의해야 합니다.</span></span></span></p><aside id="2c6a360d-33e3-8055-a8b1-c8076d76a382" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b5a360d-33e3-80ff-a9c9-c0c5ace551c0" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">조인 대상 </span><span class="css-q3ktjb">두 테이블의 Bucket 키는 동일</span><span class="css-1kxrhf3">해야 합니다.</span></span></span></li><li id="2b5a360d-33e3-80e0-8ff9-e2257820790b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">조인 대상 </span><span class="css-q3ktjb">두 테이블의 Bucketing 개수 또한 일치</span><span class="css-1kxrhf3">해야 합니다.</span></span></span></li><li id="2b5a360d-33e3-80e7-99ba-f5a0498f0f92" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이러한 제약 조건은 </span><span class="css-q3ktjb">시스템의 수평 확장성에 불리하게 작용</span><span class="css-1kxrhf3">할 수 있습니다.</span></span></span></li></ul></div></aside><p id="2b5a360d-33e3-8030-9b67-cbc9543003ea" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-80f3-b86e-e637c03b4a9b" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣ Prefix Index: 데이터 스캔 최소화</span></span></span></h3><p id="2aaa360d-33e3-80e7-90c9-c166efed8922" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">StarRocks의 </span><span class="css-q3ktjb">Prefix Index</span><span class="css-1kxrhf3">를 활용한 데이터 스키핑(data skipping) 기법입니다.</span></span></span></p><figure id="2b4a360d-33e3-8070-9ef9-c06fae99da05" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/00cbcff3-b51a-42e7-ae6a-6f5f5a172317/251213-tech-inner-3.png" alt="" class="css-1pgssrp"/></figure><h3 id="2aaa360d-33e3-80da-a775-cdfbf946f831" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Sort Key 설정</span></span></span></h3><p id="2b5a360d-33e3-8035-9ec6-eb59eb7c4f4a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">StarRocks에서 </span><span class="css-q3ktjb">Sort Key</span><span class="css-1kxrhf3">를 설정하면 다음과 같은 동작이 수행됩니다.</span></span></span></p><aside id="2c6a360d-33e3-80f8-b692-e9a44f4a6c9b" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b5a360d-33e3-807e-b555-e315a8aed45e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">데이터가 지정된 키를 기준으로 </span><span class="css-q3ktjb">정렬되어 저장</span><span class="css-1kxrhf3">됩니다.</span></span></span></li><li id="2b5a360d-33e3-805a-b5cc-d5096ba62358" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">약 </span><span class="css-q3ktjb">1,024개 행(row)</span><span class="css-1kxrhf3"> 단위로 페이지 포인터(Page Pointer)를 보유하여, 해당 구간의 물리적 주소를 관리합니다.</span></span></span></li><li id="2b5a360d-33e3-8091-8291-eef8affb786e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 통해 </span><span class="css-q3ktjb">데이터 스캔 범위를 효과적으로 축소</span><span class="css-1kxrhf3">할 수 있으며, 특정 조건 검색 시 불필요한 I/O를 최소화할 수 있습니다.</span></span></span></li></ul></div></aside><p id="2b5a360d-33e3-8066-8508-d13fa05b909a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-80da-9d8c-f49b825db76a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠의 적용 사례</span></span></span></h3><figure id="2b4a360d-33e3-80ac-832f-fe00c876d445" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/323c05c4-cf86-4512-96ea-a6687b9d06cf/스크린샷_2025-11-24_오전_7.54.04.png" alt="" class="css-1pgssrp"/></figure><p id="2b5a360d-33e3-806c-ae5b-c822a0c6f752" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Sort Key 순서</span><span class="css-1kxrhf3">는 다음과 같아요.</span></span></span></p><ol class="css-hokoge"><li id="2b5a360d-33e3-8096-8bd8-f6fce09db4e7" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">가맹점 ID</span><span class="css-1kxrhf3"> — 필수적이며 가장 빈번하게 사용되는 조회 조건</span></span></span></li><li id="2b5a360d-33e3-809b-be44-faee0443c0bd" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">거래 시각(Timestamp)</span><span class="css-1kxrhf3"> — 각 가맹점 ID에 대응되는 세부 정렬 기준</span></span></span></li></ol><p id="2c6a360d-33e3-80ec-a669-efcd7cede962" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이러한 구조를 적용함으로써 다음과 같은 성능상의 이점을 확보했어요. </span></span></span></p><p id="2c6a360d-33e3-80d2-9089-fbc36f63cdbf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Prefix Index를 활용하여 특정 가맹점의 데이터 시작 위치를 즉시 탐색할 수 있게 되었고, 조회 조건과 무관한 데이터 블록을 스캔하지 않고 건너뛰는(Data Skipping) 방식을 적용하여 데이터 스캔 범위를 최소화할 수 있었습니다.</span></span></span></p><p id="2c6a360d-33e3-807f-bb14-da78f97ecac4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결과적으로, 전체 데이터 읽기량(RawRowsRead)이 </span><span class="css-q3ktjb">약 99.68% 감소</span><span class="css-1kxrhf3">했어요. 이는 Sort Key 기반의 정렬 구조와 Prefix Index 최적화가 결합된 결과로, 대용량 거래 데이터 조회 성능을 획기적으로 개선하는 데 기여하였습니다.</span></span></span></p><p id="2b5a360d-33e3-80c0-9b82-d0810ed615dc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b5a360d-33e3-8000-b638-ec00188a3c29" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3️⃣ 전체 성능 개선 비교</span></span></span></h3><p id="2b5a360d-33e3-8032-89bf-fbd2672ddb75" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">성능 테스트 환경</span><span class="css-1kxrhf3">: MySQL, Oracle, Apache Druid, 최적화 전 StarRocks, 최적화 후 StarRocks</span></span></span></p><p id="2b5a360d-33e3-80b0-bbbf-d743c8e3160e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">응답 속도 비교</span></span></span></p><aside id="2c6a360d-33e3-80a9-af8a-dc75521d64e7" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b5a360d-33e3-805a-b0ff-f95e63845bba" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">MySQL / Oracle</span><span class="css-1kxrhf3">: 전반적으로 가장 낮은 성능을 보임</span></span></span></li><li id="2b5a360d-33e3-80ec-8381-f88c33609525" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Apache Druid</span><span class="css-1kxrhf3">: 중간 수준의 응답 속도 확보</span></span></span></li><li id="2b5a360d-33e3-80af-b293-cbff3cfc0594" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">일반 StarRocks</span><span class="css-1kxrhf3">: Druid 대비 우수한 응답 속도</span></span></span></li><li id="2b5a360d-33e3-80b5-94e3-d41c325150a0" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">최적화된 StarRocks</span><span class="css-1kxrhf3">: 최적화 이전 대비 </span><span class="css-q3ktjb">약 77.3% 향상된 성능</span><span class="css-1kxrhf3"> 달성</span></span></span></li></ul></div></aside><p id="2b5a360d-33e3-8026-aadf-dd6e94ad1a71" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">최적화 전 StarRocks 대비 </span><span class="css-q3ktjb">약 81.2% 감소한 CPU 사용률</span><span class="css-1kxrhf3">로 동일한 쿼리 부하를 처리할 수 있었어요. 이는 데이터 스캔 효율성 향상과 연산 경로 단축의 결과로 분석됩니다.</span></span></span></p><p id="2c6a360d-33e3-80f4-aa03-f76426f11c7f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b5a360d-33e3-80f1-9909-d99936187cef" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Prefix Index를 활용한 테이블 최적화는 데이터 스캔 범위를 효과적으로 축소하여 쿼리 응답 성능을 향상시키고, 동시에 시스템 자원(CPU) 사용량을 대폭 절감하는 매우 효율적인 접근 방식으로 평가됩니다. 이를 통해 대용량 거래 데이터 환경에서도 안정적이고 일관된 조회 성능을 확보할 수 있었어요.</span></span></span></p><p id="2c6a360d-33e3-80c4-a02c-f0099ad39c1d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-800e-aa63-f61a0e380498" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">현재 토스페이먼츠의 데이터 서빙 구조</span></span></span></h2><figure id="2b4a360d-33e3-80b0-8ec7-de771ced1cb0" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/aa112d3a-ef0d-4a1f-b757-d1dbeab53f59/스크린샷_2025-11-24_오전_7.54.46.png" alt="" class="css-1pgssrp"/></figure><p id="2b5a360d-33e3-8015-a625-e0f609392497" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">현재 토스페이먼츠(Toss Payments)의 데이터 서빙 구조는 다음과 같아요.</span></span></span></p><aside id="2c6a360d-33e3-80e1-b761-f3fae3ca8401" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b5a360d-33e3-8082-81d2-ea5985352b05" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">CDC(Change Data Capture) 기술과 메시지 발행(Message Publishing) 방식</span><span class="css-1kxrhf3">을 활용하고 있습니다.</span></span></span></li><li id="2b5a360d-33e3-80ab-b566-e66f36b7b4da" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Kafka</span><span class="css-1kxrhf3"> 및 </span><span class="css-q3ktjb">Flink</span><span class="css-1kxrhf3">를 통해 데이터 변경 사항을 </span><span class="css-q3ktjb">실시간으로 StarRocks에 반영</span><span class="css-1kxrhf3">합니다.</span></span></span></li><li id="2b5a360d-33e3-8066-bea1-dc893a498b51" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">검색 기능이 필요한 일부 데이터</span><span class="css-1kxrhf3">는 </span><span class="css-q3ktjb">Elasticsearch</span><span class="css-1kxrhf3">로 별도 수집하여 색인화합니다.</span></span></span></li><li id="2b5a360d-33e3-80e5-b892-df9bc1fdc7de" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">필요한 통합 원장(Integrated Ledger)은 실시간으로 가공·제공됩니다.</span></span></span></li></ul></div></aside><p id="2b5a360d-33e3-8053-9308-ff02ce7c5951" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이러한 구조를 통해 경영자 및 가맹점 사업자(사장님)에게 보다 </span><span class="css-q3ktjb">다양하고 심층적인 인사이트를 신속하게 제공</span><span class="css-1kxrhf3">할 수 있게 되었습니다.</span></span></span></p><p id="2b5a360d-33e3-8014-8bff-ea57fe6fb5da" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-8081-8728-e1702daa2e66" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">마치며</span></span></span></h2><p id="2b4a360d-33e3-806d-bd39-d93cfcd17f42" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">대규모 실시간 서빙은 “만능 데이터베이스를 찾는 일”이 아니라, </span><span class="css-q3ktjb">도메인을 이해하고 각 엔진의 강점을 정확히 조합</span><span class="css-1kxrhf3">하는 일임을 다시 확인했어요. 저희는 검색(Elasticsearch), 시계열 집계(Druid), 조인/통합 원장(StarRocks)을 </span><span class="css-q3ktjb">한 레이어에서 일관된 경험</span><span class="css-1kxrhf3">으로 묶었고, 그 과정에서 얻은 가장 큰 배움은 단순합니다.</span></span></span></p><blockquote id="2b4a360d-33e3-80b1-a4e9-ea215990a187" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">적게 읽도록 설계하면, 빠르고 효율적이며 정확해진다.</span></span></span></blockquote><p id="2b4a360d-33e3-8064-a0bd-d8e0b9c647e0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실전에서 통했던 원칙은 </span><span class="css-q3ktjb">세 줄</span><span class="css-1kxrhf3">로 요약할 수 있어요.</span></span></span></p><aside id="2c6a360d-33e3-800d-a8a1-db32f5c83569" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b4a360d-33e3-8027-a9cc-e37a9a0e7e91" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">스캔 최소화</span><span class="css-1kxrhf3">: 검색으로 후보를 좁히고, 서빙에서 확정·집계</span></span></span></li><li id="2b4a360d-33e3-80a2-bd86-c35400831846" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">사전 계산 + 멱등성</span><span class="css-1kxrhf3">: 롤업/집계테이블로 스캔 비용을 선지불하고, CDC 재처리·중복에 내성 확보</span></span></span></li><li id="2b4a360d-33e3-8049-8e3b-e9ecf9b455ac" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">조인·운영 최적화</span><span class="css-1kxrhf3">: Colocation·정렬키로 셔플 제거, 컴팩션·메타스토어 가드레일</span></span></span></li></ul></div></aside><p id="2b4a360d-33e3-807b-9b67-e9f2cd1072f5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">앞으로는 </span><span class="css-q3ktjb">AWS + IDC 분산 환경에서의 일관성 모델과 지연 편차 관리</span><span class="css-1kxrhf3">라는 숙제가 남아 있어요. 하지만 문제의 크기와 무관하게, 저희는 같은 질문으로 시작하려고 합니다.</span></span></span></p><ol class="css-hokoge"><li id="2b4a360d-33e3-8076-ad08-c857fdda8299" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">정확성</span><span class="css-1kxrhf3">을 잃지 않고, 2) </span><span class="css-q3ktjb">적게 읽도록</span><span class="css-1kxrhf3">, 3) </span><span class="css-q3ktjb">효율적인 운영이 가능한 방식</span><span class="css-1kxrhf3">으로 문제를 풀었는가?</span></span></span></li></ol><p id="2b4a360d-33e3-808a-91c9-d7e8caf14249" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 글이 대규모 데이터 서빙을 고민하는 데이터 엔지니어들에게 </span><span class="css-q3ktjb">설계의 체크리스트</span><span class="css-1kxrhf3">이자 </span><span class="css-q3ktjb">실패를 줄이는 힌트</span><span class="css-1kxrhf3">가 되길 바랍니다. 더 좋은 방법과 새로운 시도를 함께 실험해 보고 싶습니다.</span></span></span></p><p id="2b5a360d-33e3-80d2-a9ac-f1f5cdfb4697" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><p id="2aaa360d-33e3-8025-b2cc-ff5fe538b81a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">✅ </span><span class="css-q3ktjb">이번 아티클은 Toss Makers Conference의 세션을 바탕으로 재구성되었습니다.</span></span></span></p><figure id="2aaa360d-33e3-808d-87f0-f94eb3fdc15f" class="css-of5acw"><div class="css-oni540"><iframe src="https://www.youtube.com/embed/ZiNrjCpgdSo" frameBorder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" class="css-122y91a"></iframe></div></figure><p id="2b5a360d-33e3-8015-aee9-ca33a3c78c8c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b5a360d-33e3-8096-a24e-c0bbfb331b79" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[달리는 기차 바퀴 칠하기: 7년만의 컬러 시스템 업데이트]]></title>
            <link>https://toss.tech/article/tds-color-system-update</link>
            <guid>https://toss.tech/article/tds-color-system-update</guid>
            <pubDate>Mon, 15 Dec 2025 01:58:00 GMT</pubDate>
            <description><![CDATA[토스의 디자인 시스템, TDS의 컬러 시스템을 7년 만에 전면 개편하며 마주했던 문제들과, 이를 해결하기 위해 토큰 시스템을 처음부터 다시 만들어간 과정을 공유합니다.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2bca360d-33e3-80e6-9dfb-cbaf65f42ec8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요, 토스 디자인 플랫폼팀 UX Engineer 윤민석, Platform Designer 권윤입니다.</span></span></span></p><p id="2bca360d-33e3-80a0-ab9b-e85a8d51e87e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">디자인 시스템은 변화하는 서비스 속에서도 일관성과 확장성을 지켜주는, 보이지 않는 인프라예요. 토스팀도 미세한 균형 속에서 더 넓은 세상으로 확장할 준비를 해왔는데요. 그 여정의 출발점이자, 더 큰 변화를 위한 기반이 된 것이 바로 </span><span class="css-q3ktjb">컬러 시스템 개편</span><span class="css-1kxrhf3">이었어요.</span></span></span></p><p id="2bca360d-33e3-80e4-a26e-fecf3dab2e86" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이번 글에서는 TDS(Toss Design System)의 핵심 중 하나인 컬러 시스템을 7년 만에 전면 개편하며 마주했던 문제들과, 이를 해결하기 위해 토큰 시스템을 처음부터 다시 만들어간 과정을 공유하려고 해요.</span></span></span></p><p id="2bca360d-33e3-80a6-bab6-c2a31f557d79" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2bca360d-33e3-8041-a70e-cdf07fbf9002" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">7년간 외면해온 문제들</span></span></span></h3><p id="2bca360d-33e3-8018-84e3-e225fe62c309" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">TDS 컬러 시스템은 2018년 디자인 시스템이 처음 만들어졌을 때부터 큰 변화 없이 유지되어 왔어요. 7년 동안 컬러 토큰을 사용하면서 여러 문제를 마주했는데요, 특히 컬러 팔레트에서 발견한 문제가 많았어요.</span></span></span></p><p id="2bca360d-33e3-80a2-9356-f8408f535809" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">첫 번째 문제는 컬러끼리 명도가 다 달랐다는 거예요.
</span><span class="css-1kxrhf3">같은 100인데 Grey 100, Blue 100, Red 100의 명도가 다 달라서, 리스트에서 같이 썼을 때 전부 100으로 통일해도 얼룩덜룩해 보이는 문제가 있었어요. 실제로 Grey 100은 1.1:1 대비인데, Red 100은 1.34:1이었죠.</span></span></span></p><figure id="2c4a360d-33e3-8060-9dbf-dad964b848b5" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/9dcfe96b-0a93-4dd6-b5d3-ac6d578fa4a6/스크린샷_2025-12-11_오후_2.26.58.png" alt="" class="css-1pgssrp"/></figure><p id="2bca360d-33e3-80ce-a29a-fc44638410fa" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">라이트모드와 다크모드의 명도 기준도 많이 달랐어요. 같은 Teal 50을 썼는데도 라이트모드에서는 1.06:1이고 다크모드에서는 1.36:1이어서, 다크모드에서만 너무 튀는 색이 되었어요. 그래서 디자이너들은 보통 라이트모드를 기준으로 디자인하다가 다크모드에서 의도치 않은 색이 나와서 당황하고, 다크모드 색을 커스텀하는 경우도 많았어요.</span></span></span></p><figure id="2c4a360d-33e3-8063-8d4b-c030172e43ff" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/dcff15e2-4eea-4bca-bfe6-c3571036b5e6/스크린샷_2025-12-11_오후_2.27.36.png" alt="" class="css-1pgssrp"/></figure><p id="2bca360d-33e3-8061-ab84-d2949ebd1ba3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">즉, 2가지 색상만 써도 4가지 케이스(라이트 Grey, 라이트 Blue, 다크 Grey, 다크 Blue)를 모두 고려하며 만들어야 하는 상황이 지속적으로 반복되었죠.</span></span></span></p><p id="2bca360d-33e3-8016-95a3-f3e4cc760fa3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">두 번째로는 접근성 문제가 있었어요.
</span><span class="css-1kxrhf3">TDS 컬러들은 해상도가 낮은 디바이스나 가상환경에서도 쓰이게 되는데요, 이때 밝은 컬러들이 다 날아가서 보이지 않는 경우도 있었어요.</span></span></span></p><figure id="2c5a360d-33e3-8090-bbcd-e8981f8e2df2" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/89ea98d4-00db-4104-a172-118b3a68e2db/스크린샷_2025-12-11_오후_2.28.11.png" alt="" class="css-1pgssrp"/></figure><p id="2bca360d-33e3-80f7-a673-e35bb6d00bd6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 문제들이 사실 디테일하고 작은 문제들처럼 보이지만, 모여서 결국 디자인 완성도와 업무 효율성을 떨어뜨리고, 커뮤니케이션 비용을 높이고 있었어요.</span></span></span></p><p id="2bca360d-33e3-802e-a83b-dea3ab311af1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2bca360d-33e3-8005-9fb4-e1b8658fac0b" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">왜 개선하지 못했을까</span></span></span></h3><p id="2bca360d-33e3-80bb-8c47-f668fee53b99" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">앞선 문제들을 해결하기 위한 첫 번째 시도는 간단해 보였어요. 같은 100인데 Blue 100이 더 진해서, Blue 100을 더 밝게 바꿔보는 거예요.</span></span></span></p><p id="2bca360d-33e3-805b-a509-c378a6f28019" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그런데 사실 Grey 100, Blue 100은 큰 팔레트의 일부잖아요. 부분의 변경사항이 있을 때, 팔레트를 구성하는 다른 컬러 토큰들에서 문제가 발생하기 쉬워요. Blue 100만 고쳤더니 Red 100, Yellow 100, Green 100도 같이 봐야 하고, Blue 컬러 전체의 명도 진행도 다시 고려해야 했어요. 게다가 다크모드 팔레트까지 하면, 고려할 점이 곱하기 2가 돼요.</span></span></span></p><figure id="2c5a360d-33e3-80e4-8270-c68ff5c240e0" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/7b189bea-8fc3-4e6b-9680-62941591c6a4/스크린샷_2025-12-12_오후_9.45.17.png" alt="" class="css-1pgssrp"/></figure><p id="2bca360d-33e3-803e-bdce-e3270f0f130d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">결국 컬러 팔레트의 문제를 해결할 때는 작은 부분의 문제를 해결할 때에도 전체 팔레트를 건드려야 해요.</span></span></span></p><p id="2bca360d-33e3-809e-bdcb-cd179d11509e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">TDS 토큰에 있었던 또 하나의 문제는, 토큰이 수많은 사용처에서 각각 따로 관리되고 있었다는 거예요. 보통 Single Source of Truth를 추구하지만, 정확히 그 반대의 상황이었어요. 웹, 네이티브, 서버, 데우스(Design Editor) 등에서 각자 컬러를 관리하고 있고 스펙이 조금씩 달라서 추적이 어려웠어요.</span></span></span></p><figure id="2c5a360d-33e3-8062-a02d-f088d8294a10" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/e2b15af8-243d-4254-a404-d1869bc008b9/스크린샷_2025-12-12_오후_9.46.26.png" alt="" class="css-1pgssrp"/></figure><p id="2bca360d-33e3-8066-875a-ca122f9f7813" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 구조 때문에 새로운 토큰을 추가한다고 가정했을 때, 모든 플랫폼의 개발자, 다른 계열사의 플랫폼 디자이너, 디자인 에디터인 데우스팀까지 불러모아 소통해야 하는 엄청난 비효율이 생겼어요. 그리고 이 과정에서 플랫폼별로 이격이 발생하기 쉬웠죠. 실제로 &quot;데우스에는 있고 iOS에는 없는 토큰이 있는데 뭐예요?&quot; 같은 문의가 많았어요.</span></span></span></p><p id="2bca360d-33e3-8062-9590-da3b8000d9a2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">모든 플랫폼의 토큰이 다른 곳에서 관리되고 있다면 하나의 소스를 바라보게 하면 되잖아요. 근데 그러기 위해서는 되게 많은 기반 작업이 필요했어요.</span></span></span></p><p id="2bca360d-33e3-8072-bbcd-fafe295766a1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 앞의 두 가지 문제들을 해결하기 위한 솔루션은 리소스가 꽤 많이 드는 작업들이었어요. 근데 리소스에 비해서, 사실 드러나는 임팩트는 좀 작아 보였어요. 엔드유저가 느끼는 것만 본다면, 거의 달라지는 게 없어 보이잖아요. 그래서 토큰의 문제를 해결하는 일은 계속 우선순위에서 밀리게 되었어요.</span></span></span></p><p id="2bca360d-33e3-80bd-be1c-fdb40c96d1e6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2bca360d-33e3-80ce-9b06-e2aa5002fc1c" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">비즈니스 확장이 만든 전환점</span></span></span></h3><p id="2bca360d-33e3-8083-87bd-d7f5557e252f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그런데 비즈니스가 성장하면서 TDS는 새로운 문제를 마주했어요.</span></span></span></p><p id="2bca360d-33e3-80b5-aaab-f85072c0ad13" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">간편 송금앱에서 금융앱이 되며 일관성과 효율성을 위해 디자인 시스템이 필요해졌던 것처럼, 이제는 새로운 도메인, 슈퍼앱, 글로벌 진출, POS기 같은 다양한 기기들을 지원해야 했어요. 새로운 화면과 패턴이 생겨나는 속도가 급격히 빨라졌고, 디자인 시스템의 컴포넌트를 제작하는 속도가 그 속도를 따라잡지 못하게 되었어요.</span></span></span></p><figure id="2c5a360d-33e3-80f3-ae44-ed3e27c8b73b" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/856ca848-0653-498c-9301-226530af7889/스크린샷_2025-12-12_오후_9.47.36.png" alt="" class="css-1pgssrp"/></figure><p id="2bca360d-33e3-8056-b694-dc6180df6ef5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그냥 컴포넌트를 더 열심히 찍어내면 될까요? 이건 너무 지속 가능하지 않은 선택이었어요.</span></span></span></p><p id="2bca360d-33e3-80a4-8ec5-c4b84c2aaef5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 저희는 확장 가능한 디자인 시스템을 만드는 게 필요하다고 판단했고, 확장 가능한 디자인 시스템을 토큰 시스템을 통해 만들어 보기로 했어요. </span><span class="css-q3ktjb">비즈니스 확장을 계기로 토큰 시스템을 처음부터 다시 만들게 되었고, 그 과정에서 앞서 언급했던 7년간 쌓인 문제들도 해결하며, 완성도 높은 토큰 시스템을 완성할 수 있었어요.</span></span></span></p><p id="2bca360d-33e3-803e-ac93-da13811d1c78" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이때 가장 많은 부채를 가지고 있으면서도, 직접적인 레이아웃 변화는 적은 컬러 시스템을 중점적으로 작업해보기로 했습니다.</span></span></span></p><p id="2bca360d-33e3-80fe-8178-d0530ac1527d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2bca360d-33e3-808e-8f6c-eda3decb4f43" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">OKLCH: 인지적으로 균일한 색공간</span></span></span></h3><p id="2bca360d-33e3-8023-a4d1-fae728edcf7d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가장 먼저, 명도 시스템을 구축했는데요, 이를 위해서 인지적으로 균일한 색공간의 개념을 활용했어요.</span></span></span></p><p id="2bca360d-33e3-8003-a3a3-fba61acced70" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">인지적으로 균일한 색공간은 OKLCH나 HSLuv 같은 색공간을 말하는데요. 지금까지 우리가 익숙했던 HSL 같은 색상 모델에서는 같은 명도를 가지더라도 색깔마다 인지되는 밝기가 달라요. 그런 차이를 보정한 것이에요.</span></span></span></p><figure id="2c5a360d-33e3-80a3-bb77-d7a125c7b2c3" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/55122ba1-90e4-4edb-80da-8e252b02906e/스크린샷_2025-12-12_오후_9.48.25.png" alt="" class="css-1pgssrp"/></figure><p id="2bca360d-33e3-8024-9020-fa47f06c2251" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">OKLCH를 기준으로 명도를 통일하면 훨씬 균일한 색대비를 가지게 돼요. 이전의 컬러 팔레트에서는 컬러마다 명도의 차이가 이렇게 컸는데, 이제는 균일한 명도를 가지도록 했어요.</span></span></span></p><figure id="2c5a360d-33e3-8013-a1ff-eec723f0fbce" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/e7fe3912-e523-4165-85c3-ee826d18debf/스크린샷_2025-12-12_오후_9.48.57.png" alt="" class="css-1pgssrp"/></figure><p id="2bca360d-33e3-80b5-bc56-d5b12cc01c1c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 명도 단계를 맞추니, 같은 스케일의 컬러를 쓰면 같은 명도로 보이도록 쉽게 맞출 수 있었고, UI에서 사용되는 주요 컬러 조합들이 접근성 기준을 충족할 수 있도록 보장할 수 있었어요.</span></span></span></p><figure id="2c5a360d-33e3-80cb-bff6-f3f4634618d7" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/235ccd6a-24f8-42c9-bdce-d28cdc48acd4/스크린샷_2025-12-12_오후_9.49.27.png" alt="" class="css-1pgssrp"/></figure><p id="2bca360d-33e3-8081-bd5d-d6938d097e7e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그리고 시스템에 정의된 컬러 토큰에서 더 나아가서, 아무 색이나 넣어도 TDS 기준에 맞는 명도의 컬러 조합을 추출해주는 자동화 로직도 만들 수 있었어요. 예를 들어 Fill/Weak의 배경과 텍스트 컬러 색조합, 에셋(리소스)의 색상과 어울리는 색들을 자동으로 만들어 줄 수 있어요. 앱인토스와 같이 다양한 브랜드를 지원하면서도 디자인 퀄리티를 유지해야 할 때 꼭 필요한 기능이었어요. 이 로직을 활용해, 미니앱에 입점한 여러 브랜드의 브랜드 컬러를 TDS 컴포넌트에 입혔을 때도 접근성 문제 없이 적절한 명도의 컬러를 보여줄 수 있도록 만들 수도 있었습니다.</span></span></span></p><figure id="2c6a360d-33e3-80af-992b-d06101785801" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/7f284580-e276-455c-9ee7-c2503e8acbea/스크린샷_2025-12-12_오후_9.50.02.png" alt="" class="css-1pgssrp"/></figure><p id="2c6a360d-33e3-80aa-8393-f8b6439a2194" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이때 많은 기기에서는 RGB를 사용하기 때문에, OKLCH의 색상을 그대로 표현하기 어려워요. Chroma(채도)를 clamp 하면 색조와 명도를 유지하면서도 비슷하게 보여줄 수 있어요.</span></span></span></p><p id="2bca360d-33e3-8032-aa08-cc7ceac6f0bb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2bca360d-33e3-8024-b630-ee08b6ce40fb" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">수치를 넘어 시각보정까지</span></span></span></h3><p id="2bca360d-33e3-8003-a2e7-c9d88e1f1c1d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그렇게 해서 수치적으로는 아름다운 컬러 팔레트를 만들었는데요, 아쉽게도 여기서 끝은 아니었습니다. 다음으로 지난한 시각보정의 과정을 거치며 심미적으로 아름다운 컬러를 만들어 나갔습니다.</span></span></span></p><p id="2bca360d-33e3-8013-ab5a-f3c42aafb64b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">특히 노란색에서 시각보정이 필요했어요. 아까 만들었던 수치적으로 일정한 팔레트에서 노란색을 보면, 밝은 컬러는 다른 컬러들에 비해 너무 진해 보이고, 어두운 색들은 너무 탁해서 노란색같이 보이지도 않았어요.</span></span></span></p><p id="2bca360d-33e3-8097-a2c3-ff4d8196be15" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">UI에 얹어봤을 때도 텍스트 컬러가 너무 탁해서 노란색이라는 느낌이 들지 않거나, 같은 명도인데도 노란 배경만 진해 보이는 문제가 있었어요. 이것이 바로 디자인 시스템에서 자주 언급되는 어두운 노란색 문제(The Dark Yellow Problem)예요.</span></span></span></p><figure id="2c6a360d-33e3-80c0-94e6-de0ac0f42a4b" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/2772e135-7d04-4876-9eb5-9ec816384988/스크린샷_2025-12-12_오후_9.51.00.png" alt="" class="css-1pgssrp"/></figure><p id="2bca360d-33e3-803f-8342-fe8ab8c96ef9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 수치적으로 일정한 팔레트에서 더 나아가서, 시각적으로 더 적절해 보이는 팔레트를 만드는 게 중요하다는 걸 알게 되었어요. 노란 텍스트는 노란색이 주는 심상을 전달하면서도 접근성을 충족하도록, 그리고 밝은 노랑은 다른 컬러들과 같은 밝기로 보이도록 보정했어요. 그렇게 해서 노란색만 조금 다른 명도 진행을 가지게 되었죠.</span></span></span></p><figure id="2c6a360d-33e3-8022-a20e-c41da0bc4ace" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/daa967cb-34f3-4e6a-8aa9-5bc43a12cd28/스크린샷_2025-12-12_오후_9.51.52.png" alt="" class="css-1pgssrp"/></figure><p id="2bca360d-33e3-804d-b1b0-e70f26a9dd02" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">다음으로는 다크모드를 위한 시각보정이 필요했어요. 인간의 눈에서는 늘 착시와 왜곡이 일어나요. 흰 배경에 요소가 올라갈 때와 어두운 배경에 요소가 올라갈 때, 같은 밝기 차이라도 후자의 시인성이 더 떨어지는 현상이 있었어요. 이건 APCA(Advanced Perceptual Contrast Algorithm) 같은 최신 명도대비 메트릭에서도 이야기하고 있는 내용이에요.</span></span></span></p><p id="2bca360d-33e3-80e7-837d-e96d6f74d744" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">화면 밝기를 낮춰서 봤을 때 더 도드라졌어요. 그래서 다크모드에서 적절한 명도를 찾아, 다크모드만의 명도 기준을 세우게 되었어요. 다크모드에서는 명도대비를 더 강하게 가지도록 설계했어요.</span></span></span></p><p id="2c6a360d-33e3-8007-9987-f88f74ea6b7a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2c6a360d-33e3-8024-aa66-e45073011a14" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">시맨틱 토큰으로 일관성 보장하기</span></span></span></h3><p id="2c6a360d-33e3-80b8-ad7a-cc24d7822734" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">시맨틱 컬러 토큰들도 정비했어요. 다양한 시맨틱 토큰들을 제공해 디자인 결정에 들어가는 시간을 단축하고, 동일한 의도라면 같은 색상을 보여줄 수 있어 일관성을 보장할 수 있게 됐죠.</span></span></span></p><aside id="2c7a360d-33e3-8095-a632-d3c59fb6a24a" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2c6a360d-33e3-8018-8ed5-c6b31cf3ffcd" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Target: 색상이 적용되는 대상 (e.g fill, text, border)</span></span></span></li><li id="2c6a360d-33e3-80be-b7ac-e218edd7ace8" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Role: 의미론적, 계층적 색상의 역할과 의미 (e.g brand, neutral, primary, secondary)</span></span></span></li><li id="2c6a360d-33e3-80ad-8f97-ec2f389a0275" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Variant: 변형 스타일 (e.g weak, alt)</span></span></span></li></ul></div></aside><p id="2bca360d-33e3-80a9-ad7e-c013f7484598" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2bca360d-33e3-80f6-bce5-d548bd66dbef" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">디자이너가 직접 제어하는 자동화 시스템</span></span></span></h3><p id="2bca360d-33e3-806d-9e44-c4bf267ab330" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">흩어진 토큰의 소스를 통합하는 것만으로는 충분하지 않았어요. 저희는 단순한 통합을 넘어 </span><span class="css-q3ktjb">디자이너가 쉽게 제어하고 실험할 수 있는 시스템</span><span class="css-1kxrhf3">을 구축하고자 했습니다. &#x27;쉽게 제어하고 실험 가능하다&#x27;는 것에서 바로 자동화를 떠올릴 수 있지요.</span></span></span></p><p id="2bca360d-33e3-8083-a82d-f7781821099c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">먼저 </span><span class="css-q3ktjb">“사람과 기계가 모두 읽을 수 있는 구조”</span><span class="css-1kxrhf3">로 규약을 정했어요.</span></span></span></p><aside id="2c7a360d-33e3-809d-b5bc-d79392a2784f" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2c6a360d-33e3-80b0-8711-e64956404041" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Category: Style Element의 상위 묶음 (e.g Color, Layout, Effect)</span></span></span></li><li id="2c6a360d-33e3-80a8-84e5-ed4439cdfe8b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Style Element: 각각의 스타일 요소 (e.g Color, Sizing, Spacing, Blur)</span></span></span></li><li id="2c6a360d-33e3-80fc-a7eb-cdac19c50f66" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Level: 토큰의 추상화 단계 (e,g Base, Semantic, Component)</span></span></span></li><li id="2c6a360d-33e3-80a8-a95e-e514576dadfb" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Name: 각 토큰의 이름(e.g blue-500, fill-brand, button-fill-primary)</span></span></span></li></ul></div></aside><p id="2c6a360d-33e3-8024-8f81-ce1028257d06" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c6a360d-33e3-80e3-8b4a-c136d33ed311" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그리고 디자이너는 Token Studio라는 Figma 플러그인을 통해 GitHub에 커밋하고 PR을 생성하면, 전처리된 토큰과 각 플랫폼별 코드가 자동으로 생성됩니다. 이를 통해 개발자에게 별도 요청을 하는 것보다 훨씬 빠르게 실험해볼 수 있어요.</span></span></span></p><figure id="2c6a360d-33e3-8011-8e58-ed7747eeb4f1" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/47e73e5e-9b47-4bd1-ae3f-1e85b3c0dcdf/스크린샷_2025-12-12_오후_9.52.28.png" alt="" class="css-1pgssrp"/></figure><p id="2bca360d-33e3-8067-be06-c299fe3c9e53" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">다만 디자이너가 직접 커밋하고 PR을 생성하는 과정에서 오류나 실수가 발생하기 쉬워요. 예를 들어 토큰의 참조 오류가 발생하는 경우도 있죠. 하지만 빌드 시점에 에러를 감지하고 알려주기 때문에 디자이너가 직접 수정한 후 리뷰를 요청할 수 있습니다. 오류가 없으면 코드가 자동 생성되므로 개발자는 리뷰하기 쉽고 빠르게 배포할 수 있어요.</span></span></span></p><figure id="2c6a360d-33e3-80a4-833d-dc1410048160" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/848f016f-3022-42a7-a4f1-2c4965c1066d/스크린샷_2025-12-12_오후_9.53.10.png" alt="" class="css-1pgssrp"/></figure><p id="2bca360d-33e3-800c-b9aa-dde5b18554be" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실제 생성 과정을 살펴보면, 먼저 전처리 단계에서 Token Studio에서 생성된 값을 Style Dictionary라는 변환 도구에 적합하도록 변환합니다. Token Studio 및 Figma 중심적으로 만들어진 원본 데이터를 그대로 사용하기에는 &quot;Blue 50&quot;과 같은 UI 표시 위주의 이름, 중첩된 구조, 서로 다른 포맷 등의 문제가 있었어요. 전처리 과정을 통해 완전히 일관된 값과 구조를 가지도록 정규화하여 변환을 용이하게 만들었습니다.</span></span></span></p><p id="2bca360d-33e3-8028-a1ed-f9dec3e26684" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">코드 생성 과정에서는 Style Dictionary를 통해 CSS, TypeScript, Deus Variable Collection Schema, Server Driven Format 등 다양한 형태로 변환돼요. 특히 Server Driven Format의 경우 앱에서 하위호환성을 지키면서도 새로운 버전을 지원하게 만들기 위해 디자이너, Android, iOS, 사일로 개발자등과 함께 스펙을 재정의해야 해서 어려웠어요.</span></span></span></p><p id="2c6a360d-33e3-803e-b612-c2be20b803ee" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">각종 커스텀 포맷과 복잡한 요구사항을 반영하려면 변환과정을 완전히 재정의하다시피 했어야 했어요. 플랫폼에 따른 빌드 타겟 필터링, 테마 및 모드 지원, 모드와 변형을 위한 토큰 참조 재구현, 토큰 타입 매핑, 복합 토큰 변환, 토큰 오버라이딩 지원, 각각의 파일 포매팅 등 많은 작업이 필요했어요.</span></span></span></p><p id="2c6a360d-33e3-80cb-87d0-f6bc4b550b3c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 덕분에 매우 간단하고 선언적인 코드로 다양한 옵션에 따라 생성해낼 수 있었어요.</span></span></span></p><p id="2c6a360d-33e3-802b-959e-c10527a518c5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2bca360d-33e3-80a6-9556-e60edf0f7be1" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">확장 가능한 디자인 시스템: 테마 시스템</span></span></span></h3><p id="2bca360d-33e3-8046-b3b0-ff6d97c30d1a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">비즈니스적으로 다양한 요구사항에 직면했다고 말씀드렸는데요. 그 결과 확장 가능한 디자인 시스템을 만들기로 결심했어요.</span></span></span></p><p id="2c6a360d-33e3-804a-bfe3-ecba6ae4e891" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">형태적으로 확장 가능한 디자인 시스템은 바로 </span><span class="css-q3ktjb">테마 시스템</span><span class="css-1kxrhf3">입니다.</span></span></span></p><p id="2bca360d-33e3-8014-8fb7-c9c661bc9549" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">테마란 특정한 “</span><span class="css-q3ktjb">규약</span><span class="css-1kxrhf3">“에 따라 스타일을 적용하거나 변경하는 것으로, 단순히 Light/Dark 컬러만 바뀌는 것이 아니에요. 브라우저 테마처럼 배경 이미지, 그라디언트 등 모두 규약으로 정의하기만 하면 변경할 수 있어요. 때문에 중요한 것은 어떻게 규약을 정하고 어떤 규약을 정하느냐에요. 앞서 시멘틱 토큰에서 규칙을 정했고, 토큰자체도 “사람과 기계가 모두 읽을 수 있는 구조”를 만들었던 것도 디자인 의사결정을 인코딩해 모두가 동일한 멘탈 모델을 가지기 위해서였어요.</span></span></span></p><p id="2bca360d-33e3-8049-b349-f087100f1b0f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">테마 시스템을 활용하면 커스터마이징을 하면서도 품질과 일관성을 유지할 수 있고, 컴포넌트의 중복 구현을 방지할 수 있어요. 대표적인 예로 앱인토스의 Brand 컬러 토큰 오버라이드와 TDS POS의 Sizing/Spacing 토큰 오버라이드를 들 수 있어요.</span></span></span></p><figure id="2c6a360d-33e3-80c1-870a-e926448604b8" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/474d1c8d-f08b-4bf2-803b-bd01aff608fd/스크린샷_2025-12-12_오후_9.53.56.png" alt="" class="css-1pgssrp"/></figure><p id="2bca360d-33e3-806f-b0a4-c5bb7817ffd8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">즉, 테마 시스템은 커스터마이징의 시스템화를 의미하며, </span><span class="css-q3ktjb">동일한</span><span class="css-1kxrhf3"> 기능을 하면서 </span><span class="css-q3ktjb">다양한 </span><span class="css-1kxrhf3">형태를 지원하게 돼요.</span></span></span></p><p id="2bca360d-33e3-80b4-beab-de7d8909cb46" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그런데 </span><span class="css-120saye">다른</span><span class="css-1kxrhf3"> 기능이 필요하다면 어떨까요? 예를 들어 TDS Desktop은 B2B용 어드민 화면을 만드는 데 주로 사용되는 반면, TDS WTS는 B2C용이며 트레이딩 화면을 만들 때 사용되기 때문에 서로 다른 기능이 필요해요. 루이스 설리번이 말했듯 형태는 기능에 따르므로(Form follows function) 다른 기능을 하면 다양한 형태가 필요해요. 그래서 다른 기능을 할때도 커스텀을 지원하기 위한 System of System으로서 파생 가능한 테마 시스템을 만들었어요.</span></span></span></p><p id="2bca360d-33e3-805a-b15b-ccbc6e4daf57" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">파생 가능한 테마 시스템은 파운데이션 요소들을 공유하면서 전용 시맨틱, 컴포넌트 토큰들을 오버라이드하여 사용할 수 있어요. 이를 통해 다른 기능을 구현하면서도 최소한의 형태적 일관성은 보장하게 됩니다. 전용 시맨틱 토큰을 사용하는 대표적인 예시로, 일반적인 화면에서는 파란색이 긍정적이고 Primary 컬러로 사용되지만 TDS WTS에서는 빨간색이 긍정적인 의미이며 Primary 컬러로 사용되는 경우가 있죠.</span></span></span></p><p id="2c6a360d-33e3-807d-8dc7-d639165e474c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">앞서 만들어놓은 토큰 코드젠 패키지를 통해 각자만의 토큰을 확장해 사용할 수 있어요.</span></span></span></p><p id="2bca360d-33e3-80c6-ba4b-fa61fcec10a9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2bca360d-33e3-8067-aadd-c975899d8dee" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">달리는 기차의 바퀴를 칠하다</span></span></span></h2><p id="2bca360d-33e3-8085-95e1-d9fde22132da" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그런데 디자인 시스템은 만드는 것도 중요하지만 적용이 그 이상으로 중요해요. 저희는 거대한 레거시 시스템이라는 달리는 기차의 바퀴를 칠해야 했습니다. 디자인 토큰은 토스의 모든 곳에서 다양한 형태로 사용되기 때문에 마이그레이션을 위해 많은 리소스가 필요했어요.</span></span></span></p><p id="2bca360d-33e3-80a7-84af-d3ad4d519ac5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">커다란 마이그레이션을 진행하기 위해 총 3가지 단계로 나누어 진행하기로 계획했어요.</span></span></span></p><h3 id="2bca360d-33e3-8002-968f-f9f9e83f095a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1. 내부 프로세스 통합</span></span></span></h3><p id="2bca360d-33e3-806f-9148-d8a4155da5a3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">먼저 2가지의 Token 패키지를 만들었어요. 흩어져 있는 토큰 관련 패키지를 통합해 값 변화 없이 구조만 변경된 Token v1과, Token v1과 동일한 구조지만 값이 변경된 Token v2입니다. 두 패키지가 동일한 구조를 가지도록 만들기 위해 Token v1의 레거시 토큰들을 Token v2에서도 사용 가능하게 하고, Token v2에서 추가된 토큰들을 Token v1에서도 사용 가능하게 했어요.</span></span></span></p><p id="2bca360d-33e3-8057-b7c3-cce6809ccee9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이후 TDS의 새로운 메이저 버전인 TDS v3에서는 서비스와 동일한 의존성을 사용하도록 토큰 패키지를 peerDeps로 설정했습니다. 레거시 버전의 TDS에도 적용해서 최대한 토큰의 적용 범위를 넓혔어요. 물론 마이그레이션을 수월하게 할 수 있도록 CLI도 제공했습니다.</span></span></span></p><p id="2c6a360d-33e3-8037-913f-f82dd3567992" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이와 비슷한 작업은 Web 뿐만아니라 React Native, Android, iOS, Server Driven UI 등에서도 모두 진행되어야 했어요.</span></span></span></p><h3 id="2bca360d-33e3-80dc-8a16-d2377a07c7da" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2. 서비스에 토큰 시스템 적용</span></span></span></h3><p id="2bca360d-33e3-804b-8d86-e831c90e6ee0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가장 먼저 고려할 것은 토스의 디자인 에디터인 Deus예요. Deus에는 스타일 격리를 위한 ShadowDOM을 적용하고, 이를 바탕으로 Variable Collection 시스템을 만들었어요. System/Light/Dark와 같이 컨텍스트도 전환할 수 있도록 했습니다.</span></span></span></p><p id="2c6a360d-33e3-80d9-8fd2-f36675c030ff" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">스타일 격리가 없던 구형 컴포넌트 마이그레이션, 컬렉션 등록과 사용을 위한 정의, 7년간 인터페이스 변경이 없던 덕분에 레거시 토큰 내부구현에 잔뜩 의존한 코드, 분기로 처리하기 까다로운 코드젠등 한발한발 내딛을 때마다 고난이 기다리고 있었어요.</span></span></span></p><p id="2bca360d-33e3-8033-963f-cc69f13387a1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">한편 토큰 패키지가 적용된 TDS는 Frontend Platform/Android/iOS의 모노레포 버전관리를 통해 일괄적으로 전파할 수 있었어요. Server Driven UI의 경우 앱버전의 분기에 따라 역매핑을 한 컬러를 내려주는 등의 작업이 필요했어요.</span></span></span></p><h3 id="2bca360d-33e3-8086-bc10-d538fc5a2ca2" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3. 함께 컬러 버전 높이기</span></span></span></h3><p id="2bca360d-33e3-80c3-8b9d-d7e28257cbac" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이제 컬러 버전을 높여야겠죠? Token v1과 Token v2의 컬러 구조는 동일했지만 동일한 키가 동일한 의미를 가지게 매핑되지는 않았습니다. 명도 시스템이 바뀌며 완전히 1:1 매핑이 되는 구조는 아니었거든요.</span></span></span></p><p id="2bca360d-33e3-8039-b486-dc5944cfb20b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">때문에 저희는 시맨틱 토큰과 컴포넌트을 활용해 동일한 의미를 가지는 구조를 만들고 각각의 컴포넌트에 적용하기로 했어요. 만들어진 시맨틱/컴포넌트 토큰에 따라 TDS v3에 점진적으로 적용하고, 준비가 되면 Token v2를 허용하는 방식으로 진행했습니다. 이때 TDS에서 의존하는 인터렉션 패키지부터, TDS를 의존하는 주요 라이브러리까지 모두를 챙겨야 했어요.</span></span></span></p><p id="2bca360d-33e3-80ce-b6dd-dc9bed31ad69" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실제 서비스에 적용할 때는 테스트로 몇가지 서비스에 적용해본뒤, 우선순위를 정해 중요한 화면부터 신규 컬러를 전파했어요. 이후 일반적인 화면들은 또 다시 모노레포 버전 관리를 통해 일괄 적용해요. 이는 다른 계열사에도 마찬가지로 적용할 수 있는 프로세스지요.</span></span></span></p><p id="2c7a360d-33e3-80aa-98ab-d94ff35caac5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c7a360d-33e3-805c-ab43-d947a30684a4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">글로는 간단하게 보이지만, 실제로는 Web, RN, Android, iOS, Server Driven과 같은 다양한 플랫폼, 의존하는 패키지들, 디자인 에디터, 다양한 계열사와 사일로까지 엄청나게 많은 것들을 고려해서 진행해야 했어요.</span></span></span></p><p id="2c7a360d-33e3-8099-8551-d91ad83a28a4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가끔은 기차가 아니라 비행기가 아닐까 싶을 정도였습니다.</span></span></span></p><p id="2bca360d-33e3-803a-a987-d426ec6f1dad" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2bca360d-33e3-80d4-8b60-dce32db5d26b" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">앞으로 더 나은 디자인 시스템을 향해</span></span></span></h3><p id="2bca360d-33e3-80bf-8088-dd8a439e65df" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">지금까지 컬러 시스템을 업데이트하며 4가지의 문제를 만나고 해결했어요.</span></span></span></p><aside id="2c7a360d-33e3-806b-a070-e7c41254843f" class="css-nv7vyi"><div class="css-1vn47db"><ol class="css-hokoge"><li id="2bca360d-33e3-802f-82a1-db360b2fbcdb" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">완성도 낮은 컬러 팔레트</span><span class="css-1kxrhf3"> → 수치와 시각적 우아함을 갖춘 컬러 팔레트로</span></span></span></li><li id="2bca360d-33e3-80b8-8616-c91f05ecbaea" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">분산되어 관리되는 토큰의 소스들</span><span class="css-1kxrhf3"> → 디자이너가 실험 가능한 시스템으로</span></span></span></li><li id="2bca360d-33e3-80af-aff2-eceb44f04ebe" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">빠르게 생겨나는 새로운 패턴들</span><span class="css-1kxrhf3"> → 파생 가능한 테마 시스템으로</span></span></span></li><li id="2bca360d-33e3-80d8-bb62-ca3f276b2b5f" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">복잡한 마이그레이션</span><span class="css-1kxrhf3"> → 점진적 업데이트 프로세스 구축으로</span></span></span></li></ol></div></aside><p id="2bca360d-33e3-80e9-867d-e135651c3702" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 저희는 아무리 복잡해 보여도 가로막는 문제가 된다면, 풀어요. 바닥부터 다시 쌓아올리게 되더라도요. 그래서 오늘의 선택이 내일의 한계가 되지 않도록, 100명을 위한 시스템에서 100만 명을 위한 시스템이 되었으면 합니다.</span></span></span></p><p id="2bca360d-33e3-8096-bf07-cece16eb1d5c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 여기서 끝이 아니라, 앞으로 더 개선해보고 싶은 과제들이 많아요.</span></span></span></p><p id="2bca360d-33e3-8088-be45-f6a001c408c3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2bca360d-33e3-8085-947d-ea72c7d04c55" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">탄탄한 기초공사
</span><span class="css-1kxrhf3">먼저 기초공사를 탄탄히 하고 싶습니다. 타이포그래피, 스페이싱, 상태 등 더 많은 파운데이션들이 정교한 규약하에 토큰화되고 Theme 시스템으로 사일로나 계열사에서 형태의 변화가 필요하다면 쉽게 형태를 커스텀하면서도 퀄리티가 지켜지도록 만들고 싶어요. 기능에 대해서도 커스텀이 가능하면서도 퀄리티가 지켜지도록 TDS Headless를 잘 가꾸고 싶어요.</span></span></span></p><p id="2bfa360d-33e3-8024-9a63-e37453db353a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2bca360d-33e3-8061-bf02-caf03b91b693" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">메트릭과 AI의 활용
</span><span class="css-1kxrhf3">이외에 관심 있는 분야는 디자인 시스템을 위한 메트릭 구축과 AI의 활용입니다. 디자인 시스템 메트릭은 디자인 시스템에서 데이터 기반의 의사결정을 도우며, 유지보수 및 리서치가 가능한 시스템을 기대하고 있어요.</span></span></span></p><p id="2bca360d-33e3-8044-90bb-f1c1f2505fb8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">AI를 사용하면 TDS의 맥락을 이해하면서 화면을 디자인하고, 만들어진 화면을 코드로 옮기고, 필요한 도메인 컴포넌트도 쉽게 만들 수 있도록 해 생산성을 올려보고 싶어요.</span></span></span></p><p id="2bca360d-33e3-8005-a323-cf2595616ce6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">TDS가 잘 만들어진 디자인 시스템이기는 하지만 아직도 할 것이 많고, 하고 싶은 것도 많은 것 같아요.</span></span></span></p><p id="2bca360d-33e3-8007-ab01-c22b1f5faefc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2bca360d-33e3-8032-bf7c-e52a77f0e869" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">디자인 시스템을 도입하고자 하는 분들께</span></span></span></h3><p id="2bca360d-33e3-806e-a26b-f64035776100" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">마지막으로, 디자인 시스템을 도입하고자 하는 현직자 분들께 드릴 수 있는 팁을 공유하려고 해요.</span></span></span></p><p id="2bca360d-33e3-80e5-a074-ea2c2cac8cba" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">디자인 시스템은 개발자 혼자서는 도입하기도 어렵고 유지하기도 어려워요. 결국 컴포넌트를 디자인하고 화면을 디자인하는 것은 디자이너이기 때문에, 좋은 제약을 가지면서 효율적이고 실제로 사용 가능한 디자인 시스템을 구축하려면 꼭 디자이너가 참여하고 시스템이 작동할 수 있도록 전파가 필요해요. 그렇지 않다면 수십 개의 커스텀이 생기고, 디자인 시스템이 달성하고자 하는 일관성과 효율성이 퇴색될 수 밖에 없습니다.</span></span></span></p><p id="2bca360d-33e3-804e-a1dc-ffcd42e6f593" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">만약 불가능한 상황이라면 오픈소스 Headless 컴포넌트들을 활용해 필수적으로 구현해야 하는 기능과 접근성이라도 챙겨볼 수 있을 듯 해요.</span></span></span></p><p id="2bca360d-33e3-8093-b6af-d42842bdb050" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">디자인 시스템을 만들고 유지보수하는 일이 쉬운 일은 아니겠지만, 팀의 규모가 크다면 도입을 고려해볼 만하다고 생각해요. 디자인 시스템에 관심 있는 모든 개발자들 화이팅입니다!! ✨</span></span></span></p><p id="2caa360d-33e3-8067-a7ac-ed56000ef6ad" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c7a360d-33e3-802c-add4-eb7465ca247a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1qimhyf">*이 글은 지난 10월 31일에 진행된 토스 UX Insight Club Vol.2의 발표 내용을 바탕으로 재구성 되었습니다.</span></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[레거시 정산 개편기: 신규 시스템 투입 여정부터 대규모 배치 운영 노하우까지]]></title>
            <link>https://toss.tech/article/payments-legacy-6</link>
            <guid>https://toss.tech/article/payments-legacy-6</guid>
            <pubDate>Thu, 11 Dec 2025 05:21:00 GMT</pubDate>
            <description><![CDATA[토스페이먼츠 정산 플랫폼팀의 레거시 개편 여정을 공유합니다.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2b3a360d-33e3-8059-bcc6-d3aaf7956038" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요, 토스페이먼츠 Server Developer 강민주, 박진현입니다.</span></span></span></p><p id="2aaa360d-33e3-80cf-b3a6-ea627c86ff0c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1odxvuk">&quot;정산 시스템을 왜 개편하나요?&quot;</span></span></span></p><p id="2aaa360d-33e3-80cf-86bd-c43d09c01fbb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠에서 정산 시스템을 운영하며 가장 많이 받았던 질문이에요. 하지만 20년이 넘은 레거시 시스템을 운영하다 보니, 저희가 반드시 극복해야 할 명확한 한계가 있었습니다. 지금부터 토스페이먼츠 정산 플랫폼팀이 20년 레거시 정산 시스템을 어떻게 개편했는지, 그 여정을 공유합니다.</span></span></span></p><p id="2b3a360d-33e3-80f9-8352-f2d753786515" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-8024-a3ba-ce3da8650ce1" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">정산이란 무엇인가?</span></span></span></h3><p id="2aaa360d-33e3-8060-95a0-fa1f85e998c9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">먼저 정산이 무엇인지부터 짚어볼게요. 정산은 쉽게 말해 </span><span class="css-q3ktjb">고객이 결제한 돈을 PG에서 상점에 정확히 전달하는 과정</span><span class="css-1kxrhf3">입니다. 하지만 이 과정이 생각보다 간단하지 않아요.</span></span></span></p><p id="2aaa360d-33e3-80d7-90a1-ca9e95ab4340" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">상점별로 계약 조건에 따라 수수료 계산 방식이 다르고, 돈을 지급하는 일자를 조정하는 등 매우 정밀한 작업들이 필요하기 때문이죠. 토스페이먼츠 PG 정산 시스템은 20년이라는 기간 동안 이런 정밀한 작업들을 수행해오고 있었습니다.</span></span></span></p><p id="2b2a360d-33e3-803d-824b-f34332c2379e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1qimhyf">참고: </span><a target="_blank" rel="noreferrer noopener" class="css-1uuzhek" href="https://docs.tosspayments.com/resources/glossary/settlement">https://docs.tosspayments.com/resources/glossary/settlement</a></span></span></p><p id="2b3a360d-33e3-803c-8b99-fead350755c5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-80c4-9af8-f582b9352ec7" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">왜 레거시 시스템을 개편해야 했나?</span></span></span></h3><p id="2aaa360d-33e3-809f-af59-d5bb5e1d5def" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">20년간 운영해온 시스템을 개편한다는 것은 쉬운 결정이 아니었습니다. 하지만 저희가 극복해야 할 명확한 한계가 세 가지 존재했어요.</span></span></span></p><h2 id="2aaa360d-33e3-8052-80f2-e3d8c0d6f358" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">1️⃣ 하나의 공통 쿼리에 종속된 비즈니스 로직</span></span></span></h2><h3 id="2aaa360d-33e3-8047-ad72-dfd7056d25d8" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문제 상황: 거대한 공통 쿼리의 늪</span></span></span></h3><p id="2aaa360d-33e3-8019-a50b-c8900d6331df" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">정산을 하기 위해서는 어떤 기능들이 필요할까요?</span></span></span></p><aside id="2b9a360d-33e3-8071-9f55-ec0853752e37" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2aaa360d-33e3-805f-871a-dd1e97009797" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">상점의 계약 정보 조회</span></span></span></li><li id="2aaa360d-33e3-8033-9f21-fcdcd4caf8fd" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">정산 대상이 되는 거래 조회</span></span></span></li><li id="2aaa360d-33e3-8003-af01-c5f909fd7fe6" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">해외 결제인 경우 특정 통화로 환전</span></span></span></li><li id="2b0a360d-33e3-8092-9af6-d7abda728e65" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기타 정산 유형 별 요구사항</span></span></span></li></ul></div></aside><p id="2aaa360d-33e3-80b6-984c-e999c9ff8572" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이처럼 거래 한 건을 정산하기 위해선 다양한 기능들이 조건에 따라 적용되어야 하는데요. 기존 시스템은 이 모든 것을 하나의 거대한 쿼리로 처리하고 있었습니다.</span></span></span></p><p id="2aaa360d-33e3-8016-ae3a-dcc6d0d29b90" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">수많은 도메인을 엮기 위해 여러 JOIN과 SUBQUERY, UNION ALL을 사용했고, 분기문을 처리하기 위해 중첩된 DECODE나 CASE WHEN 표현식을 사용하고 있었어요.</span></span></span></p><p id="2aaa360d-33e3-8018-8c49-d8d5d002a438" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 모든 것을 공통 쿼리로 처리하려다 보니, 작은 요구사항 하나를 반영하는 데도 어느 조건을 수정해야 하는지 명확하지 않았습니다. 또 변경에 대한 영향 범위가 상당히 크고, 테스트를 위한 비용도 높았기 때문에 전반적인 개발 유지보수 비용이 컸어요.</span></span></span></p><p id="2b0a360d-33e3-806c-b813-d69ebd821966" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-80d7-97af-cbd0de0c4837" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">접근 방법: 분할정복</span></span></span></h3><p id="2aaa360d-33e3-80a4-abef-d65d55eb254f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 이 거대한 쿼리를 분석하면서 </span><span class="css-q3ktjb">분할정복</span><span class="css-1kxrhf3">에 집중했습니다. JOIN, UNION ALL 등을 중심으로 엮여있는 각 연결고리를 분석하면서 카테고리를 나눴어요.</span></span></span></p><p id="2aaa360d-33e3-8020-b332-c84fafd6c750" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1단계: 도메인 분리</span></span></span></p><aside id="2bea360d-33e3-80dd-9e3c-e1795f27f9b3" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2aaa360d-33e3-80d3-a297-ed475a1a3877" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가맹점 정보</span></span></span></li><li id="2aaa360d-33e3-8092-93be-db321dc88ee0" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">거래 정보</span></span></span></li><li id="2aaa360d-33e3-805d-a5ce-c3766dd0452f" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">수수료 계산</span></span></span></li><li id="2aaa360d-33e3-8077-9c2f-c9f2d558e293" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">환율 정보</span></span></span></li><li id="2aaa360d-33e3-806f-9090-debb9fcbc587" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">...</span></span></span></li></ul></div></aside><p id="2aaa360d-33e3-80a3-bc66-e20a5b026c1b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2단계: 세부 기능 분리</span></span></span></p><p id="2aaa360d-33e3-80e3-932c-ca1dfec8244d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">분류된 카테고리에서 기능들을 더욱 세분화하여 문제를 작은 단위로 분할했습니다. 이렇게 문제를 작고 명확한 단위가 될 때까지 나누고 나니, 비로소 각 기능에 대한 분석과 코드 개선을 진행할 수 있는 단단한 기반이 마련되었습니다.</span></span></span></p><p id="2b0a360d-33e3-8027-ba8e-c856a2b870df" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-8014-8a0f-c9395711796e" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">분할정복의 추가 이점: 점진적 전환</span></span></span></h3><p id="2aaa360d-33e3-8004-95e1-cb49b3f99d00" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">분할정복 접근 방식은 시스템 개편에 또 다른 장점을 가져다 주었습니다. </span><span class="css-q3ktjb">시스템 전체가 개편되기 전이라도, 정복한 기능부터 점진적으로 새로운 시스템으로 전환할 수 있다는 것</span><span class="css-1kxrhf3">이죠.</span></span></span></p><p id="2aaa360d-33e3-8042-887c-ef6841491fed" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들어, 고시환율 환전과 체크카드 결제유형에 대한 새로운 요구사항이 추가됐다면, 해당 기능들의 개편 우선순위를 높여서 요구사항을 충족시키는 방안을 계획할 수 있었습니다. 덕분에 회사의 방향과 맞춰, 장기 프로젝트 중에서도 단계별로 실질적 가치를 제공할 수 있었어요.</span></span></span></p><p id="2b0a360d-33e3-802b-beaf-d9392d7d2871" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-8031-80e6-c12f49a1de05" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">개편된 코드: 비즈니스 규칙이 드러나다</span></span></span></h3><p id="2aaa360d-33e3-8054-80a1-f482c785e3e5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예전에는 DECODE나 CASE WHEN 문을 한참 해석해야만 비즈니스 규칙을 겨우 알 수 있었는데요. 이제는 코드가 비즈니스 규칙을 명확하게 드러내고, 역할에 맞는 객체로 분리되어 요구사항에 필요한 변경 지점과 영향받을 수 있는 지점을 훨씬 명확하게 관리할 수 있게 되었습니다.</span></span></span></p><p id="2bea360d-33e3-8086-a4f7-f01dd6252171" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-80f4-af97-e4113b521e9c" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">2️⃣ 데이터 모델링의 한계</span></span></span></h2><h3 id="2aaa360d-33e3-80c2-bfba-dbb531faaa51" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문제 상황: 집계된 데이터의 추적 불가능</span></span></span></h3><p id="2b0a360d-33e3-803e-92c5-c91378f0726f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기존 정산 시스템은 거래별 결과를 개별적으로 저장하지 않았어요. 대신, </span><span class="css-q3ktjb">특정 기준에 따라 거래 결과를 집계(Sum)한 상태로 저장</span><span class="css-1kxrhf3">하고 있었습니다.</span></span></span></p><figure id="2bfa360d-33e3-80d6-b364-d1d68f34dee3" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/75a7441d-3462-4805-a68a-5ff01c4fdba7/1208-img-inner-techblog-6.png" alt="" class="css-1pgssrp"/></figure><p id="2b0a360d-33e3-80de-8c46-c2e1e25e4001" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 구조는 과거의 집계 요구사항에 맞춰서 효율적이었지만, 문제 상황이 발생하면 큰 제약이 있었습니다.</span></span></span></p><p id="2bea360d-33e3-8096-a0be-c7d2d41a5b7b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들어 </span><span class="css-q3ktjb">거래 A, B, C 중 어떤 건에서 오류가 났는지 추적이 불가능</span><span class="css-1kxrhf3">했습니다. 또 이미 집계된 상태라, </span><span class="css-q3ktjb">다른 목적(예: 가맹점별·상품별 조회)에 데이터를 재활용</span><span class="css-1kxrhf3">하기도 어려웠어요.</span></span></span></p><p id="2b0a360d-33e3-8074-9154-ea9795f51ff8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결국 ‘편의성’을 위해 희생한 ‘추적 가능성’이 기술적 부채가 되어버렸던 셈입니다.</span></span></span></p><p id="2b0a360d-33e3-8062-a886-c494925c75e4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-8082-bb8a-f95be0209665" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">개선</span><span class="css-1kxrhf3"> 1 : 최소 단위 데이터 관리</span></span></span></h3><p id="2aaa360d-33e3-8047-b7d1-f81ecb3da8f0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 해결하기 위해, </span><span class="css-q3ktjb">정산 데이터를 거래 단위로 명확하게 관리하는 구조</span><span class="css-1kxrhf3">로 전면 개편했어요. 즉, 모든 거래가 1:1로 처리되고 저장되는 형태입니다.</span></span></span></p><figure id="2bfa360d-33e3-80ca-a953-c59d4f65e7ec" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/0471b7a8-ba78-418a-a4c1-d50141c41862/1208-img-inner-techblog-1.png" alt="" class="css-1pgssrp"/></figure><p id="2b0a360d-33e3-802b-a480-f66b5ed96da7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 데이터의 최소 단위를 확보하자 문제 발생 시 </span><span class="css-q3ktjb">원인 추적이 용이</span><span class="css-1kxrhf3">해졌습니다. 그리고 최소 단위 데이터를 조합해, </span><span class="css-q3ktjb">다양한 관점(조회·리포트·분석)에 맞는 결과를 유연하게 제공</span><span class="css-1kxrhf3">할 수 있게 되었습니다.</span></span></span></p><p id="2b0a360d-33e3-80a4-944c-d14440a7bfab" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-8070-8664-cb5dbd69295c" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">개선 2: 설정 정보 스냅샷</span></span></span></h3><p id="2b0a360d-33e3-80be-88b3-c55401d01e04" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">거래 단위로 데이터를 관리하게 되었지만, 여전히 한 가지 문제가 남았는데요. 바로 </span><span class="css-q3ktjb">결과값이 ‘어떤 설정값’에 의해 계산되었는지를 증명할 수 없었다는 점</span><span class="css-1kxrhf3">입니다.</span></span></span></p><p id="2b0a360d-33e3-80b4-9b01-f666dc67cec7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가맹점의 계약 조건(수수료율, VAT 포함 여부 등)은 언제든 변경될 수 있어요. 단순히 결과 금액만 저장한다면, </span><span class="css-q3ktjb">당시의 계약 조건을 재현할 수 없게 됩니다. </span><span class="css-1kxrhf3">이 문제를 해결하기 위해, </span><span class="css-q3ktjb">모든 계산 결과에 대해 당시의 설정 정보를 스냅샷으로 함께 저장</span><span class="css-1kxrhf3">하는 방식을 도입했습니다.</span></span></span></p><figure id="2bfa360d-33e3-80e6-9f4c-e38301e25176" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/1451b4e9-11d9-4405-904e-8acd81012d3f/1208-img-inner-techblog-4.png" alt="" class="css-1pgssrp"/></figure><p id="2b0a360d-33e3-8014-8bc2-cb03c1473fa1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이제 각 거래 결과는 자신이 계산될 당시의 </span><span class="css-q3ktjb">정확한 계약 조건과 환경을 증명</span><span class="css-1kxrhf3">할 수 있습니다. 즉, 시간이 지나더라도 그 때의 맥락을 그대로 복원할 수 있게 된 것이죠.</span></span></span></p><p id="2b0a360d-33e3-808f-9604-e6192b3f082e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-8049-89ab-d7aca3ce5ed1" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">추가 개선 : 상태 기반 재처리</span></span></span></h3><p id="2b0a360d-33e3-80a2-9cc6-e63dd30269a4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기존 시스템에서는 </span><span class="css-q3ktjb">수천만 건의 거래를 하나의 트랜잭션으로 처리</span><span class="css-1kxrhf3">하고, 모든 결과가 문제없이 계산된 후에야 한 번에 커밋되었는데요. 새로운 시스템은 이러한 비효율을 제거하기 위해 거래별로 상태를 독립적으로 기록하도록 설계했습니다.</span></span></span></p><figure id="2bfa360d-33e3-8083-8636-d164e89d799b" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/5e0e1cd3-ee08-485d-b225-f389a30beff0/1208-img-inner-techblog-5_(1).png" alt="" class="css-1pgssrp"/></figure><p id="2b0a360d-33e3-80bb-935f-d031ec8c09a6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이제 각 거래의 상태를 기반으로 </span><span class="css-q3ktjb">실패 건만 선별적으로 재처리</span><span class="css-1kxrhf3">할 수 있습니다. 그 결과, 장애 복구에 걸리는 시간을 크게 줄일 수 있었습니다.</span></span></span></p><p id="2b0a360d-33e3-8032-b4de-d4bf16d6c4db" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-80bc-a440-e8c6ec754275" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">3️⃣ 데이터 고해상도 문제</span></span></span></h2><p id="2b0a360d-33e3-80eb-be9c-ec6b58450ba7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">정산 데이터를 </span><span class="css-q3ktjb">최소 단위로 세밀하게 관리</span><span class="css-1kxrhf3">하게 되면서, 기존에 비해 저장되는 데이터의 양이 폭발적으로 증가했습니다. 이로 인해 </span><span class="css-q3ktjb">저장 효율과 조회 성능을 동시에 유지해야 하는 새로운 도전 과제</span><span class="css-1kxrhf3">가 등장했어요. 이를 해결하기 위해 저희는 </span><span class="css-q3ktjb">데이터베이스 구조 자체를 최적화</span><span class="css-1kxrhf3">하는 두 가지 접근을 적용했습니다.</span></span></span></p><p id="2b0a360d-33e3-80ca-b8d8-d9689452d315" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-80e5-8c2b-f64b7f74b259" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">개선 1: 파티셔닝과 인덱스 전략</span></span></span></h3><p id="2b0a360d-33e3-8072-a19b-cf86110734d0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">정산 업무의 대부분 조회는 </span><span class="css-q3ktjb">정산일자</span><span class="css-1kxrhf3">를 기준으로 수행됩니다. 따라서 물리적 데이터 분할과 효율적인 탐색이 가능한 구조를 설계했어요.</span></span></span></p><figure id="2bfa360d-33e3-80c0-960d-e53657359d6c" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/6f0cd4b6-7f90-4e30-bc5b-9076603fd3dc/1208-img-inner-techblog-3.png" alt="" class="css-1pgssrp"/></figure><ul class="css-uswsmm"><li id="2b0a360d-33e3-805e-aeb5-ddfe7b651006" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">날짜 기반 Range 파티셔닝</span><span class="css-1kxrhf3">으로 검색 범위를 최소화</span></span></span></li><li id="2b0a360d-33e3-804c-860c-f8389a521b4d" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">정산일자 선두 복합 인덱스</span><span class="css-1kxrhf3">로 탐색 경로를 단축</span></span></span></li></ul><p id="2b0a360d-33e3-8053-89b5-ea700523e235" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결과적으로, </span><span class="css-q3ktjb">거대한 테이블에서도 효율적인 조회 방식을</span><span class="css-1kxrhf3"> 확보할 수 있었습니다.</span></span></span></p><p id="2b0a360d-33e3-80e7-bad9-d7c9e8820354" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-803d-a8d7-cc2167c318e2" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">개선 2: 조회 전용 테이블 설계</span></span></span></h3><p id="2b0a360d-33e3-8041-890b-d425158ac5d7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">최소 단위 데이터를 그대로 유지하다 보니, 기존 시스템보다 </span><span class="css-q3ktjb">조회 시점의 실시간 집계 비용</span><span class="css-1kxrhf3">이 커지는 문제가 있었습니다. 즉, 동일한 조회 요청이라도 과거보다 </span><span class="css-q3ktjb">응답 속도가 느려지는 현상</span><span class="css-1kxrhf3">이 발생한 것이죠.</span></span></span></p><p id="2b0a360d-33e3-807f-92c7-e8114f82bb65" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 해결하기 위해, </span><span class="css-q3ktjb">조회 패턴에 맞춘 전용 테이블</span><span class="css-1kxrhf3">을 추가했습니다.</span></span></span></p><figure id="2bfa360d-33e3-800b-a416-c5c5a891ba75" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/d6bb5ae1-4db0-49a3-af77-508cb2480583/1208-img-inner-techblog-7.png" alt="" class="css-1pgssrp"/></figure><p id="2aaa360d-33e3-804c-bc69-d6a3145b42bf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 제품에 필요한 인덱스를 조회 전용 테이블에 추가함으로써, 배치의 쓰기 성능에 영향을 주지 않으면서 효율적인 조회가 가능하도록 1차적인 개선을 마쳤습니다.</span></span></span></p><p id="2c0a360d-33e3-8004-a54d-fac7ac5ab592" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c0a360d-33e3-806a-a88d-f58f9c39da00" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 운영 기간이 길어지면서 저희는 조회 성격이 두 가지로 나뉜다는 것을 느꼈어요. 서비스의 핵심 기능은 앞서 설계한 조회 전용 테이블을 통해 저희가 직접 관리하며 응답 속도를 보장했지만, 어드민 계열의 제품의 상황은 달랐습니다. 어드민에서는 훨씬 복잡하고 다양한 조건의 집계 요구사항이 빗발쳤는데, 그때마다 &#x27;조회 전용 테이블&#x27;을 매번 새로 만드는 것은 유지보수 측면에서 매우 비효율적이었기 때문입니다.</span></span></span></p><p id="2c0a360d-33e3-80b2-aa3d-e6b3a28bb22f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c0a360d-33e3-80ac-97ad-db09119ddec8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결국 저희는 </span><span class="css-q3ktjb">&quot;핵심 조회와, 복잡한 어드민 계열의 조회는 유연한 데이터 플랫폼으로&quot;</span><span class="css-1kxrhf3"> 역할을 나누기로 결정했어요.</span></span></span></p><p id="2c0a360d-33e3-8057-870f-c5163772fb79" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이에 따라 어드민의 다양한 조회 니즈는 데이터 팀이 구축한 고성능 데이터 서빙 플랫폼을 통해 해결할 수 있었는데요. 데이터 팀과 어떻게 시너지를 냈는지, 그 구체적인 아키텍처가 궁금하시다면 다음에 발행될 콘텐츠와 </span><a target="_blank" rel="noreferrer noopener" class="css-iynyr0" href="https://www.youtube.com/watch?v=ZiNrjCpgdSo">발표</a><span class="css-1kxrhf3">를 확인해 보시기 바랍니다.</span></span></span></p><p id="2c0a360d-33e3-80fd-845a-e2881fa04ca4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-80fc-b901-f49894f985bf" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">4️⃣ 배치 시스템 성능 문제</span></span></span></h2><h3 id="2aaa360d-33e3-80dc-8dc0-eb39183835b0" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문제 상황: 처리 시간의 폭발적 증가</span></span></span></h3><p id="2aaa360d-33e3-80f7-8843-c850e7af4d67" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기존 레거시 배치 시스템에는 치명적인 성능 이슈가 있었습니다. 거래 데이터가 실제 정산 데이터로 만들어지기까지 오랜 시간이 걸렸고, 거래가 조금만 늘어나도 처리 시간이 굉장히 빠르게 늘어나는 문제가 있었죠. 이대로 두면 회사가 목표로 하는 거래 규모까지 거래량이 늘어났을 때, 배치를 하루 종일 돌려도 처리가 끝나지 않는 상태가 벌어질 것이 예상되었어요.</span></span></span></p><p id="2aaa360d-33e3-80c5-858d-d64a2872e78c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">신규 시스템에서는 Spring Batch로 전환하여 배치 코드를 작성했지만, 프레임워크 자체가 문제를 해결해주지는 않았습니다. 여전히 두 가지 문제가 존재했기 때문이죠.</span></span></span></p><ul class="css-uswsmm"><li id="2aaa360d-33e3-80cd-b5f7-d42fcaa95490" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">대량의 I/O 발생</span></span></span></li><li id="2aaa360d-33e3-80d1-bddb-d6f7dc64bc20" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">단일 스레드 기반 처리의 한계</span></span></span></li></ul><p id="2b0a360d-33e3-80d9-8653-d5b7aaa41bc8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">대표적인 두 개의 문제에 대해서 어떻게 해소했는지 공유드리겠습니다.</span></span></span></p><p id="2bea360d-33e3-8065-9a47-eb964942380b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-8050-af6b-f1dea3189822" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">해결 방법 1: I/O 횟수 줄이기</span></span></span></h3><p id="2aaa360d-33e3-8086-97c6-fe1feadf0757" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">개선 1: 설정 정보 캐싱</span></span></span></p><p id="2b0a360d-33e3-803a-a888-ef2c0caa3640" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기존에는 거래 단위로 </span><span class="css-q3ktjb">가맹점의 설정 정보를 매번 DB에서 조회</span><span class="css-1kxrhf3">했습니다. 하지만 배치 실행 시점에는 이미 </span><span class="css-q3ktjb">적용해야할 설정 정보가 확정된 상태</span><span class="css-1kxrhf3">였어요. 따라서 배치 시작 시점에 </span><span class="css-q3ktjb">모든 설정 정보를 한 번에 캐싱</span><span class="css-1kxrhf3">하도록 개선했습니다.</span></span></span></p><p id="2b0a360d-33e3-80ab-b5b2-ddc064ae0b27" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결과적으로 반복적인 DB 조회가 제거돼, 배치 처리 중 I/O 횟수를 줄일 수 있었어요.</span></span></span></p><p id="2b0a360d-33e3-80df-b2e8-cbed20b6be92" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2aaa360d-33e3-80e8-a8ec-ce289565dd0c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">개선 2: ItemProcessor에서 Bulk 조회</span></span></span></p><p id="2b1a360d-33e3-807c-acb8-f25ad78bf9c5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Spring Batch의 기본 구조는 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">ItemReader → ItemProcessor → ItemWriter</span></code><span class="css-1kxrhf3"> 순서로, </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">ItemProcessor</span></code><span class="css-1kxrhf3">가 개별 건마다 실행되는 형태입니다. 이때 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">ItemProcessor</span></code><span class="css-1kxrhf3"> 내부에서 I/O 발생시키는 로직이 존재한다면, 거래 100만 건 처리 시 </span><span class="css-q3ktjb">100만 번의 I/O</span><span class="css-1kxrhf3">가 추가 발생해요.</span></span></span></p><p id="2bea360d-33e3-807a-887a-c74244c29477" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 해결하기 위해 </span><span class="css-q3ktjb">처리 단위를 묶는 Wrapper 구조</span><span class="css-1kxrhf3">를 도입했습니다.</span></span></span></p><p id="2b1a360d-33e3-80a1-91fb-edc591fcceb9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-8035-8087-ea3340925548" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Before) </span><span class="css-1kxrhf3">건별 조회</span></span></span></p><p id="2b1a360d-33e3-800e-bc37-fa7178c5f979" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-8042-8584-c314d20ca84a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">After) </span><span class="css-1kxrhf3">Bulk 조회</span></span></span></p><p id="2b1a360d-33e3-8038-8bd9-da7651bcffb4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결과적으로 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">ItemProcessor</span></code><span class="css-1kxrhf3"> 내부에서의 I/O 횟수는 데이터 개수(N)가 아니라 청크 반복 횟수(N / Chunk Size)만큼 획기적으로 줄어들었어요.</span></span></span></p><p id="2b1a360d-33e3-8073-97e4-f75e094d186b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2aaa360d-33e3-8067-9ddf-f6888ed03dd9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">개선 3: JDBC Batch Insert</span></span></span></p><p id="2aaa360d-33e3-8011-9946-ffa0dd174e89" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기존 시스템은 결과 데이터 한 건당 하나의 INSERT 쿼리를 수행하고 있었는데요. 신규 시스템에서는 JDBC의 Batch Insert 방식을 도입해서 여러 건의 데이터를 하나의 쿼리로 묶어서 처리했습니다.</span></span></span></p><h3 id="2aaa360d-33e3-8029-b724-c38cef698fd7" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">해결 방법 2: 병렬 처리</span></span></span></h3><p id="2b1a360d-33e3-80b5-92cb-feab4286155f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">I/O 최적화를 통해 개별 트랜잭션의 처리 속도를 높였지만, 단일 스레드로는 물리적인 시간의 한계가 명확했습니다. 이 부분에 대한 개선책을 알려드릴게요.</span></span></span></p><p id="2b1a360d-33e3-803f-b2f9-ec4741457525" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2aaa360d-33e3-80eb-a549-e6d053d0f5ca" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">개선 1: 외부 API 병렬 호출</span></span></span></p><p id="2aaa360d-33e3-807e-944b-f8104c23210d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">도메인을 구분하게 되면서 신규 시스템에서는 정보를 얻어오기 위해 별도의 API 통신이 필요한 경우가 생겼습니다. 그리고 이를 순차적으로 호출하다 보니, 네트워크 대기 시간(Latency)이 고스란히 누적되는 문제가 있었습니다. 저희는 직렬로 호출하던 것을 동시성을 통해 단축시켰어요.</span></span></span></p><p id="2b1a360d-33e3-8055-a0ca-cfc91b9a9397" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-801c-af86-ec100eff7410" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Before)</span></span></span></p><p id="2b1a360d-33e3-8042-b895-ccc86ce345a6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">After)</span></span></span></p><p id="2aaa360d-33e3-80a0-b2dd-eb59f48caf8b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">단건 처리 기준으로는 수십 밀리 초의 차이일 수 있지만, 배치 처리해야 할 데이터가 수백만 건이었기 때문에 전체 수행 시간을 단축시킬 수 있었습니다.</span></span></span></p><p id="2b1a360d-33e3-80e3-a8bd-e28ed63ac89e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2aaa360d-33e3-8042-b4c4-de9415534155" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">개선 2: Multi-threaded Step + 모듈러 연산</span></span></span></p><p id="2aaa360d-33e3-80ba-8c1c-cadf30492fc3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Spring Batch의 Multi-Threaded Step 기능을 적용했지만, 데이터를 읽어오는 로직이 Thread-safe하지 않아 문제가 있었습니다. 이미 처리된 거래를 다른 스레드가 다시 읽어와 &#x27;중복 정산&#x27;을 일으키거나, 특정 거래를 모든 스레드가 건너뛰어 &#x27;정산 누락&#x27;을 발생시키는 상황이 생길 수 있었기 때문인데요. 처음에는 동기화(Synchronization)를 적용했지만, 결국 데이터를 읽는 시점에는 병렬 처리의 이점이 없어졌습니다.</span></span></span></p><p id="2aaa360d-33e3-803e-92f0-c1870f5f3327" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 저희는 </span><span class="css-q3ktjb">모듈러 연산을 사용해 각 스레드가 처리할 데이터를 미리 명확하게 나누어 할당</span><span class="css-1kxrhf3">하는 방식으로 해결했습니다.</span></span></span></p><figure id="2bfa360d-33e3-80fd-b555-dc8e08b402a2" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/f4a596c1-d4e0-4581-a468-3518b49c38ec/1208-img-inner-techblog-2_(1).png" alt="" class="css-1pgssrp"/></figure><p id="2aaa360d-33e3-8043-9314-d1e66fa8ab8f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 방식을 통해 스레드 간의 경합을 차단했고, 멀티 스레드를 기반으로 성능 확보를 할 수 있었습니다.</span></span></span></p><p id="2b1a360d-33e3-803d-a695-d879307e357e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><p id="2c5a360d-33e3-80c1-adb2-c2077d107b1b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2aaa360d-33e3-8020-85a0-c01d0acfd8a6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">지금까지 20년 넘은 레거시 정산 시스템의 한계점과 개선 방법에 대해 전반적으로 소개해드렸습니다. 그런데 이렇게 개선한 시스템을 과연 라이브 환경에 바로 적용할 수 있었을까요?</span></span></span></p><p id="2aaa360d-33e3-8056-9bde-f6fc046c33e6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 그러지 못했습니다. 개선된 시스템이 기존과 동일한 동작을 보장한다는 증거가 있어야 하고, 시스템 전환의 영향도를 최소화할 수 있어야 했기 때문인데요. 지금부터는 </span><span class="css-q3ktjb">신규 시스템 개발 이후의 과정</span><span class="css-1kxrhf3">, 즉 검증과 투입 그리고 배치 운영에 대해 소개하겠습니다.</span></span></span></p><p id="2bea360d-33e3-801b-81c1-c471afd0d4b9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-80e0-9010-e638ecfd6f57" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">신규 시스템 검증: 수만 개의 테스트 케이스</span></span></span></h2><p id="2aaa360d-33e3-8072-a0d3-e4fa88ba9402" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">여러분은 여러분이 개발한 시스템을 어떻게 확신하시나요?</span></span></span></p><p id="2aaa360d-33e3-80a4-8ce2-dd58c4db0660" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">새로 개발한 시스템이 기존 시스템과 동일하게 작동하고, 생각하는 모든 케이스들을 정확히 처리하고 있다는 확신을 가질 수 있어야 실제 서비스에 적용할 수 있을 텐데요. 저희 시스템이 검증해야 하는 경우의 수는 얼마나 될까요?</span></span></span></p><aside id="2bea360d-33e3-807f-966d-e04e85fe3b3c" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2aaa360d-33e3-8019-99b0-f5ecd9e8a129" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">현재 지원하는 계산 유형: </span><span class="css-q3ktjb">수천 개</span></span></span></li><li id="2aaa360d-33e3-8009-841d-c4503502304a" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">각 계산 유형의 세부 설정: </span><span class="css-q3ktjb">수십 개</span></span></span></li><li id="2aaa360d-33e3-8067-bba2-eb9ef0d4009f" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결제수단, 할부 여부 등 거래 속성에 따른 변수</span></span></span></li></ul></div></aside><p id="2aaa360d-33e3-803c-b8ed-e2d91f1bdda6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게만 해도 </span><span class="css-q3ktjb">수만 개 이상의 조합</span><span class="css-1kxrhf3">이 나옵니다. 직접 손으로 검증하는 건 불가능에 가까웠죠.</span></span></span></p><p id="2bea360d-33e3-80c3-aa92-f79d6036f0a0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-80db-adb7-c39e79fc2263" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">테스트 자동화 플랫폼 활용</span></span></span></h3><p id="2aaa360d-33e3-80da-966c-ca8c431b6166" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 수만 개의 테스트 케이스를 검증하기 위해 </span><span class="css-q3ktjb">테스트 자동화 플랫폼</span><span class="css-1kxrhf3">을 적극 활용했습니다.</span><span class="css-1qimhyf">(이 플랫폼은 지난 SLASH24의 </span><a target="_blank" rel="noreferrer noopener" class="css-1uuzhek" href="https://www.youtube.com/watch?v=cGks5f2f0YE">정웅님의 발표</a><span class="css-1qimhyf">에서도 소개되었습니다.)</span><span class="css-1kxrhf3"> 테스트 자동화 플랫폼은 저희가 원하는 형태의 테스트 방식을 표준화하여 제공하고, 수만 개 이상의 테스트 케이스 관리가 용이합니다.</span></span></span></p><p id="2aaa360d-33e3-80ee-8e81-c2acde2e8fde" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 가능한 모든 케이스를 취합해 테스트 데이터를 구성하고, 해당 데이터를 입력값으로 하여 계산 결과를 바로 확인할 수 있는 별도 테스트용 계산 API를 구현했습니다. 이 계산 API는 </span><span class="css-q3ktjb">배치 모듈에서 사용하고 있는 코어 계산 모듈을 그대로 사용</span><span class="css-1kxrhf3">하고 있어, 실제 계산 배치에서 돌고 있는 로직과 동일한 계산 로직을 실행시킬 수 있어요.</span></span></span></p><p id="2aaa360d-33e3-8051-975f-c58778c997d8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 라이브 환경에 시스템을 적용하기 전 이 테스트 검증을 항상 진행함으로써 시스템 변경의 안정성을 높이고 있습니다.</span></span></span></p><p id="2bea360d-33e3-80f6-bf9a-f720b39c149d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2aaa360d-33e3-8087-8579-db0a2d632bf9" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">안전한 라이브 투입: 배치 카나리 시스템</span></span></span></h2><p id="2aaa360d-33e3-802f-b03d-f03f4594e2db" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">정산 로직을 검증했다면, 실제 투입은 어떻게 진행되었을까요? 저희가 신규 시스템 투입에 대해 고민했던 부분이 2가지가 있었습니다:</span></span></span></p><ul class="css-uswsmm"><li id="2aaa360d-33e3-8034-ab86-e356d31eaa8c" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">신규 시스템 투입 이후 이슈가 발생하더라도 빠른 시간 안에 복구가 가능해야 한다.</span></span></span></li><li id="2aaa360d-33e3-80d8-a949-c027eab7cd20" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문제가 발생하더라도 충분히 빠르게 대응할 수 있는 감당 가능한 규모여야 한다.</span></span></span></li></ul><h3 id="2aaa360d-33e3-80f3-8be5-c8c2718b80d3" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">원자적 투입 단위 정의</span></span></span></h3><p id="2aaa360d-33e3-807b-b604-c29a816afcbd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 시스템의 변화를 원자적으로 적용해야 하는 적정 단위를 정의했습니다.</span></span></span></p><aside id="2bea360d-33e3-8090-ac45-f2b965a97872" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2aaa360d-33e3-80d9-b641-c506c10acae1" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사업자번호 단위</span></span></span></li><li id="2aaa360d-33e3-800d-97c8-f6db0ec933ce" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가맹점 ID 단위</span></span></span></li><li id="2aaa360d-33e3-80a2-8e0b-f3693c380d6b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결제수단 단위</span></span></span></li><li id="2aaa360d-33e3-80c0-8e39-f1072786e1f5" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">...</span></span></span></li></ul></div></aside><p id="2aaa360d-33e3-803d-91df-d8e9bd3097b7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 생각한 투입 단위를 기반으로 대상 가맹점을 그룹화하였고, </span><span class="css-q3ktjb">특정 조건에 맞는 가맹점들을 대상으로 live 환경에서 검증 및 신규 시스템으로 투입될 수 있도록 하는 배치 레이어에서의 카나리 시스템</span><span class="css-1kxrhf3">을 구현했어요.</span></span></span></p><h3 id="2aaa360d-33e3-807e-b86a-e68d7fdbb5c3" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">배치 카나리 구조</span></span></span></h3><figure id="2bfa360d-33e3-8004-ba7a-f58e99c94073" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/2beb829a-3f3c-47bf-a0b3-b33cde53d486/1208-img-inner-techblog-8.png" alt="" class="css-1pgssrp"/></figure><aside id="2bea360d-33e3-80ee-9ed0-c2795b13db4c" class="css-nv7vyi"><div class="css-1vn47db"><ol class="css-hokoge"><li id="2aaa360d-33e3-8026-b696-f27be57f61dd" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">레거시 시스템 기반으로도 정산 건을 생성하고,</span></span></span></li><li id="2aaa360d-33e3-80ab-b3e2-c0f9c666239c" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">신규 시스템 기반으로도 정산 건을 생성합니다.</span></span></span></li><li id="2aaa360d-33e3-8045-b8f7-ec422c7901bd" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">두 시스템이 만든 데이터를 기반으로 </span><span class="css-q3ktjb">두 데이터가 동일한지 검증</span><span class="css-1kxrhf3">을 진행합니다.</span></span></span></li><li id="2aaa360d-33e3-80c1-a8cf-f03b331ba8a4" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">두 시스템에서 만든 거래가 동일하면</span><span class="css-1kxrhf3"> 신규 시스템으로 만들어진 데이터를 투입합니다.</span></span></span></li><li id="2aaa360d-33e3-8092-8495-c8c0dbba81b5" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">불일치하는 경우</span><span class="css-1kxrhf3">에는 레거시 시스템으로 만들어진 데이터를 투입하고, 불일치의 원인을 이후에 트래킹합니다.</span></span></span></li></ol></div></aside><h3 id="2aaa360d-33e3-80ec-83df-f505d6e014fd" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">세밀한 투입 단위</span></span></span></h3><p id="2aaa360d-33e3-801c-8f1f-ebbdf45571e1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 투입의 단위를 더 세분화했습니다:</span></span></span></p><aside id="2bea360d-33e3-80bd-9a55-c1de58b1484b" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2aaa360d-33e3-80ae-95bf-f2e86f29555f" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가맹점 단위</span></span></span></li><li id="2aaa360d-33e3-8088-a031-cb2a4fbc30ed" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결제수단 단위</span></span></span></li><li id="2aaa360d-33e3-8034-97e6-c5f3bfabbae1" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">더 나아가서는 </span><span class="css-q3ktjb">하나의 결제 건 단위</span><span class="css-1kxrhf3">로도 시스템 투입</span></span></span></li></ul></div></aside><p id="2aaa360d-33e3-8001-8735-ff431fb12cda" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가령, 하나의 가맹점 안에서도 특정 결제수단 건이 신규 시스템 기준으로 문제가 있을 때에는 해당 영역에 대해서만 레거시 시스템 기반으로 만들어진 데이터를 투입하도록 할 수 있어요. 그리고 지속적인 검증을 통해 </span><span class="css-q3ktjb">오랜 기간 불일치가 발생하지 않는 가맹점에 대해서는 온전히 신규 시스템으로 정산</span><span class="css-1kxrhf3">이 될 수 있도록 시스템을 구축했습니다.</span></span></span></p><p id="2c5a360d-33e3-80eb-af74-f526b2cf878a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><h2 id="2aaa360d-33e3-8040-8846-c9162fa8c4db" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">대규모 배치 운영 노하우</span></span></span></h2><p id="2aaa360d-33e3-8095-9100-f0da4e2284d0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">지금까지 다양한 케이스의 거래들을 빠르게 검증하고, 시스템의 안정성을 챙기면서 실제 라이브 환경까지 투입을 어떻게 진행했는지 말씀드렸는데요. 이제 마지막으로 </span><span class="css-q3ktjb">대량의 배치 시스템에 대한 관리 및 모니터링</span><span class="css-1kxrhf3">을 어떻게 발전시켜왔는지 설명드리겠습니다.</span></span></span></p><h3 id="2aaa360d-33e3-80a0-8f07-c5ab9cd971c7" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">현재 운영 중인 Jenkins Job의 개수: 1,500+</span></span></span></h3><p id="2aaa360d-33e3-80f2-9780-dbf7f24a4d19" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">현재 저희 정산 시스템으로 등록되어서 유지보수되고 있는 Jenkins Job의 개수는 1,716개입니다. 엄청나죠?</span></span></span></p><h3 id="2aaa360d-33e3-80bf-9acd-fe9e452134f5" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">레거시 배치 시스템의 문제점</span></span></span></h3><p id="2aaa360d-33e3-8034-91c5-c8ae6f134460" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">과거 정산 배치는 굉장히 많은 수의 배치가 </span><span class="css-q3ktjb">단일 인스턴스로 띄워져 있는 여러 개의 IDC 서버에 마구 흩어져</span><span class="css-1kxrhf3"> 있었습니다. 배치들은 관리가 어렵고 </span><span class="css-q3ktjb">장애에 취약한 상태</span><span class="css-1kxrhf3">였어요. 한 서버에 이슈가 생겨 배치가 실행되지 못하면 즉각 정상화하기 어려운 구조였죠.</span></span></span></p><p id="2aaa360d-33e3-8031-9a12-dfdf95220ec2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">해당 배치에 대한 실행 정보는 서버 내의 crontab으로 정의되어 있었는데, 이 선언되어 있는 리스트가 서버마다 다르게 되어 있어 제대로 관리되지 못하고 있었어요.</span></span></span></p><h3 id="2aaa360d-33e3-80bc-9267-ec439899095f" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1단계 개선: Kubernetes로 이전</span></span></span></h3><p id="2aaa360d-33e3-803c-b82d-f18d24b97c50" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문제 지점이 너무나도 많았지만, 처음에는 </span><span class="css-q3ktjb">하드웨어 장애에 취약한 환경에서 벗어나는 것</span><span class="css-1kxrhf3">을 최우선 목표로 두었습니다. 배치 실행이 단일 서버에 종속되지 않도록 </span><span class="css-q3ktjb">AWS 환경 내의 Kubernetes로 배치들을 옮겨와서 관리</span><span class="css-1kxrhf3">했어요.</span></span></span></p><p id="2aaa360d-33e3-803c-bf04-ecb43f3e9ef5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 Kubernetes로 배치 시스템을 운영하는 과정에서 여러 이슈가 있었는데요. </span><span class="css-q3ktjb">AWS와 데이터센터 간 물리적 거리</span><span class="css-1kxrhf3">로 인해 RTT가 길어지면서 쿼리 실행으로만 구성된 레거시 배치의 성능 저하 문제가 발생했습니다. 또 레거시 배치는 </span><span class="css-q3ktjb">정확히 한 번만 실행</span><span class="css-1kxrhf3">되어야 하는데, Kubernetes CronJob은 시스템 제약으로 정확히 한 번 실행을 보장할 수 없어 </span><span class="css-q3ktjb">배치 중복 실행</span><span class="css-1kxrhf3"> 문제가 생겼어요.</span></span></span></p><p id="2aaa360d-33e3-8074-8330-e1471f7a35c2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Kubernetes 환경에서는 배치가 안전하게 실행될 수 있는 환경을 보장받기가 어려웠죠.</span></span></span></p><p id="2c5a360d-33e3-806f-ae4b-f328b6f46140" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-8018-ac0e-e1e38c092fac" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2단계 개선: Jenkins 선택</span></span></span></h3><p id="2aaa360d-33e3-807b-9f3b-e984e915d013" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 배치 시스템을 운용하기 위한 더 안정적인 프레임워크를 고민했고, 그 결과 </span><span class="css-q3ktjb">Jenkins</span><span class="css-1kxrhf3">를 선택했습니다. Jenkins 선택의 이유를 말씀드릴게요.</span></span></span></p><p id="2aaa360d-33e3-80df-8791-f808433cc679" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">정산 배치는 자금 집행과 관련된 미션 크리티컬한 배치가 많아, 최대한 외부 영향 없이 안정적으로 시스템이 유지될 수 있도록 하는 것이 관건이었습니다.</span></span></span></p><aside id="2c5a360d-33e3-80bd-82e0-e7606e1b7ab8" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1. 정확히 한 번의 실행 보장</span></span></span></h4><div class="css-1vn47db"><p id="2aaa360d-33e3-8070-86f4-cbeb7b07ba50" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">정산 도메인은 굉장히 stateful한 도메인입니다. 계산은 한 번만 실행되어야 하고, 완료가 되면 그걸 바탕으로 지급 데이터를 만들어야 하죠. Jenkins가 다른 배치 관리 시스템들과 비교했을 때 이 부분에서 가장 잘 들어맞는 프레임워크였습니다.</span></span></span></p><p id="2aaa360d-33e3-805c-8b19-f43e0a8c840d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2. 워크플로우 정의</span></span></span></p><p id="2aaa360d-33e3-801c-9212-ecd7b3f412a1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">정산 도메인에서는 도메인 배치들 간에서 배치가 실행되는 선후행을 잘 명세할 수 있는 것이 중요했는데요. Jenkins가 가장 단순하게 </span><span class="css-q3ktjb">파이프라인 선언만으로 저희가 원하는 수준의 워크플로우</span><span class="css-1kxrhf3">를 정의할 수 있었습니다.</span></span></span></p><p id="2aaa360d-33e3-8017-b2c9-f7d58cb73394" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">3. 플러그인 생태계</span></span></span></p><p id="2aaa360d-33e3-80f8-bb91-f309b9ae46b9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Jenkins에서는 plugin 생태계를 기반으로 다양한 부가 기능을 제공하고 있는데, Jenkins에 저희가 원하는 기능을 충분히 구현할 수 있을 만큼 기능이 다양했습니다.</span></span></span></p></div></aside><p id="2c5a360d-33e3-8016-8a26-f43f8a004d08" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-8094-9799-ce224107fe99" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3단계 개선: Dynamic Provisioning</span></span></span></h3><p id="2c5a360d-33e3-80fd-b4f7-def3524b8d7b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안정성을 최우선으로 생각하고 Jenkins를 선택했지만, 최신 시스템 트렌드인 고가용성과 효율성을 놓치지 않기 위해 여러 기술 요소들을 많이 도입했습니다. 정산 시스템은 주요 배치들이 새벽과 같은 특정 시간에 몰려서 실행되는 경우가 많아 문제가 발생해요. Jenkins에 배치 실행 장비를 고정적으로 할당하다 보면 같은 시점에 실행되는 배치가 몰릴 때 배치 실행이 지연될 수 있어 유동적으로 감당하기 어렵고, 반대로 서버 장비를 과도하게 할당하면 특정 시간에는 서버 자원의 낭비가 발생합니다.</span></span></span></p><p id="2c5a360d-33e3-801d-bfd6-de19bd8ea4c5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 해결하기 위해 </span><span class="css-q3ktjb">Jenkins의 Dynamic Provisioning 기능</span><span class="css-1kxrhf3">을 구현했습니다. 배치 실행을 위한 노드 자원을 동적으로 관리할 수 있는 기능으로, 배치 실행 요청이 많을 때는 서버 자원을 동적으로 할당받아 배치를 실행하고 필요하지 않은 경우에는 서버 자원을 다시 회수함으로써 배치 실행에 대한 서버 비용 절감도 같이 챙겼어요.</span></span></span></p><h3 id="2c5a360d-33e3-80ee-a3c9-c565408abc68" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">
4단계 개선: Job DSL을 활용한 Job 선언 코드화</span></span></span></h3><p id="2c5a360d-33e3-804d-ae82-fa95a99c1b5e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">4단계 개선에서는 Job DSL을 활용한 Job 선언 코드화를 진행했습니다. Jenkins를 많이 사용하신 분들은 공감하실 텐데요. Jenkins에서 파이프라인 실행 노드를 잘못 설정해서 배치가 실패했다거나, Jenkins 노드 내의 환경변수를 일괄적으로 바꿔야 하는데 바꿔야 하는 job은 수십 개인데 일일이 들어가서 바꿔야 한다거나. 혹은 배치 개발을 했는데 파라미터 하나를 추가하려면 Jenkins UI에 들어가서 config 변경 버튼 눌러서 파라미터를 하나하나 수정해야 하는 등의 경험이 있으실 겁니다.</span></span></span></p><p id="2aaa360d-33e3-80bb-8962-d99ef9a8b839" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희도 마찬가지로 계속해서 신규 개발이 진행될 때마다 </span><span class="css-q3ktjb">Jenkins UI를 통해 배치를 선언하는 것에 많은 시간</span><span class="css-1kxrhf3">이 들었습니다. 또 Job 선언이 shell 스크립트로 제각각 선언되어 있다 보니, Job 내에 정의되어 있는 여러 기능이나 설정들을 빠르게 확인하고 일괄적으로 변경하는 것이 쉽지 않았어요.</span></span></span></p><h3 id="2aaa360d-33e3-800b-87f1-dfa8b4d2e641" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">해결 방법: Job DSL 기반 코드화</span></span></span></h3><p id="2aaa360d-33e3-8084-8252-ccae66f496ac" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 Job DSL 기반으로 job 선언 방식을 변경하면서 GitHub repository에 코드화되어 있는 설정 프로젝트를 켜서 </span><span class="css-q3ktjb">코딩을 하듯이 배치 job을 선언</span><span class="css-1kxrhf3">하고 </span><span class="css-q3ktjb">커밋만 하면 Jenkins에 새로운 job을 생성</span><span class="css-1kxrhf3">할 수 있게 되었습니다. 코드 리뷰도 할 수 있으니 배치 시스템의 스케줄링 안정성도 높아질 수 있죠. 또한 모든 배치 실행 환경의 JVM 버전, 노드 설정뿐만 아니라 모니터링 툴 설정같은 공통적인 설정도 </span><span class="css-q3ktjb">일괄적으로 코드를 통해서 바꿀 수 있습니다</span><span class="css-1kxrhf3">.</span></span></span></p><p id="2aaa360d-33e3-80a8-86d9-ea400efc1bed" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">배치 job 선언의 코드화는 여러 개발자들이 job을 선언하고 관리하는 비용을 획기적으로 줄이고, 각자의 도메인 application 개발에 더욱 집중할 수 있는 환경을 만들었습니다.</span></span></span></p><p id="2c5a360d-33e3-8083-be98-e0f6cd81af4f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-80f1-91c8-c769d5bc7a50" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">5단계 개선: 배치 모니터링 도구 강화</span></span></span></h3><p id="2aaa360d-33e3-800e-8904-c763ce7d2656" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">배치 시스템을 개발하면서 자주 마주치는 이슈 상황들이 있었습니다. 서버에서 OOM이 발생하거나 멀티스레딩 환경으로 배치를 구현하면서 thread block 문제에 맞닥뜨리기도 하고, reader / processor / writer 중 어느 한 부분의 지연으로 인해 전체적인 성능 지연이 발생하는 일들도 있었어요. 이런 문제가 발생할 때마다 이슈 지점의 정확한 분석이 필요했죠.</span></span></span></p><h3 id="2aaa360d-33e3-80a5-aca1-daa88f2e543e" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">도입한 모니터링 도구들</span></span></span></h3><p id="2aaa360d-33e3-8060-bc3e-c416723d5bb2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1. Thread Dump</span></span></span></p><p id="2aaa360d-33e3-80a8-ba55-dc0d3d429cda" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">쓰레드의 데드락이나 병목 지점을 확인하기 위해서 배치 실행마다 Thread Dump를 생성할 수 있도록 기능을 추가했습니다.</span></span></span></p><p id="2aaa360d-33e3-8071-b35d-e7d1241f9849" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2. Async Profiler</span></span></span></p><p id="2aaa360d-33e3-8062-9492-e7eaea0118ca" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">각 쓰레드가 어떤 형태로 CPU 리소스와 메모리를 사용하는지, 어떤 메서드에서 병목이 발생하고 있는지를 파악할 수 있도록 했습니다.</span></span></span></p><p id="2aaa360d-33e3-80a0-9c71-f6d6bc8b10cd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">3. Prometheus와 Pinpoint</span></span></span></p><p id="2aaa360d-33e3-8092-ad8c-d0ca8747efd1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">각 실행 배치별 JVM 메모리 사용률과 CPU 사용률을 탐지하고, 외부 시스템 간의 통신 지연 혹은 쿼리 지연을 탐지하고 있습니다.</span></span></span></p><p id="2aaa360d-33e3-807c-8e18-d78021428c06" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-80b2-bce9-d076798d7a18" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">마치며</span></span></span></h3><p id="2c5a360d-33e3-808f-a94a-fb825c1a461d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">지금까지 토스페이먼츠의 정산 시스템이 어떻게 발전되어 왔는지 말씀드렸습니다.</span></span></span></p><p id="2c5a360d-33e3-8055-9c5c-d20fb9670063" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희의 시스템은 하루에 수백만 케이스의 거래와 수천만 건의 데이터를 최대 10배 빠른 시간 안에 처리할 수 있는 시스템으로 개선되었어요. 이러한 성능적 개선과 더불어, 비즈니스의 요구사항을 유연하게 담을 수 있는 정산 시스템으로서 개편을 이뤄냈습니다.</span></span></span></p><p id="2aaa360d-33e3-8047-b279-c038c68a4c70" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 토스페이먼츠는 많은 기술적 변화를 이뤄왔는데요, 아직도 정산 시스템에는 더욱 발전시켜야 할 기술적 고민 포인트들이 많습니다. 많은 기술적 성장의 가능성이 열려 있는 토스페이먼츠에 많은 관심과 지원 부탁드립니다!</span></span></span></p><p id="2aaa360d-33e3-803f-91eb-f9cb244e04b0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2aaa360d-33e3-80d9-9d5e-d4d223608756" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">✅ 이번 아티클은 아래 Toss Makers Conference 25의 세션을 바탕으로 재구성되었습니다.</span></span></span></p><figure id="2aaa360d-33e3-805c-bff4-f88abac2d06b" class="css-of5acw"><div class="css-oni540"><iframe src="https://www.youtube.com/embed/Hb8QI5WyBJ4" frameBorder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" class="css-122y91a"></iframe></div></figure></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[업무 효율화, 작은 단계부터 다시 보기]]></title>
            <link>https://toss.tech/article/research_process</link>
            <guid>https://toss.tech/article/research_process</guid>
            <pubDate>Wed, 10 Dec 2025 03:32:00 GMT</pubDate>
            <description><![CDATA[꼭 필요하지만 리소스가 많이 드는 단순 반복 업무, 리서치 프로세스에서 어떻게 개선했는지 소개해 드릴게요.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2c5a360d-33e3-8064-9ea4-c2ec8047def8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스 팀원들이 사용자를 효율적으로 만날 수 있는 환경을 조성하는 리서치 플랫폼팀 서소희, 문은진입니다. </span></span></span></p><p id="2c5a360d-33e3-80e4-8f9c-ef2d760d7abe" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“지금 이 과정, 더 효율적으로 할 수 없을까?”라는 고민, 누구나 한 번쯤 해보셨을 거예요. 하지만 막상 효율화라고 하면 너무 거창하게 느껴지거나, 어디서부터 손대야 할지 막막해지는 경우도 많죠. </span></span></span></p><p id="2c5a360d-33e3-809f-82f8-f818392d1444" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">오늘은 저희가 리서치 과정을 효율화했던 방법을 소개해 드릴게요. 이 방법은 리서치 뿐 아니라 다양한 업무에서 효율화를 고민할 때 참고해 볼 수 있어요.</span></span></span></p><p id="2c5a360d-33e3-80eb-afb2-f7289f99da2b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스가 다양한 사업으로 빠르게 확장되면서 리서치 수요도 크게 늘었어요. B2B 고객이나 외국인 사용자처럼 더 다양한 유저를 섭외하면서도 기존과 같은 속도로 리서치를 진행할 수 있는 환경을 만드는 것이 중요했죠. 그래서 먼저 지금의 프로세스가 어떻게 흘러가는지 정확히 점검하는 일부터 시작했어요.</span></span></span></p><p id="2c5a360d-33e3-8056-b55f-c5a98da853c1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-80a6-b757-d0cc81049bb1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-8074-8005-e522678f4289" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2c5a360d-33e3-8026-a8e6-f18293212d8f" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1aa9h9v">1. 현황 파악 : 액션 별로 정리하기</span></span></span></h3><p id="2c5a360d-33e3-8083-ac43-dad261d483a9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">프로세스를 정리할 때 단순히 단계만 나열하면 문제를 정확히 파악하기 어려워요. 액션 별로 쪼개야 어디에서 어떤 문제가 생기는지 알 수 있어요. 누가, 어디에서(툴/채널), 무엇을, 왜 하고 있는지를 자세히 적어 봤어요.</span></span></span></p><p id="2c5a360d-33e3-80b4-b56b-c8ede0c0a1e9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">리서치가 확정된 뒤 인터뷰 일정을 진행자와 참관자에게 공유하는 과정을 예로 들어볼게요.</span></span></span></p><p id="2c5a360d-33e3-80c7-a70e-e47f812c35cd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2c5a360d-33e3-8055-8a7b-f68473339160" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Don’t - 겉핥기식 단계 정리</span></span></span></h3><p id="2c5a360d-33e3-80ef-946f-f5264b426802" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">전체 흐름은 보이지만, 정확하게 누가 무엇을 하는지 드러나지 않기 때문에 문제 파악이 힘들어요.</span></span></span></p><aside id="2c5a360d-33e3-80a2-b49f-fe63c64c2745" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">인터뷰 일정 공유 과정</span></span></span></h4><div class="css-1vn47db"><ol class="css-hokoge"><li id="2c5a360d-33e3-80b1-b2a7-c7bf518daf33" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">인터뷰 참여자 모집</span></span></span></li><li id="2c5a360d-33e3-8097-aa9b-e0b000cebd5e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">인터뷰 진행자, 참관자의 캘린더에 일정 생성</span></span></span></li><li id="2c5a360d-33e3-80e8-a29b-e08b1cb3de21" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">진행자, 참관자에게 메시지 보냄</span></span></span></li></ol></div></aside><p id="2c5a360d-33e3-80e0-9b80-c99bcba201d1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2c5a360d-33e3-8048-9f77-e4decb60eb7f" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Do - 하는 일을 모두 적기</span></span></span></h3><p id="2c5a360d-33e3-8018-8949-d3534e73b771" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">‘일정을 생성한다’는 단계는 실제로 이렇게 나눌 수 있어요. 이렇게 나누면 어떤 단계가 번거로운지 파악하는 게 훨씬 명확해져요.</span></span></span></p><aside id="2c5a360d-33e3-8012-812d-d1c7823cdddf" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2c5a360d-33e3-80fe-8a65-c4470d4cb6c6" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">날짜와 시간 선택</span></span></span></li><li id="2c5a360d-33e3-8033-bcdc-f8247bfa4e56" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">리서치 주제 입력</span></span></span></li><li id="2c5a360d-33e3-80cd-8333-de79dc1fe89d" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">참석자 추가</span></span></span></li><li id="2c5a360d-33e3-80ae-aed1-f6b8708e4dd4" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">회의실 설정</span></span></span></li><li id="2c5a360d-33e3-80a6-a1b5-c30a8b9f04f8" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">공개 범위 비공개로 전환</span></span></span></li><li id="2c5a360d-33e3-807a-baed-d94b6eb7d7f0" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">화상회의 주소 첨부</span></span></span></li><li id="2c5a360d-33e3-807a-a00f-ea0724ef32fd" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">진행가이드 및 질문지 템플릿 추가 </span></span></span></li></ul></div></aside><p id="2c5a360d-33e3-8054-8bf2-c4b6506dd8d5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2c5a360d-33e3-8007-a95e-dd14aba7f9ab" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">TIP 💡</span></span></span></h3><p id="2c5a360d-33e3-809d-ba59-c909bd500da6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">과정을 정리할 때는 일관된 기준을 적용하는 게 좋아요.</span></span></span></p><p id="2c5a360d-33e3-8027-a138-feeb98a2c8ab" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">시간, 담당자, 툴… 어떤 기준을 선택해도 돼요. 일관되게 유지하는 게 중요해요. 기준이 섞이면 예외 상황이 생기고, 읽는 사람도 정확히 이해하기 어려워져요.</span></span></span></p><p id="2c5a360d-33e3-80ec-9a07-f66c38c414cd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">예외 케이스도 함께 정리해보세요.</span></span></span></p><p id="2c5a360d-33e3-80d8-ab2a-f3b5ba6ee5d1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가끔 발생하는 일이어도 어떤 단계에서, 어떤 상황이 왜 생기는지 적어 두면 기존 프로세스의 부족한 부분을 파악하고 보완할 수 있어요.</span></span></span></p><p id="2c5a360d-33e3-8070-a7e1-c001d21d11ee" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-803c-a4ca-d1bc2df5c8d3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-805d-ad48-d45f9e9d0843" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-80f0-b171-f88829512b71" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2c5a360d-33e3-804e-9dd1-f117ba6b7ebd" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1aa9h9v">2. 문제 정의 : 질문 던지기</span></span></span></h3><p id="2c5a360d-33e3-80a6-b8ee-ca07d10038a9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">액션을 보며 한 단계씩 질문을 던져요. </span><span class="css-q3ktjb">“이건 왜 필요하지?” </span></span></span></p><p id="2c5a360d-33e3-80b9-bd18-ff3ba029428a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">필요하지 않은 일이라면 없애고, 꼭 필요한 일이라면 더 쉽게 할 수 있는 방법을 찾는 거예요.</span></span></span></p><p id="2c5a360d-33e3-80bc-a40b-d0545baa050a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들어, 앞서 살펴본 인터뷰 일정 공유 과정을 다시 보면:
</span></span></span></p><aside id="2c5a360d-33e3-8044-9135-df469eb3bb36" class="css-nv7vyi"><div class="css-1vn47db"><ol class="css-hokoge"><li id="2c5a360d-33e3-8038-a9c8-f224a0621e68" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">참여자 모집</span></span></span></li><li id="2c5a360d-33e3-80c4-8726-e597e665dd2b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">진행자·참관자 캘린더에 일정 생성</span></span></span></li><li id="2c5a360d-33e3-80d0-b23b-e1f78d67d60b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">진행자·참관자에게 메시지 전송</span></span></span></li></ol></div></aside><p id="2c5a360d-33e3-8016-be9b-cca5a050f131" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-8018-aa37-df44bd8f1029" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">여기서 2번(일정 생성)은 꼭 필요한 작업이에요. 하지만 사람이 매번 수기로 입력할 필요는 없죠. 그래서 자동화할 수 있는 방법을 찾았어요.</span></span></span></p><p id="2c5a360d-33e3-8079-b169-ccec3d35fed5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">반면 3번(메시지 전송)은 꼭 필요한 일인지 다시 생각해볼 필요가 있었어요. 팀원들이 캘린더를 자주 확인한다면 굳이 메시지까지 보낼 필요가 없을 수도 있으니까요.</span></span></span></p><p id="2c5a360d-33e3-80af-9db7-fb5f00e9a792" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사실 이런 일들은 크게 문제처럼 보이지 않을 수 있어요. 인터뷰 일정 공유은 몇 초 만에 끝나는 일이니까요. 하지만 이런 작은 액션도 여러 사람이 하루에 여러 번 반복하면 금방 큰 비효율로 이어져요. 반복되는 업무일수록 사소한 단계를 줄이는 것만으로도 팀 전체의 리소스를 크게 절약할 수 있어요.</span></span></span></p><p id="2c5a360d-33e3-8051-acf9-d90c1cdebecf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-8068-abae-fd781541e127" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-8012-a1a3-eec69bde227a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-80e6-a7ad-f1f750ef8f46" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2c5a360d-33e3-80ad-9aa5-c38b9432755a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1aa9h9v">3. 우선 순위 선정 : 나의 기준에서 벗어나기</span></span></span></h3><p id="2c5a360d-33e3-80bc-80a7-dd04420fd8f5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">우선순위를 정할 때는 먼저 기준을 정했어요. 저희는 다음 세 가지를 기준으로, 문제의 심각성과 해결했을 때의 임팩트를 함께 판단했어요.</span></span></span></p><ol class="css-hokoge"><li id="2c5a360d-33e3-809f-9ff7-e5d562992ed9" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">많은 사람들에게 영향을 미치는지</span></span></span></li><li id="2c5a360d-33e3-809d-b5b6-d6f020d75764" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">다른 업무에 영향을 주는지</span></span></span></li><li id="2c5a360d-33e3-80b8-87a3-c9693f27e514" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 업무를 할 때 얼마나 시간이 소요되는지 </span></span></span></li></ol><aside id="2c5a360d-33e3-80a5-9d35-cc80ed56fdfb" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문제: 일정 초대 과정에서 리소스가 쓰이고 휴먼에러 발생</span></span></span></h4><div class="css-1vn47db"><p id="2c5a360d-33e3-80dc-b02b-df14cc2f0289" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">해결 방법: 일정 초대를 자동화</span></span></span></p><p id="2c5a360d-33e3-80e5-bfb0-d5c784c3e7fc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">임팩트</span></span></span></p><ul class="css-uswsmm"><li id="2c5a360d-33e3-8038-bee6-e715d6b44839" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">매번 보내던 일정을 초대하지 않아도 돼, 시간 절약</span></span></span></li><li id="2c5a360d-33e3-809b-b0ab-f5f1769cf16b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">만약 잘못 보냈을 때 실수를 대처하는 시간과 리소스를 절약할 수 있음</span></span></span></li><li id="2c5a360d-33e3-8027-a605-d23c4871cfc2" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">해당 업무를 새로운 팀원에게 알려줘야 할 필요가 없어짐</span></span></span></li></ul></div></aside><p id="2c5a360d-33e3-8079-9a21-e0365d39c31a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">우선순위를 정할 때는 보통 시급도나 나의 리소스를 먼저 기준으로 삼는 경우가 많아요. 저도 처음엔 그랬어요. 일정을 초대하고 메시지를 보내는 일은 제 업무에 큰 영향을 주지 않으니, 우선순위가 아니라고 생각했죠.</span></span></span></p><p id="2c5a360d-33e3-8044-8724-c6ffb9a32ef1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 이 작업은 다른 이해관계자들에게는 중요한 업무였어요. 일정 초대 과정을 자동화하면 운영 담당자는 더블 체크에 쓰던 시간을 줄일 수 있고, 인터뷰 진행자·참관자도 불필요한 확인과 메시지 커뮤니케이션에서 벗어날 수 있죠.</span></span></span></p><p id="2c5a360d-33e3-8060-b812-ceb8f237ba1f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 경험을 통해, 우선순위는 ‘내 기준’이 아니라 이 일에 영향을 받는 사람들을 기준으로 정해야 한다는 것을 깨달았어요.</span></span></span></p><p id="2c5a360d-33e3-80e7-ad12-d59530c27ca8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-80a9-b2f5-dd94cef88cd0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-809c-b28f-e454e5d7227b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2c5a360d-33e3-80d7-b93d-d2480f95df08" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1aa9h9v">4. 해결책 적용하기 : 작게 시도해보기</span></span></span></h3><p id="2c5a360d-33e3-80ac-85d1-ccd03d2d77b3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">모든 문제를 한 번에 완벽하게 해결하는 방법을 찾기는 어려워요. 현실적으로 가능한 작은 부분부터 개선했어요. </span></span></span></p><p id="2c5a360d-33e3-8097-9610-fcacb24d5db7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">캘린더로 일정을 보내는 것은 자동화할 수 있었지만, 참석자까지 자동으로 추가할 수는 없었어요.  그래서 “전부 자동화해야 한다”는 생각을 내려놓고, 가능한 부분만 먼저 개선하는 방식으로 시작했어요. 액션 단위로 쪼개지 않았다면 도출할 수 없었던 해결책이죠.</span></span></span></p><p id="2c5a360d-33e3-8057-94a6-e018a21cf3c7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">새로운 방식을 적용하는 게 두렵다면, 테스트 기간을 가져보는 것도 방법이에요. 테스트 없이 바로 적용한다고 생각하면 머릿속에는 리스크만 떠오르기 쉽거든요.</span></span></span></p><p id="2c5a360d-33e3-80ea-ad5c-c289c75b107e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">일정 확정 후 팀원들에게 메시지를 보내지 않는다고 했을 때, 팀원들이 일정을 놓쳐 인터뷰에 입장하지 못할까봐 걱정됐어요. 이는 곧 인터뷰를 기다리는 사용자에게도 좋지 않은 경험이니까요.</span></span></span></p><p id="2c5a360d-33e3-8057-b330-d268279bd999" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 생각을 하면 당연히 새로운 시도가 어려워져요. 그래서 일부 케이스만 먼저 적용해보고, 예상하지 못한 문제가 없는지 확인한 후 관련 팀원들에게 피드백을 받는 방식으로 점진적으로 적용했어요.</span></span></span></p><p id="2c5a360d-33e3-802e-8bb2-c3da62574496" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">해결책을 처음부터 ‘완성된 형태’로 만들 필요는 없더라고요. 작게 테스트하고, 실제로 잘 작동하는지 확인하면서 조금씩 조정해 나가는 편이 훨씬 효과적이었죠.  완벽한 준비보다 작은 실험, 한 번의 결정보다 언제든지 원래 방법으로 돌아올 수 있다는 자신감이 중요해요.</span></span></span></p><p id="2c5a360d-33e3-8060-86e0-ccfe4939fcc3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3"> </span></span></span></p><p id="2c5a360d-33e3-8066-a2eb-da90d4bc8977" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-80fb-b327-d14156abd3fe" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2c5a360d-33e3-80d6-bfd8-e5d1ee70d9b7" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1aa9h9v">5. 결과 개선 내용</span></span></span></h3><p id="2c5a360d-33e3-8053-9c7d-c0261bbe15ee" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">일정 생성 자동화</span></span></span></p><aside id="2c5a360d-33e3-803c-aec2-eb9bb0d3c318" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Before</span></span></span></h4><div class="css-1vn47db"><p id="2c5a360d-33e3-8020-a686-ffa3169a29a4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">인터뷰 일정을 잡을 때마다 이 모든 걸 </span><span class="css-q3ktjb">매번 수기로 반복</span><span class="css-1kxrhf3">해야 했어요.</span></span></span></p><ul class="css-uswsmm"><li id="2c5a360d-33e3-8047-8bd5-c1e543294dd6" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">날짜·시간 설정</span></span></span></li><li id="2c5a360d-33e3-808f-a722-e4382cfd2518" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">주제 입력</span></span></span></li><li id="2c5a360d-33e3-8024-8f3f-c1756c2736e3" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">참석자 추가</span></span></span></li><li id="2c5a360d-33e3-8085-a88e-d35ba80e9f81" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">회의실/화상링크 설정</span></span></span></li><li id="2c5a360d-33e3-80c8-9940-e5945e26920a" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가이드·질문지 템플릿 첨부</span></span></span></li><li id="2c5a360d-33e3-801d-83c2-d13eeb2c59fe" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">잘못 입력된 정보가 없는지 여러 번 확인</span></span></span></li></ul></div></aside><p id="2c5a360d-33e3-8005-a286-d9b1fd957420" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><aside id="2c5a360d-33e3-80de-913c-d3263495ce09" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">After</span></span></span></h4><div class="css-1vn47db"><p id="2c5a360d-33e3-8063-b19e-d83039baf4d8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">리서치 시트에 날짜와 시간만 입력하면, 이 모든 과정이 자동으로 생성되도록 만들었어요. </span></span></span></p><ul class="css-uswsmm"><li id="2c5a360d-33e3-8000-a36d-f0b64f0ba394" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">캘린더 초대</span></span></span></li><li id="2c5a360d-33e3-80dc-b6d7-d987865bbe9b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가이드/질문지 템플릿 첨부</span></span></span></li><li id="2c5a360d-33e3-80c5-8fa0-d3397c9f6d7b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기본 설정 적용</span></span></span></li></ul><p id="2c5a360d-33e3-803d-8749-e5759a828c56" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">반복 입력·검수 작업이 사라지고, 휴먼에러와 확인 리소스가 크게 줄었어요.</span></span></span></p></div></aside><p id="2c5a360d-33e3-8075-b3bd-c56db2eab4d9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-807a-8f55-c00d31d8d9b5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 변화를 팀원들은 어떻게 느끼는지 여쭤봤어요.</span></span></span></p><p id="2c5a360d-33e3-80a8-b728-f41d731bbc0b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><aside id="2c5a360d-33e3-803c-bc07-c92a5a89b3d5" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">어시스턴트 A) </span></span></span></h4><div class="css-1vn47db"><p id="2c5a360d-33e3-80a1-bf34-c8bc604f34b2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">전에는 누락된 작업이 없는지 몇 번이고 확인해야 해서 퇴근 전에 10~20분씩 다시 검토하곤 했어요. 지금은 그 시간에 더 의미 있는 업무에 집중할 수 있게 됐어요.</span></span></span></p><p id="2c5a360d-33e3-8002-8924-fc1c0b59ac62" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">리서처 B) </span></span></span></p><p id="2c5a360d-33e3-80d9-abc0-c4d6f0f450f7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예전엔 일정이 바뀔 때마다 운영 담당자와 계속 확인하고 수정해야 했어요. 누락·오타가 생기기도 해서 다시 요청하느라 번거로웠고요. 이제는 모든 과정이 자동화돼서 ‘혹시 잘못됐을까?’라는 걱정을 하지 않아도 돼요.</span></span></span></p></div></aside><p id="2c5a360d-33e3-80f0-ab38-e0e35dbf9012" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-80a9-ad6c-eb405908ebb4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-80c3-adc9-f7f3c86ca875" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-8004-8228-d8666890ce28" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2c5a360d-33e3-8010-aeb3-c985316cb151" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2c5a360d-33e3-801f-973c-e3357ecb2c99" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-q3ktjb">적용해보기</span></span></span></h2><p id="2c5a360d-33e3-808b-8862-d2e9beefe36b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">처음에는 리서치 과정의 모든 단계를 자동화해야만 ‘효율화’라고 생각했어요. 예를 들면 조건에 맞는 참여자가 자동으로 필터링되고, 일정도 시스템이 알아서 조율하고, 사례비도 별도 요청 없이 자동 지급되는 식의 완전한 자동화요.그러다 보니 어디부터 손대야 할지 막막했고, 효율화라는 말 자체가 더 어렵게 느껴졌어요.</span></span></span></p><p id="2c5a360d-33e3-8005-b5da-cf8a7203aad1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그런데 작은 액션 하나를 자동화하면서, ‘효율화’를 더 이상 거창한 목표로 보지 않게 되었어요. 제가 보기엔 사소한 작업이었지만, 그 일을 반복하던 팀원에게는 체감되는 변화가 분명히 있었던 거죠.</span></span></span></p><p id="2c5a360d-33e3-804f-9f5a-fac6902e145e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">시스템을 새로 만들지 않아도, 자잘한 반복 작업을 줄이거나 불필요한 단계를 하나 덜어내는 것만으로도 충분히 효율화가 된다는 걸 알게 됐어요. 혹시 효율화가 막막하고 어렵게 느껴진다면, 지금 내가 하고 있는 일을 작은 단위로 쪼개고 질문을 던져보세요. 많은 힌트를 얻을 수 있을 거예요.</span></span></span></p><p id="2c5a360d-33e3-806c-b8c9-c659a348ff1a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2c5a360d-33e3-8040-a042-c1e92fae38e6" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ </span><span class="css-q3ktjb">액션은 작은 단위로 쪼개기</span></span></span></h3><p id="2c5a360d-33e3-80a3-9ca5-d2e781c7926e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">→ 흐름만 정리하기 보다, 개별 동작(클릭·입력·공유 등)으로 쪼개요. 그래야 어떤 과정이 비효율적인지 파악할 수 있어요.</span></span></span></p><p id="2c5a360d-33e3-80f8-a071-e5813334a5b1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2c5a360d-33e3-8057-9531-f9cce5b39da0" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣ </span><span class="css-q3ktjb">각 액션별로 “이건 왜 하고 있지?” 질문 던지기</span></span></span></h3><p id="2c5a360d-33e3-809d-9927-e6cdb6bb2ee5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">→ 목적이 불명확한 단계는 과감히 없애고, 꼭 필요한 단계는 더 편하게 할 수 있는 방법을 찾아봐요.</span></span></span></p><p id="2c5a360d-33e3-80ea-afcc-cd7c97e814f7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2c5a360d-33e3-8080-998d-eabf328a1a7c" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3️⃣ </span><span class="css-q3ktjb">명확한 기준을 세워 우선순위 정하기</span></span></span></h3><p id="2c5a360d-33e3-8043-9710-ec88461ddcd7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">→ 이해관계자가 많은지, 다른 업무에도 영향을 주는지, 그리고 이 일을 하는 데 시간이 얼마나 드는지를 기준으로 우선순위를 매겨보세요.</span></span></span></p><p id="2c5a360d-33e3-80df-9872-da0a74e08bbc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2c5a360d-33e3-80cb-b5c3-faae88e0fd7e" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">4️⃣ </span><span class="css-q3ktjb">할 수 있는 작은 부분부터 해결하고, 테스트 기간 갖기</span></span></span></h3><p id="2c5a360d-33e3-8040-8a5d-c4980eb65934" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">→ 한 번에 완전한 자동화를 목표로 하기보다, 최소 단위로 적용하고 이해관계자에게 피드백을 받아 점진적으로 확장하세요. 문제가 생기면 빠르게 원래 방법으로 돌아오면 돼요.</span></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[사업자 데이터 리터러시 높이기: BC Monthly Report 발행기]]></title>
            <link>https://toss.tech/article/business-customer-data</link>
            <guid>https://toss.tech/article/business-customer-data</guid>
            <pubDate>Tue, 09 Dec 2025 07:53:00 GMT</pubDate>
            <description><![CDATA[Business Data Team이 구축한 BC 데이터 마트와 전사적 지표 정의, 그리고 Monthly Report 발행 여정에 대해 공유합니다.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2b7a360d-33e3-80da-9ef8-f400e543fe41" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요, 토스 Business Data Team Leader(Data Analyst) 김윤아입니다. </span></span></span></p><p id="2b7a360d-33e3-8063-9b46-ef0783bced7f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스는 금융 혁신을 이끌어가는 과정에서 수많은 사용자(User) 데이터를 기반으로 의사결정을 해왔습니다. 하지만, 작년까지만 해도 우리에게 안정적인 매출을 가져다주는 또 하나의 핵심 고객인 사업자 고객(Business Customer, BC)에 대한 데이터적 이해는 높지 않았어요.</span></span></span></p><p id="2b7a360d-33e3-8023-b732-d5629b347679" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1odxvuk">&quot;이번 달, 우리에게 매출을 발생시킨 Business Customer는 몇 개인가요?&quot; </span></span></span></p><p id="2bca360d-33e3-80cd-a174-e954488babe3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 간단한 질문에 누구도 자신 있게 답할 수가 없었고, 이 문제를 해결하기 위해 24년 하반기에 Business Data Team이 생겨났습니다. 이 글에서는 Business Data Team이 구축한 BC 데이터 마트와 전사적 지표 정의, 그리고 Monthly Report 발행 여정에 대해 이야기해 보려고 해요.</span></span></span></p><figure id="2b7a360d-33e3-802d-a08e-e483ed8a32f6" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/f49879cf-74bb-4873-8dc9-a94c84197fe5/1205-img-inner-techblog-1.png" alt="" class="css-1pgssrp"/></figure><h2 id="2b7a360d-33e3-80d7-a944-f9ad930f458e" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">1️⃣ 혼돈을 넘어, 단 하나의 진실을 찾아서: 사업자 데이터 마트 구축</span></span></span></h2><h3 id="2b7a360d-33e3-80d3-8771-e14aff490439" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사업부에 갇힌 데이터를 하나의 언어로 통합하기</span></span></span></h3><p id="2b7a360d-33e3-8028-818d-e6198b44bae3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기존 토스 내에서는 사용자(User) 지표에 대한 기준은 명확했지만, 사업자 데이터는 각 사업부(쇼핑, 광고, 페이 등)별로 분산되어 관리되고 있었습니다. 이로 인해 사업자 관련 지표를 논할 때마다 &#x27;서로 다른 숫자를 이야기하는&#x27; 비효율성이 발생했어요.</span></span></span></p><p id="2b7a360d-33e3-80e4-ab23-e12b185320da" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 프로젝트의 첫 번째이자 가장 중요한 단계는 Business Customer(이하 BC) 관련 데이터를 통합하고 표준화하는 단일 진실의 근원(Single Source of Truth, SSOT) 데이터 마트를 구축하는 것이었습니다. </span><span class="css-1kxrhf3">각 사업부의 서비스 특성을 이해하고 지표의 기준을 전사적으로 통일하는 과정은 고도의 커뮤니케이션과 논리적 접근이 필요한 작업이었습니다.</span></span></span></p><aside id="2bca360d-33e3-805c-aa47-cbfaac62a63c" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2bba360d-33e3-80f5-aeb4-d18f5032ccc7" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">서비스 지식에 대한 이해가 필요했던 예시
</span><span class="css-1kxrhf3">: 광고 대행사의 경우, &#x27;실제 매출 발생 주체&#x27;를 광고 대행사로 볼 것인지, 아니면 &#x27;광고 집행을 요청한 광고주&#x27;로 볼 것인지를 정의하는 것부터 필요했어요. </span></span></span></li><li id="2bba360d-33e3-8072-b1da-cc87c2d751ab" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">복잡한 사업자 관계에서 트래킹 기준을 정해야 했던 예시
</span><span class="css-1kxrhf3">: 수백개의 결제 가맹점을 대표 사업자인 본사가 정산하는 케이스, 각 가맹점에서 따로 정산하는 케이스, 서비스에 따라서 두 가지가 혼재되는 케이스도 있었어요.</span></span></span></li><li id="2bba360d-33e3-802f-ad6e-e603ed00458a" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">필요한 데이터가 데이터베이스에 적재되어있지 않았던 예시
</span><span class="css-1kxrhf3">: 보험사의 경우 대행사를 통해 정산이 이루어지는 케이스가 빈번한데, 실제 어느 보험사의 예산으로 집행된 케이스인지 SAP(회계정산시스템)에 정보가 아예 없었기에 정보를 어떻게 잘 적재할 수 있는지에 대한 고민도 있었습니다. </span></span></span></li></ul></div></aside><p id="2b7a360d-33e3-80dc-90bc-e6def7832c02" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">각 사업부의 담당자들과 대화하고 매출과 비용 발생이 일어나는 과정을 하나씩 정리한 끝에 토스는 비로소 &#x27;토스에서 활동하는 Business Customer&#x27;에 대한 전사적인 정의를 할 수 있었습니다. </span></span></span></p><figure id="2b7a360d-33e3-80f8-b552-c36ac73aabed" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/658bd7dc-9f8f-4682-9168-c7bc4611d6f6/1205-img-inner-techblog-2.png" alt="" class="css-1pgssrp"/></figure><h2 id="2b7a360d-33e3-804f-a1d0-e1dfaf7791b2" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">2️⃣ 데이터에 생명을 불어넣다: Monthly BC Report 기획 및 설계</span></span></span></h2><h3 id="2b7a360d-33e3-806d-8553-eaf4231fd20f" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">전사적 공감대를 형성하는 방법</span></span></span></h3><p id="2b7a360d-33e3-809f-a203-d28582661448" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">SSOT 마트가 완성되었지만, 이 데이터가 잠재력을 발휘하기 위해서는 전사적으로 쉽게 접근하고 비즈니스에 활용될 수 있어야 했어요. 저희 팀은 가장 높은 전파력과 일관성을 가질 수 있는 방법으로 &#x27;월간 전사 리포트 (Monthly BC Report)&#x27; 발행을 선택했고 단순히 메트릭을 나열하는 것을 넘어, 비즈니스 현황에 대한 통찰(Insight)을 제공하는 것을 목표로 했습니다. </span></span></span></p><ul class="css-uswsmm"><li id="2b7a360d-33e3-8025-88f4-f98f7987fe8c" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">핵심 트렌드 분석</span><span class="css-1kxrhf3">
월간 매출 발생을 기준으로 BC를 사업부별로 시각화하고, 매출 규모별 특징(Tier)을 세분화하여 어느 매출 Tier에서의 BC 증감이 일어나는지 파악할 수 있도록 했어요. 더 나아가 New, Churn, Retained 사업자 트렌드를 한눈에 보여주어 월별로 어떤 유형의 사업자가 잘 유입되고 있는지 혹은 이탈하고 있는지 비교할 수 있도록 했어요. </span></span></span></li><li id="2b9a360d-33e3-8070-9253-f58d17dc5b8d" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">플랫폼 만족도 확인 </span><span class="css-1kxrhf3">
Cohort Retention 지표를 사업부별로 구성하였고, 많은 BC들이 속해있는 사업부는 주요 서비스별로 나누어 어떤 서비스의 BC가 플랫폼에 오래 잔존하고 있는지 볼 수 있도록 했습니다. </span></span></span></li><li id="2b7a360d-33e3-804c-941d-e403600b240e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Deep-Dive를 위한 Raw Data 제공</span><span class="css-1kxrhf3">
매출 규모가 큰 BC 중 매출 상승/하락이 두드러지거나 Churn이 발생한 상위 매출 사업자에 대해서는, 사업부와 BC 이름을 명시한 Raw Data 리스트를 정리하여 실무자가 즉시 액션 포인트(Action Point)를 찾을 수 있도록 구성했습니다.</span></span></span></li></ul><p id="2b9a360d-33e3-8044-972d-c448ed9348cf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-80e0-838f-d3329496a061" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">현업의 니즈를 담아내는 과정</span></span></span></h3><p id="2b7a360d-33e3-801c-9711-ec249acbb55d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">리포트의 완성도를 높이기 위해, 작성한 초안을 바탕으로 데이터를 가장 활발하게 사용할 현업 리더들과의 심층 인터뷰를 진행했어요. Platform Product Owner, Sales Team Leader, Domain Head 등 다양한 직무를 대상으로 인터뷰 했고, &quot;현재 리포트에서 가장 궁금한데 빠진 지표는 무엇인가요?&quot;, &quot;이 정보를 통해 어떤 의사결정을 내리고 싶으신가요?&quot; 등의 질문을 통해 현업의 숨겨진 니즈를 파악하고 지표에 반영했습니다.</span></span></span></p><p id="2b9a360d-33e3-8034-94a0-cee29e45319d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-80eb-93de-d029565105dd" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">데이터 파이프라인 만들기 </span></span></span></h3><p id="2b7a360d-33e3-80ac-bc96-c4c8b3c2eea0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">SSOT로 만들어진 BC 마트는 Airflow로 구축하고, 리포트에 필요한 소비 영역 배치는 Jenkins에서 돌아가도록 만들었어요. 마지막으로 태블로(Tableau)에서 Fact성 집계를 SQL로 불러오게 만들어서 Monthly로 리프레시하기만 하면 리포트에 활용되는 수많은 차트들이 업데이트 되도록 만들었습니다. </span></span></span></p><p id="2b9a360d-33e3-8021-8b0d-c2f405c5ca2f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-80e9-bb27-f4714edba672" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">집단 지성 검증</span></span></span></h3><p id="2b7a360d-33e3-8056-907d-ee03759c4ea6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">발행 직전, Business Data Team은 &#x27;누구나 한눈에 지표를 오해 없이 이해할 수 있는가&#x27;를 기준으로 최종 검증 회의를 진행했습니다. 주요 지표 정의, 분모/분자 명시, 데이터 단위 등 리포트의 명확성과 가독성을 극대화하는 세부 사항을 점검하여 최종 완성도를 확보했습니다.</span></span></span></p><figure id="2b7a360d-33e3-8023-b946-e4a7def641b5" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/4086c92d-46df-45e5-a256-8ce4e674acef/1205-img-inner-techblog-3.png" alt="" class="css-1pgssrp"/><figcaption class="css-wgpbp3"><span class="css-jfs1hr">리포트 예시(가상 데이터)</span></figcaption></figure><hr class="css-1ifza5r"/><h2 id="2b7a360d-33e3-807a-bd79-da08a6ba5cea" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">3️⃣ 리포트 발행 후, 데이터 활용의 물꼬를 트다</span></span></span></h2><h3 id="2b7a360d-33e3-8041-900f-f2d2cf3763e3" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">‘장님이 눈을 뜬 것 같다’는 현업의 피드백</span></span></span></h3><p id="2b7a360d-33e3-802b-a687-dec509d732a3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Monthly BC Report가 전사에 발행된 후, 몇가지 인상적인 피드백을 받았어요.</span></span></span></p><blockquote id="2b7a360d-33e3-8092-85ac-e773ed313b91" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">&quot;장님이 눈을 뜬 것 같다. 드디어 비즈니스 현황을 한눈에 볼 수 있는 대시보드가 생겨서 너무 좋다.&quot;</span></span></span></blockquote><p id="2b7a360d-33e3-80fe-92a9-f4cf52a52954" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">리포트 발행으로 BC 데이터를 활용해 뚜렷한 성과 지표를 볼 수 있게 되었다는 반응이었습니다. 더하여 지표를 확인하는데 그치지 않고 BC Report 발행은 전사적인 관심과 활용 논의의 물꼬를 트는 기폭제가 되었어요.</span></span></span></p><p id="2b7a360d-33e3-80fc-b554-d531844cefe5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">새로운 분석 요청도 많이 들어왔어요</span></span></span><span class="css-1vn47db"><ul class="css-uswsmm"><li id="2b7a360d-33e3-80f6-a6d5-c19be684f4d6" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Churn 가맹점 Raw Data를 Full List로 받았으면 좋겠다는 요청</span></span></span></li><li id="2b7a360d-33e3-8086-8ffb-fa91cfcd2a8f" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">매출 이전 단계인 &#x27;회원 가입(Registered)&#x27; 개념이 리포트에 추가되면 좋겠다는 의견</span></span></span></li><li id="2b7a360d-33e3-80bb-bb24-d9546555ad9c" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Cross Domain Activation의 전후 순서를 알고 싶다는 니즈</span></span></span></li><li id="2b7a360d-33e3-80dd-b277-c00f6907a44d" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Monthly 통계 데이터가 아니라 Daily로 실시간 트래킹 하고싶다는 요청사항</span></span></span></li></ul></span></p><p id="2b7a360d-33e3-8093-b582-ef24a0f5e50e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이러한 의견은 자연스럽게 도메인별 BC Activation Funnel 분석 등 후속 심화 분석 프로젝트로 이어졌습니다. </span></span></span></p><p id="2b7a360d-33e3-80ef-b8ae-de0149793df2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">피드백을 남겨주신 분들의 직무가 굉장히 다양했던 것도 인상깊었어요. Strategy Manager, Business Marketing Manager, Platform Product Owner, Sales Team Leader 등 각 팀과 사업부의 실무자 분들이 BC 데이터를 활용하여 본인의 임팩트를 만드는 고민을 시작하셨다는 것이 느껴졌습니다. 이런 반응을 통해 리포트가 3~4회차 발행되었을 때는 전사적으로 ‘사업자 데이터 리터러시가 높아지고 있다’는 생각이 들어서 뿌듯했어요. </span></span></span></p><p id="2b7a360d-33e3-806a-a9e1-fc379d6bebe1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-80f2-a450-cf8bab0f7863" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">📝 여전히 진행 중인, 살아있는 리포트</span></span></span></h3><p id="2b7a360d-33e3-80e8-9404-de634a39f835" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스는 보고서 형식의 정형화된 문서를 많이 사용하지는 않으나, BC 데이터는 공동의 학습과 기준 확립이 중요한 단계였기에, 명확하고 일관된 메시지를 위해 리포트 형식을 고수했습니다.</span></span></span></p><p id="2b7a360d-33e3-8066-80b0-ea5b8bcf267b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사실 이 리포트는 발행 후 단 한 번도 같은 포맷으로 나간 적이 없어요. 매달 현업의 피드백을 반영하여 새로운 지표가 추가되고, 정의가 디벨롭되어 나갑니다. 이처럼 데이터에 대한 관심과 이해도가 점차 높아지는 문화 속에서 일하는 것은 데이터 분석가로서 큰 행복이에요.</span></span></span></p><p id="2b7a360d-33e3-8086-8358-d25e89c81872" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">많은 기업에서 전사 데이터 리터러시를 올리기 위한 고민을 하는 것으로 알고 있습니다. 저는 4가지 단계가 있다고 생각하는데요, </span></span></span></p><aside id="2bca360d-33e3-80c9-8c37-d66474fdd0fe" class="css-nv7vyi"><div class="css-1vn47db"><ol class="css-hokoge"><li id="2b7a360d-33e3-80f6-8c7a-fa6991ef596d" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">누구나 쉽게 주요 데이터 볼 수 있도록 만들기 </span></span></span></li><li id="2bca360d-33e3-8081-bccf-cf78449621ae" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">데이터를 나의 업무에 접목하여 생각할 수 있도록 만들기 </span></span></span></li><li id="2bca360d-33e3-8077-bb38-cedd78584db4" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">모든 팀원들이 각자의 분야에서 데이터 분석으로 비즈니스 임팩트 만들기 </span></span></span></li><li id="2bca360d-33e3-80f5-b95f-e43dd2510576" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">성공 사례가 잘 공유될 수 있는 문화 만들기 </span></span></span></li></ol></div></aside><p id="2b7a360d-33e3-80ce-8b5d-fd67c8ffdf71" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">BC Monthly 리포트 발행으로 2번 스텝까지 달성할 수 있었다고 생각합니다. 3번과 4번 단계까지 도달하면 토스의 사업자 데이터 리터러시가 매우 높다고 자신있게 이야기할 수 있을 것 같아, 아직 갈 여정이 많이 남아 있다고 생각해요.</span></span></span></p><p id="2b7a360d-33e3-801d-b886-e3a476ee9808" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-8078-9b7a-ea11ba4efd14" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">마무리하며</span></span></span></h3><p id="2b7a360d-33e3-8035-ab99-cb9553c6868b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">해당 프로젝트를 진행하면서 가장 뿌듯했던 순간은, 사업부의 각 팀원들로부터 여러 피드백을 받았던 순간인 것 같아요. 데이터에 대한 관심과 목마름이 큰 팀원들과 함께 업무하는 것보다 더 이상적인 업무환경은 DA에게 없다고 생각합니다.</span></span></span></p><p id="2b7a360d-33e3-8019-9539-f273ae3beca2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">데이터로 비즈니스의 정의를 바꾸고 전사 데이터 리터러시를 높이는 압도적인 임팩트를 경험하고 싶은 DA라면, 토스에 지원해 주세요. 매달 새로운 도전을 과제를 풀어나가며 함께 성장해 나갈 동료를 기다립니다.</span></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[토스인컴 세금 환급 서비스 : 빠른 속도에서 품질을 지키기 위한 E2E 자동화 여정]]></title>
            <link>https://toss.tech/article/income-qa-e2e-automation</link>
            <guid>https://toss.tech/article/income-qa-e2e-automation</guid>
            <pubDate>Tue, 02 Dec 2025 06:10:00 GMT</pubDate>
            <description><![CDATA[우리는 결심했습니다. "누구나 실행할 수 있고, 언제나 신뢰할 수 있는 자동화 시스템"을 만들자고. 그 핵심은 Functional Page Object Model(POM)이었습니다.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2b8a360d-33e3-8007-a2d4-dc35894e4345" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요. 토스인컴 QA Manager 정수호입니다.</span></span></span></p><p id="2b8a360d-33e3-80f5-bd66-d18de1cdbd9e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스인컴의 QA는 단순히 ‘테스트를 수행하는 팀’이 아니에요. 우리는 제품팀의 구성원으로서 </span><span class="css-q3ktjb">품질을 함께 설계하고 실행하는 동료</span><span class="css-1kxrhf3">입니다. 특히 제가 맡고 있는 </span><span class="css-q3ktjb">세금 환급 서비스</span><span class="css-1kxrhf3">는 토스인컴을 대표하는 도메인입니다. 사용자 유형이 다양하고, 세무 로직과 정책, 예외 흐름이 많죠. 변화가 잦고 조건이 복잡한 서비스일수록 </span><span class="css-q3ktjb">품질을 초기에 설계</span><span class="css-1kxrhf3">하고 </span><span class="css-q3ktjb">실행을 단순화</span><span class="css-1kxrhf3">하는 일이 중요합니다.</span></span></span></p><p id="2b8a360d-33e3-80ca-8be6-d6dc012aa049" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">메뉴얼 검증으로는 &quot;빠르게 실험하고, 빠르게 배포하는&quot; 토스의 속도를 따라갈 수 없습니다. 버튼 하나, 문구 하나가 바뀌어도 35개 이상의 시나리오를 다시 확인해야 했고, 작은 누락이 전체 배포를 지연시키기도 했습니다.</span></span></span></p><p id="2b8a360d-33e3-803d-9ecf-f6999e7737d8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 우리는 결심했습니다.</span><span class="css-q3ktjb"> &quot;누구나 실행할 수 있고, 언제나 신뢰할 수 있는 자동화 시스템&quot;</span><span class="css-1kxrhf3">을 만들자고. 그 핵심은 </span><span class="css-q3ktjb">Functional Page Object Model(POM)</span><span class="css-1kxrhf3">이었습니다.</span></span></span></p><p id="2b8a360d-33e3-80b1-a69d-ef68b6e93e78" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-80fd-8f46-f8f051907607" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스인컴 QA의 일하는 방식</span></span></span></h3><p id="2b8a360d-33e3-8055-9767-fc402899b7f0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스인컴의 QA는 중앙 </span><span class="css-q3ktjb">기능조직(QA 팀)</span><span class="css-1kxrhf3">이면서 동시에 각 서비스의 </span><span class="css-q3ktjb">사일로(제품팀)</span><span class="css-1kxrhf3"> 안에 </span><span class="css-q3ktjb">겸직</span><span class="css-1kxrhf3"> 형태로 배치됩니다.즉, </span><span class="css-q3ktjb">제품팀 속 QA</span><span class="css-1kxrhf3">로서 프로젝트의 </span><span class="css-q3ktjb">초기 기획·디자인</span><span class="css-1kxrhf3">부터 </span><span class="css-q3ktjb">배포·라이브 모니터링</span><span class="css-1kxrhf3">까지 전 과정을 함께해요.</span></span></span></p><aside id="2b8a360d-33e3-80ea-b9c8-ce1b610baa58" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b8a360d-33e3-8023-9404-c2917d8ede08" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">요구사항과 히스토리를 </span><span class="css-q3ktjb">처음부터</span><span class="css-1kxrhf3"> 이해합니다.</span></span></span></li><li id="2b8a360d-33e3-80ed-abf8-d97c40d7d19b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">리스크를 </span><span class="css-q3ktjb">사전에</span><span class="css-1kxrhf3"> 발견해 범위와 우선순위를 명확히 합니다.</span></span></span></li><li id="2b8a360d-33e3-80e3-982a-fc447ed60a20" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">테스트 케이스 설계와 실행을 </span><span class="css-q3ktjb">사용자 여정</span><span class="css-1kxrhf3"> 기준으로 녹여냅니다.</span></span></span></li><li id="2b8a360d-33e3-80b7-852f-d08bd1ea8b69" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">배포 이후에는 팀 전체가 함께 </span><span class="css-q3ktjb">라이브 상태를 점검</span><span class="css-1kxrhf3">합니다.</span></span></span></li></ul></div></aside><p id="2b8a360d-33e3-800d-9525-c4555f78d22b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 구조 덕분에 QA는 &quot;끝단에서 문제를 발견하는 팀&quot;이 아니라, </span><span class="css-q3ktjb">의사결정에 참여해 리스크를 줄이고 실행 속도를 높이는 팀</span><span class="css-1kxrhf3">이 됩니다. Functional POM은 이런 일하는 방식과 최적의 궁합을 이뤄요.</span></span></span></p><p id="2b8a360d-33e3-809d-9f22-e177363f421c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1qimhyf">*POM: 화면을 어떻게 조작할지에 대한 설명서를 코드로 한곳에 모아둔 것
*Functional: 그 설명서를 작고 명확한 함수들로 나눠 필요한 것만 조립해 쓰는 방식</span></span></span></p><p id="2b8a360d-33e3-803e-91d7-ed8011c24636" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-805a-bd8a-de7afe3f1371" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">우리가 마주했던 현실과 전환의 계기</span></span></span></h3><p id="2b8a360d-33e3-8055-818f-d3910127a957" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">초기에는 우리도 일반적인 </span><span class="css-q3ktjb">클래스 기반 POM</span><span class="css-1kxrhf3">을 도입했습니다. 하지만 세금 서비스 특성상 </span><span class="css-q3ktjb">UI 문구와 전환 흐름이 자주 바뀌는</span><span class="css-1kxrhf3"> 상황에서, </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">this</span></code><span class="css-1kxrhf3"> 상태 관리와 상속 구조는 </span><span class="css-q3ktjb">복잡성을 더했고 유지보수 비용</span><span class="css-1kxrhf3">이 계속 늘었어요.</span></span></span></p><aside id="2b8a360d-33e3-8091-8577-c23b5c200fa5" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b8a360d-33e3-8016-8f9e-ecea255c06c4" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">작은 문구 수정 하나가 </span><span class="css-q3ktjb">모든 테스트를 깨뜨리는</span><span class="css-1kxrhf3"> 상황</span></span></span></li><li id="2b8a360d-33e3-8097-99e3-c2ba5b38e18f" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">35개 시나리오 중 </span><span class="css-q3ktjb">어디선가 셀렉터가 어긋나며 도미노처럼 실패</span></span></span></li><li id="2b8a360d-33e3-80ec-921a-cef5b5ecc144" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">새 창·리다이렉트·스크래핑 탭 전환에서 </span><span class="css-q3ktjb">&quot;Page is closed&quot;</span><span class="css-1kxrhf3"> 빈발</span></span></span></li></ul></div></aside><p id="2b8a360d-33e3-8042-8de0-f22182203675" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">우리는 깨달았습니다. </span><span class="css-q3ktjb">자동화는 라이브러리 선택이 아니라 &quot;운용 구조&quot; 문제</span><span class="css-1kxrhf3">라는 것을. 그래서 목표를 다시 세웠습니다. </span><span class="css-q3ktjb">더 단순하게, 더 조립 가능하게, 더 읽기 쉽게.</span></span></span></p><p id="2b8a360d-33e3-80f9-a4ae-c525e21eb74c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b8a360d-33e3-800d-822c-f7e8aed6d1c2" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">우리가 시도한 변화들 (Functional POM을 중심으로)</span></span></span></h2><h3 id="2b8a360d-33e3-8023-8aa0-f4905b857618" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ 클래스 대신 </span><span class="css-q3ktjb">함수형 POM</span><span class="css-1kxrhf3">으로</span></span></span></h3><p id="2b8a360d-33e3-8010-8c60-e1cd15e742c1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">상태를 가지는 클래스 대신, </span><span class="css-q3ktjb">무상태(Stateless) 함수</span><span class="css-1kxrhf3">로 페이지 동작을 설계했습니다. 원칙은 단순합니다.
</span><span class="css-1odxvuk">입력으로 page(그리고 필요 시 context)를 받고, 결과로 page를 돌려준다.</span></span></span></p><p id="2b8a360d-33e3-8074-8a21-ff1b8debe511" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Before — POM 없이 작성된 테스트(중복·취약)</span></span></span></p><p id="2b8a360d-33e3-80ba-8f92-f965ed6bd823" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">After — 함수형 POM으로 캡슐화</span></span></span></p><p id="2b8a360d-33e3-8052-87ec-e201e1d7841b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">테스트는 &quot;사람이 읽는 시나리오&quot;처럼</span></span></span></p><p id="2b8a360d-33e3-8054-830a-cbdbc7e62799" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">네이밍 컨벤션(가독성 강화)</span></span></span></p><div data-table-wrapper="true" class="css-1m7s5mg"><div role="table" class="css-uznrcw"><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">접두사</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">의미</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">예시</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">goto</span></code></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">페이지 이동</span></div><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">gotoLoginPage()</span></code></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">click</span></code></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">클릭</span></div><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">clickReConsent()</span></code></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">enter</span></code></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">입력</span></div><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">enterPhonePin()</span></code></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">answer</span></code></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">질문 응답</span></div><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">answerNoMarriageQuestion()</span></code></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">add/skip/update</span></code></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">데이터 조작</span></div><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">addMedicalDeduction()</span></code></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">verify/check</span></code></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">검증</span></div><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">verifyRefundAmount()</span></code></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">waitFor</span></code></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">대기</span></div><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">waitForRefundPageReady()</span></code></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">complete</span></code></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">복합 플로우</span></div><div role="cell" class="css-8vl804"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">completeLogin()</span></code></div></div></div></div><p id="2b8a360d-33e3-808f-8e3c-d53a40350997" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-800e-afee-c4b87ac2c688" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣ &quot;페이지=화면&quot;이 아니라 &quot;여정의 단계&quot;로 분리</span></span></span></h3><p id="2b8a360d-33e3-8012-af16-e4ed8a3f7195" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">세금 환급의 전체 여정을 </span><span class="css-q3ktjb">4단계</span><span class="css-1kxrhf3">로 나눴습니다.</span></span></span></p><aside id="2b8a360d-33e3-8028-8f1d-f0bbc4db91df" class="css-nv7vyi"><div class="css-1vn47db"><ol class="css-hokoge"><li id="2b8a360d-33e3-8063-b46b-c9cb5b661a25" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">로그인 및 약관 동의</span></span></span></li><li id="2b8a360d-33e3-8081-b847-f57b334c0649" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">공제 설정</span></span></span></li><li id="2b8a360d-33e3-805f-9aae-ff825c81bf92" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">환급 정보 및 결제</span></span></span></li><li id="2b8a360d-33e3-801e-b3c0-fc4546223c33" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">신고 완료</span></span></span></li></ol></div></aside><p id="2b8a360d-33e3-80b7-84cf-e214427b2a95" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">각 단계는 </span><span class="css-q3ktjb">하나의 페이지 오브젝트 파일</span><span class="css-1kxrhf3">이 담당합니다.</span></span></span></p><p id="2b8a360d-33e3-8023-8781-dc0d585ff9fa" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 나누면 페이지 전환이 잦아도 </span><span class="css-q3ktjb">책임 경계</span><span class="css-1kxrhf3">가 명확하고, 각 단계를 </span><span class="css-q3ktjb">독립적으로 수정·재사용</span><span class="css-1kxrhf3">할 수 있습니다.</span></span></span></p><p id="2b8a360d-33e3-802b-a869-c17df9f3bdf1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-8039-b6c1-ddaaa3f70f07" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">3️⃣ Robust Click Strategy</span><span class="css-1kxrhf3"> — 클릭 실패에 흔들리지 않게</span></span></span></h3><p id="2b8a360d-33e3-80a5-9658-ff2cf6de39a8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">React 렌더링 타이밍으로 생기는 </span><span class="css-q3ktjb">간헐 실패(플래키)</span><span class="css-1kxrhf3">를 줄이기 위해, 클릭 유틸에 </span><span class="css-q3ktjb">4단계 폴백</span><span class="css-1kxrhf3">을 넣었습니다.</span></span></span></p><p id="2b8a360d-33e3-8087-a616-e36600b3b243" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">과거엔 &quot;클릭이 안 돼요&quot;가 매일 한 번씩 들렸다면, 지금은 거의 들리지 않습니다.</span></span></span></p><p id="2b8a360d-33e3-80b6-b805-dc62bc3cd17c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80b8-8b14-cca3f5bd8e0e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-8003-a1d3-faaa471cc140" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">4️⃣</span><span class="css-1kxrhf3"> </span><span class="css-q3ktjb">페이지 전환 자동 감지</span><span class="css-1kxrhf3"> — 새 창/리다이렉트에서도 안전하게</span></span></span></h3><p id="2b8a360d-33e3-8005-81cb-e27b9ffcb547" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">로그인 → 스크래핑 → 결제 등에서 새 창이 열리거나 리다이렉트가 일어나면 </span><span class="css-q3ktjb">기존 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1y26ms3">page</span></code><span class="css-q3ktjb">가 닫히곤</span><span class="css-1kxrhf3"> 합니다. 항상 </span><span class="css-q3ktjb">최신 유효 페이지</span><span class="css-1kxrhf3">를 다시 얻어 쓰는 패턴을 </span><span class="css-q3ktjb">유틸로 통일</span><span class="css-1kxrhf3">했어요.</span></span></span></p><p id="2b8a360d-33e3-807d-9f86-cb1b8c07d5f6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">테스트 본문에서는 전환마다 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">currentPage = ...</span></code><span class="css-1kxrhf3">를 명시적으로 </span><span class="css-q3ktjb">교체</span><span class="css-1kxrhf3">해 항상 올바른 탭에서 동작하도록 합니다.</span></span></span></p><p id="2b8a360d-33e3-80b1-9e15-eb2f404128ee" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-8075-9ead-e7aa6e4a262f" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">5️⃣ </span><span class="css-q3ktjb">공제별 독립 함수</span><span class="css-1kxrhf3"> — 시나리오를 &quot;레고처럼 조립&quot;</span></span></span></h3><p id="2b8a360d-33e3-80e3-8cba-eb94a5bd7295" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">의료비, 신용카드, 주담대, 인적공제 등 모든 공제 동작을 </span><span class="css-q3ktjb">완전히 독립된 함수</span><span class="css-1kxrhf3">로 만들었습니다. 조합만 바꾸면 </span><span class="css-q3ktjb">새로운 테스트</span><span class="css-1kxrhf3">를 빠르게 만들 수 있어요.</span></span></span></p><p id="2b8a360d-33e3-8038-9c9b-d04429db10e3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-80a1-b067-d608245fa6d1" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">6️⃣ </span><span class="css-q3ktjb">협업 중심 운영</span><span class="css-1kxrhf3"> — 스펙 변경이 POM 한 곳으로 흘러가게</span></span></span></h3><p id="2b8a360d-33e3-807f-b34c-d4f32ea5281f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 각 사일로의 Slack 스레드에서 </span><span class="css-q3ktjb">기획 변경·디자인 업데이트·릴리즈 공지</span><span class="css-1kxrhf3">를 한 줄로 이어 관리합니다. 문구나 버튼이 바뀌면, </span><span class="css-q3ktjb">테스트 본문은 그대로</span><span class="css-1kxrhf3"> 두고 </span><span class="css-q3ktjb">POM/유틸 한 곳</span><span class="css-1kxrhf3">만 수정해요.</span></span></span></p><ul class="css-uswsmm"><li id="2b8a360d-33e3-8022-9eca-cd8ce033e425" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기획: &quot;버튼 &#x27;확인&#x27; → &#x27;시작하기&#x27;로 변경&quot;</span></span></span></li><li id="2b8a360d-33e3-8059-acfc-c8a007b83adc" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">QA: &quot;</span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">clickButton(&quot;시작하기&quot;)</span></code><span class="css-1kxrhf3">로 POM 반영 완료. 전체 자동화에 즉시 적용&quot;</span></span></span></li></ul><p id="2b8a360d-33e3-8077-9c56-f14e9edb4e99" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">소통 채널과 변경 반영 위치를 </span><span class="css-q3ktjb">한 곳으로 모으니</span><span class="css-1kxrhf3"> 속도와 안정성이 동시에 올라갔습니다.</span></span></span></p><p id="2b8a360d-33e3-808e-9566-cff7e7e8ce62" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><p id="2b8a360d-33e3-808e-b337-deff32599232" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-808f-a28a-d20837889f9c" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">시스템 개요(스택/구조)</span></span></span></h3><aside id="2b8a360d-33e3-80f0-bbb9-c2095636b23d" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b8a360d-33e3-80d5-ae94-d3e52166c0b9" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Framework</span><span class="css-1kxrhf3">: NestJS v10</span></span></span></li><li id="2b8a360d-33e3-80a2-8a64-d6276e8f613b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Engine</span><span class="css-1kxrhf3">: Playwright v1.48 (HTML 리포트, 비디오/스크린샷)</span></span></span></li><li id="2b8a360d-33e3-80d0-82e4-e5bffda69a62" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Infra</span><span class="css-1kxrhf3">: Worker Threads 병렬 실행, Slack Web API 알림</span></span></span></li></ul></div></aside><p id="2b8a360d-33e3-80c4-b5ff-f01d24b20aaa" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">아키텍처 개념</span></span></span></p><aside id="2b8a360d-33e3-809b-b0a0-ee96091cc1b3" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b8a360d-33e3-8099-8988-e7c24178c9e9" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">테스트는 </span><span class="css-q3ktjb">함수형 POM</span><span class="css-1kxrhf3">과 </span><span class="css-q3ktjb">유틸</span><span class="css-1kxrhf3">을 가져와 </span><span class="css-q3ktjb">시나리오 스크립트</span><span class="css-1kxrhf3">로 구성</span></span></span></li><li id="2b8a360d-33e3-8039-a38b-d3102322cdf3" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">공통 유틸(</span><span class="css-q3ktjb">클릭/대기/전환 추적</span><span class="css-1kxrhf3">)은 한 곳에서 개선 → 전체 효과</span></span></span></li><li id="2b8a360d-33e3-8027-945d-d5ef71090bee" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">리포트는 </span><span class="css-q3ktjb">HTML 통합</span><span class="css-1kxrhf3"> + </span><span class="css-q3ktjb">비디오 증적</span><span class="css-1kxrhf3"> + </span><span class="css-q3ktjb">Slack 요약 알림</span></span></span></li></ul></div></aside><p id="2b8a360d-33e3-8057-9c8d-f7b01a2b9e16" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-8078-a7ab-d7fca420046f" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실행 패턴 &amp; 결과 확인</span></span></span></h3><aside id="2b8a360d-33e3-8075-a13e-fdfe197f096b" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b8a360d-33e3-801c-af74-d05cf75928fe" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">단일 실행</span><span class="css-1kxrhf3">: 특정 TC만 디버그 (비디오 ON)</span></span></span></li><li id="2b8a360d-33e3-80ae-8d65-c98f5edc8c8b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">전체 실행</span><span class="css-1kxrhf3">: 워커 병렬 (HTML 리포트 병합, Slack 알림)</span></span></span></li><li id="2b8a360d-33e3-8008-aaf5-de3cb73a5f98" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">반복 실행</span><span class="css-1kxrhf3">: 플래키 구간 집중 검증 (횟수·쿨다운)</span></span></span></li><li id="2b8a360d-33e3-80f8-a404-ffd0206c6182" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">격리 실행</span><span class="css-1kxrhf3">: 사용자/쿠폰/스크래핑 상태를 </span><span class="css-q3ktjb">테스트 데이터</span><span class="css-1kxrhf3">로 분리</span></span></span></li></ul></div></aside><p id="2b8a360d-33e3-8059-b795-c0d232a8f450" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">결과물</span></span></span></p><aside id="2b8a360d-33e3-8018-baf4-e68f79190d91" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b8a360d-33e3-807d-8e4e-eadf5a651325" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">HTML 리포트</span><span class="css-1kxrhf3">: 실패 스택/스크린샷/영상 한눈에</span></span></span></li><li id="2b8a360d-33e3-80a0-8706-d684a445e4d6" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">비디오</span><span class="css-1kxrhf3">: 전환 타이밍·클릭 실패 재현성 강화</span></span></span></li><li id="2b8a360d-33e3-8066-b2fb-f8b58c302be3" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Slack</span><span class="css-1kxrhf3">: 요약 알림 + 실패 케이스 바로가기</span></span></span></li></ul></div></aside><p id="2b8a360d-33e3-80f4-83fd-e181b079c227" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-80d7-a1ad-ff4b6b385e5a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">우리가 얻은 결과(숫자 &amp; 체감)</span></span></span></h3><div data-table-wrapper="true" class="css-1m7s5mg"><div role="table" class="css-1emlqs7"><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">지표</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">Before (Manual/Legacy)</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">After (Functional POM)</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">개선율</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">검증 시간</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">4시간+</span></div><div role="cell" class="css-8vl804"><span class="css-1y26ms3">55분</span><span class="css-1mjnzsq"> (병렬 </span><span class="css-1y26ms3">20분</span><span class="css-1mjnzsq">)</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">77% ↓</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">커버리지</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">주요 5개</span></div><div role="cell" class="css-8vl804"><span class="css-1y26ms3">35개 전체 시나리오</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">+600%</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">성공률</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">불안정</span></div><div role="cell" class="css-8vl804"><span class="css-1y26ms3">100% (최근 2주)</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">—</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">코드 중복률</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">85%</span></div><div role="cell" class="css-8vl804"><span class="css-1y26ms3">20%</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">76% ↓</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">신규 테스트 작성</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">2시간</span></div><div role="cell" class="css-8vl804"><span class="css-1y26ms3">20분</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">83% ↓</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">UI 변경 대응</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">35개 파일 수정</span></div><div role="cell" class="css-8vl804"><span class="css-1y26ms3">POM 1곳 수정</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">98% ↓</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">온보딩</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">1주</span></div><div role="cell" class="css-8vl804"><span class="css-1y26ms3">1일</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">86% ↓</span></div></div></div></div><p id="2b8a360d-33e3-8004-ae0a-fe413be14a04" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><p id="2b8a360d-33e3-8037-a5a2-fb1fe7b2fc1a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-8025-8510-f85975ab82e7" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">트러블슈팅 플레이북</span></span></span></h3><p id="2b8a360d-33e3-8029-9018-eefcd16d402e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-ptbvf1">타임아웃 문제 해결하기</span><span class="css-q3ktjb">
</span><span class="css-1kxrhf3">세금환급 서비스에는 폴링이 있는 화면이 많아요. 네트워크가 완전히 쉬지 않기 때문에 Playwright의 기본 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">networkidle</span></code><span class="css-1kxrhf3"> 대기 방식은 자주 실패했습니다.
그래서 </span><span class="css-q3ktjb">&quot;실패로 간주하지 않는 안전 대기&quot;</span><span class="css-1kxrhf3">를 기본값으로 두었어요. </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">waitForNetworkIdleSafely</span></code><span class="css-1kxrhf3">는 네트워크가 잠잠해질 때까지 최대한 기다리되, 타임아웃이 나더라도 테스트 자체는 중단하지 않습니다. 화면이 준비됐는지는 텍스트나 role 같은 </span><span class="css-q3ktjb">UI 앵커</span><span class="css-1kxrhf3">로 판단하죠.
이렇게 하니 네트워크는 움직이지만 실제 화면은 이미 준비된 상황에서도 테스트가 안정적으로 진행됐어요.</span></span></span></p><p id="2b8a360d-33e3-8007-abe8-e98562c73f1e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8083-b130-df0ae110b6d8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-ptbvf1">페이지 전환 실패 극복하기</span><span class="css-q3ktjb">
</span><span class="css-1kxrhf3">로그인이나 결제 단계처럼 새 창이 열리거나 리다이렉트가 자주 발생하는 구간에서는 기존 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">page</span></code><span class="css-1kxrhf3"> 객체를 그대로 쓰면 &quot;Page is closed&quot; 에러가 터져요.
이제는 모든 의미 있는 동작이 끝날 때마다 </span><span class="css-q3ktjb">&quot;최신 페이지를 다시 가져오는&quot; 습관</span><span class="css-1kxrhf3">을 들였습니다. </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">getLatestNonScrapePage</span></code><span class="css-1kxrhf3">로 스크래핑 탭을 제외한 유효한 최신 탭을 찾아 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">currentPage</span></code><span class="css-1kxrhf3">를 항상 새로 할당해요. 이 단순한 패턴 하나로 전환 관련 에러가 거의 사라졌습니다.</span></span></span></p><p id="2b8a360d-33e3-8061-8fb0-d013707df95d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-808b-b969-fc4b41facd37" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-ptbvf1">클릭 미적중 대응 전략</span><span class="css-q3ktjb">
</span><span class="css-1kxrhf3">클릭 미적중은 한 번에 해결하려 하지 않았어요. 대신 실패에 </span><span class="css-q3ktjb">내성을 넣는 방식</span><span class="css-1kxrhf3">으로 접근했습니다.
버튼 클릭은 </span><span class="css-q3ktjb">Enter 키 → 일반 클릭 → Force 클릭 → JS 직접 실행</span><span class="css-1kxrhf3"> 순으로 네 단계 시도합니다. 어떤 단계에서 어떤 버튼을 눌렀다가 실패했는지, 실패 시점의 URL, 사용한 대기 전략까지 모두 에러 메시지에 남겨요. 다음에 같은 에러가 발생하더라도 원인 파악이 훨씬 빠르고 재현도 간단해졌습니다.</span></span></span></p><p id="2b8a360d-33e3-8002-88f5-c9330147d5f2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80ac-85c6-e15e851408d1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-ptbvf1">UI 변경에 유연하게 대응하기</span><span class="css-q3ktjb">
</span><span class="css-1kxrhf3">UI 문구가 바뀌는 건 거의 매번 일어나요. 이럴 땐 테스트 본문을 건드리지 않고 </span><span class="css-q3ktjb">POM과 유틸만 수정</span><span class="css-1kxrhf3">합니다. 테스트는 그대로 &quot;결혼공제 No, 의료비 Yes…&quot; 같은 </span><span class="css-q3ktjb">비즈니스 문장</span><span class="css-1kxrhf3">으로 남겨두고, 버튼, 셀렉터, 대기 전략은 모두 POM이 책임지죠.
데이터 의존이 큰 단계에서는 금액, 종류, 날짜 같은 입력값을 </span><span class="css-q3ktjb">기본값이 있는 파라미터</span><span class="css-1kxrhf3">로 바꿔 노출했어요. 이렇게 하니 케이스 생성 속도가 훨씬 빨라졌고, 같은 흐름에서도 숫자만 바꾸면 새로운 시나리오가 만들어집니다.</span></span></span></p><p id="2b8a360d-33e3-8016-8f45-e2afccabd599" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><p id="2b8a360d-33e3-80b3-8269-d460bab2b679" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-80f7-9636-cfcf72581fc8" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">트러블슈팅 이후의 변화</span></span></span></h3><p id="2b8a360d-33e3-80fd-b028-ee47bea46511" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 구조가 자리를 잡자, 팀 안의 일상이 완전히 달라졌습니다.</span></span></span></p><p id="2b8a360d-33e3-809e-8734-f5d8cb911e96" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-ptbvf1">개발 후 즉시 자동 검증</span><span class="css-q3ktjb">
</span><span class="css-1kxrhf3">이제는 </span><span class="css-q3ktjb">개발이 끝나면 바로 기본 기능 자동 점검이 진행</span><span class="css-1kxrhf3">돼요. 핵심 시나리오를 빠르게 훑는 기능 테스트가 계속 돌아가고, 문제 없이 통과되면 바로 배포할 수 있습니다. QA 요청을 따로 넣을 필요가 없죠.</span></span></span></p><p id="2b8a360d-33e3-8070-893f-ec9169374799" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8054-b328-f92808dd353a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-ptbvf1">24시간 자동화 시스템</span><span class="css-q3ktjb">
</span><span class="css-1kxrhf3">현재 자동화는 24시간 가동 중이에요. 누가 요청하지 않아도 결과가 자동으로 사내 메신저의 QA Automation 증적 채널로 공유됩니다. 모든 테스트가 통과했는지, 어떤 스텝이 오래 걸렸는지, 새 코드 배포 이후 속도가 얼마나 개선됐는지까지 한눈에 볼 수 있어요.</span></span></span></p><p id="2b8a360d-33e3-8049-8fa5-c4ecff76907b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80d6-b5ae-d614707b36b6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-ptbvf1">금액 정합성 자동 검증</span><span class="css-q3ktjb">
</span><span class="css-1kxrhf3">세금환급 서비스는 금액이 핵심 데이터입니다. 이제는 </span><span class="css-q3ktjb">엔진(플랫폼)에서 계산 로직이 바뀌어도 금액 정합성을 자동으로 검증</span><span class="css-1kxrhf3">해요. 과거에는 QA가 직접 여러 케이스를 돌려 눈으로 비교해야 했지만, 지금은 자동화가 모든 금액을 비교하고 오차를 리포트합니다.</span></span></span></p><p id="2b8a360d-33e3-80a2-a158-f044cf7da121" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8080-a67f-c4c6d4ed2202" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-ptbvf1">성능 개선 지표로 활용</span><span class="css-q3ktjb">
</span><span class="css-1kxrhf3">자동화 리포트에는 </span><span class="css-q3ktjb">각 스텝별 실행 시간</span><span class="css-1kxrhf3">이 표시돼요. 기능 개선 전후를 비교하면 &quot;어떤 부분에서 얼마나 빨라졌는지&quot;를 수치로 바로 확인할 수 있습니다. QA 리포트는 이제 단순한 통과 여부를 넘어, </span><span class="css-q3ktjb">성능과 속도 개선을 시각적으로 보여주는 지표</span><span class="css-1kxrhf3">로 자리 잡았어요.
이 모든 과정은 누가 일일이 요청하거나 기다릴 필요 없이 자동으로 돌아가요. 그 결과, 팀은 &quot;검증을 기다리는 시간&quot; 대신 &quot;다음 개선을 준비하는 시간&quot;에 집중할 수 있게 됐습니다.</span></span></span></p><p id="2b8a360d-33e3-807a-8b70-e69c9408870a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><p id="2b8a360d-33e3-8028-ae96-ffdeb57678a2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-8034-a1a4-f863c2d6e451" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실전 팁 &amp; 베스트 프랙티스</span></span></span></h3><p id="2b8a360d-33e3-8048-ba90-c5b3ef598f2a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1️⃣ 가장 아픈 곳부터 시작하기
</span><span class="css-1kxrhf3">우리는 늘 </span><span class="css-q3ktjb">가장 아픈 곳부터</span><span class="css-1kxrhf3"> 시작했어요. 가장 자주 깨지던 로그인·약관 구간을 먼저 함수로 뽑았고, 그다음 공제, 결제, 신고 순으로 확장했습니다.</span></span></span></p><p id="2b8a360d-33e3-80c6-af65-fd815b67e5ac" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8071-93f9-f283fef6a647" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣ </span><span class="css-q3ktjb">사용자 시나리오 기준으로 파일 나누기
</span><span class="css-1kxrhf3">파일을 나눌 때는 화면이 아니라 </span><span class="css-q3ktjb">사용자 시나리오를</span><span class="css-1kxrhf3"> 기준으로 경계를 나눴어요. 이 기준이 명확해야 책임이 선명해지고, 수정도 빠르거든요.</span></span></span></p><p id="2b8a360d-33e3-806e-a723-dd8a738536d3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8021-bf1c-ed515d953fc5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3️⃣ </span><span class="css-q3ktjb">페이지 전환 시 원칙 지키기
</span><span class="css-1kxrhf3">전환을 다룰 때는 원칙 하나를 정했어요.
</span><span class="css-120saye">&quot;전환 후에는 반드시 currentPage를 새로 할당한다.&quot;
</span><span class="css-1kxrhf3">이 짧은 한 줄이 수많은 전환 문제를 미리 막아줬습니다.</span></span></span></p><p id="2b8a360d-33e3-8079-803f-f135679ea20a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80e0-a4d9-f3fa31d84cb9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">4️⃣ </span><span class="css-q3ktjb">과한 추상화 피하기
</span><span class="css-1kxrhf3">추상화는 과하게 하지 않았어요. 클래스를 여러 겹으로 쌓는 대신, </span><span class="css-q3ktjb">작은 함수와 명시적 인자</span><span class="css-1kxrhf3">로 명료함을 택했습니다. 누구나 유지보수를 할 수 있도록 말이에요</span></span></span></p><p id="2b8a360d-33e3-8051-b565-f127e576a048" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80e7-942d-d883657112f0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">5️⃣ </span><span class="css-q3ktjb">변경에 유연한 구조 만들기
</span><span class="css-1kxrhf3">자주 바뀌는 문구, 셀렉터, 대기 로직은 전부 </span><span class="css-q3ktjb">POM과 유틸의 영역</span><span class="css-1kxrhf3">으로 두었어요. 테스트 본문에는 최대한 </span><span class="css-q3ktjb">비즈니스 문장만 남겨</span><span class="css-1kxrhf3">, 누가 봐도 읽히는 테스트를 만들었습니다.</span></span></span></p><p id="2b8a360d-33e3-808f-babc-dc1510cfcded" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8095-85f7-f5f2a7ed66fd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">6️⃣ </span><span class="css-q3ktjb">실패 로그 상세히 남기기
</span><span class="css-1kxrhf3">실패가 발생하면 &quot;무엇을 하다 실패했는지(버튼/URL/대기)&quot;를 그대로 로그에 남겨요. 재현이 빠르고, 학습이 쉬워집니다.</span></span></span></p><p id="2b8a360d-33e3-8047-969a-eea14601de5c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-802e-b901-cfc2e1f713e3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">7️⃣ </span><span class="css-q3ktjb">코드를 문서처럼 작성하기
</span><span class="css-1kxrhf3">모든 함수에는 JSDoc으로 사용법과 주의사항, 간단한 예시를 적어두었어요. 새로 합류한 팀원도 코드를 열자마자 이해할 수 있게 하기 위해서죠. 우리에게 </span><span class="css-q3ktjb">코드는 곧 문서</span><span class="css-1kxrhf3">입니다.</span></span></span></p><p id="2b8a360d-33e3-80d7-a4cb-d707d39c11fa" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><p id="2b8a360d-33e3-8023-873c-f91ee560ed0d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-80f2-bd1e-eb3a693f29b2" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">읽히는 테스트를 만드는 법</span></span></span></h3><p id="2b8a360d-33e3-80bf-ae5c-ca559053fd7c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ </span><span class="css-q3ktjb">서술형 제목으로 시작하기
</span><span class="css-1kxrhf3">테스트는 제목부터 </span><span class="css-q3ktjb">서술형 문장</span><span class="css-1kxrhf3">으로 써요. 예를 들어 &quot;결혼공제 No + 의료비 Yes → 환급 확인 후 결제 완료&quot;처럼요.</span></span></span></p><p id="2b8a360d-33e3-80f3-be53-da90acbb67e6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-806e-8bff-f2b847371444" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣ </span><span class="css-q3ktjb">사전조건 명확히 하기
</span><span class="css-1kxrhf3">사전조건에는 &quot;로그인 가능한 유저&quot;, &quot;세금환급 서비스 진입 가능&quot;처럼 최소한의 맥락만 남깁니다.</span></span></span></p><p id="2b8a360d-33e3-8097-92ce-fc6eb40a2fcf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8005-a9a1-d0e1e167cdd4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3️⃣ </span><span class="css-q3ktjb">Given-When-Then 구조로 작성하기
</span><span class="css-1kxrhf3">시나리오는 Given–When–Then의 리듬으로 써요.
&quot;로그인과 약관 동의가 끝난 상태에서, 결혼공제는 아니요로 답하고, 의료비 공제를 받고, 신용카드 공제는 건너뛴 뒤, 예상 환급액 300,000원을 확인하고 결제·신고까지 완료한다.&quot;</span></span></span></p><p id="2b8a360d-33e3-80ca-94c0-d60ab7931030" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80ed-bce3-fcd412661724" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">4️⃣ </span><span class="css-q3ktjb">운영 방식 문서화하기
</span><span class="css-1kxrhf3">운영 방식도 자연어로 덧붙여요. &quot;이 케이스는 단일·반복·격리 실행이 가능하며, 워커 병렬을 켜면 HTML 리포트가 병합되고, 비디오와 Slack 알림으로 결과가 공유된다.&quot;</span></span></span></p><p id="2b8a360d-33e3-8060-85d6-e332b071c849" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8058-983f-f3236247dd6b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">5️⃣ </span><span class="css-q3ktjb">자연어를 코드로 변환하기
</span><span class="css-1kxrhf3">이렇게 자연어로 먼저 작성한 시나리오를 그대로 코드로 옮기면 다음과 같아요.</span></span></span></p><p id="2b8a360d-33e3-8064-98ab-eb76bcea2388" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">핵심은 하나예요. </span><span class="css-q3ktjb">테스트가 먼저 읽히고, 코드가 그 뒤를 따라간다.</span><span class="css-1kxrhf3"> 이 순서를 지키면 비개발자도 테스트를 이해할 수 있고, 개발자는 즉시 실행 가능한 스크립트를 얻습니다.</span></span></span></p><p id="2b8a360d-33e3-8002-ab5b-ffd21cba895f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-804e-b276-c065a53fc979" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">우리가 배운 것들</span></span></span></h3><p id="2b8a360d-33e3-80d1-8eee-d86433cb9791" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">우리가 이 과정을 통해 배운 건 단순합니다.</span></span></span></p><aside id="2b8a360d-33e3-801f-8c52-ec090fd273eb" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b8a360d-33e3-8029-9fac-c06b619b5d8b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">복잡함을 이기는 방법은 </span><span class="css-q3ktjb">단순화와 일관성</span><span class="css-1kxrhf3">이에요.</span></span></span></li><li id="2b8a360d-33e3-80c3-862a-d78d6ccc8e07" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">상속과 클래스보다 </span><span class="css-q3ktjb">작은 함수와 명시적 컨텍스트</span><span class="css-1kxrhf3">가 훨씬 강해요.</span></span></span></li><li id="2b8a360d-33e3-8045-b643-e36b56a08bef" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">자주 변하는 요소일수록 </span><span class="css-q3ktjb">한 곳(POM/유틸)</span><span class="css-1kxrhf3">에 모아 관리하는 게 나아요.</span></span></span></li><li id="2b8a360d-33e3-80f2-802c-d3cf6c523e5e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">QA는 더 이상 &#x27;게이트&#x27;가 아니라 </span><span class="css-q3ktjb">&#x27;가속기&#x27;</span><span class="css-1kxrhf3">예요.</span></span></span></li></ul></div></aside><p id="2b8a360d-33e3-8060-94c3-da139892fb57" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">처음부터 함께 설계하고, 누구나 반복 가능한 형태로 실행을 정리할 때, 팀은 더 빠르고 안정적으로 나아갈 수 있습니다.</span></span></span></p><p id="2b8a360d-33e3-80ec-8a10-fe9d55ddbaa1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-80cb-a05e-ed8f1ff33e38" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">마치며</span></span></span></h3><p id="2b8a360d-33e3-805d-bf02-eb1bc1003345" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Functional POM은 어떤 유행을 쫓기 위한 도구가 아니에요. 우리에겐 </span><span class="css-q3ktjb">일을 단순하게 만드는 습관</span><span class="css-1kxrhf3">이었습니다. 클래스 대신 함수를 선택했고, 과한 추상화 대신 </span><span class="css-q3ktjb">가독성과 조립성</span><span class="css-1kxrhf3">을 택했습니다. 그 결과, UI가 바뀌어도 두렵지 않은 테스트를 갖게 됐어요. 지금도 35개의 시나리오가 모두 살아 있는 자동화를 유지하고 있습니다.</span></span></span></p><p id="2b8a360d-33e3-80dc-9926-e59e06958471" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이제 QA는 끝에서 검증만 하는 팀이 아니에요. </span><span class="css-q3ktjb">처음부터 함께 설계하고, 함께 개선하는 팀</span><span class="css-1kxrhf3">으로 자리 잡았습니다. 앞으로도 토스인컴 QA팀은 </span><span class="css-q3ktjb">Simplicity</span><span class="css-1kxrhf3">를 무기로 품질과 속도를 동시에 높이는 실험을 이어갈 예정이에요.</span></span></span></p><p id="2b8a360d-33e3-8024-805e-ff7c9e7a53d9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2bca360d-33e3-8000-89b8-f19933e59003" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[토스 Next ML Challenge - 광고 클릭 예측(PCTR) ML 경진대회 출제 후기]]></title>
            <link>https://toss.tech/article/toss-next-ml-challenge</link>
            <guid>https://toss.tech/article/toss-next-ml-challenge</guid>
            <pubDate>Tue, 02 Dec 2025 02:06:00 GMT</pubDate>
            <description><![CDATA[토스의 첫 ML 경진대회, Next ML Challenge의 출제 비하인드 스토리와 참가자 분들의 문제 해결 방식을 공유합니다.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2b7a360d-33e3-8058-8afa-ceaaa5131ab3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요. 토스 광고 플랫폼에서 ML Engineer로 일하고 있는 박재휘입니다.</span></span></span></p><p id="2b7a360d-33e3-805f-a72f-e8dbe7d1750b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">지난 9월부터 10월까지 토스와 데이콘이 함께 </span><a target="_blank" rel="noreferrer noopener" class="css-iynyr0" href="https://dacon.io/competitions/official/236575/overview/description">&#x27;Toss Next ML Challenge&#x27;</a><span class="css-1kxrhf3">를 개최했습니다. 저는 이번 대회에 출제 위원으로 참여했는데요, 문제를 기획하고 준비하면서 느꼈던 경험과 참가자분들의 신선한 문제 해결 방식을 공유하고 싶어 이렇게 글을 쓰게 되었습니다.</span></span></span></p><p id="2bca360d-33e3-8050-bbe0-f14b8e000260" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-8084-8a3d-fc8718bead53" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">왜 Toss Next ML Challenge를 열었나요?</span></span></span></h3><p id="2b7a360d-33e3-80e0-9a9c-d4d65c403f05" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스는 ML 기술을 통해 예측의 정확도와 의사결정의 수준을 높여가고 있습니다. 특히 광고 도메인에서는 머신러닝이 핵심 기술로 자리잡고 있죠. 이런 배경에서 토스는 ML 엔지니어들이 현업에서 풀고 있는 실제 기술 문제를 공개하고, 우수 인재를 발굴하기 위해 Toss Next ML Challenge를 개최했습니다.</span></span></span></p><p id="2b7a360d-33e3-80af-ac0d-e11b2eb87697" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이번 첫 챌린지의 주제는 &#x27;광고 클릭 예측(Click-Through Rate, CTR) 모델 개발&#x27;이었습니다. 실제 토스 앱 내 광고 데이터를 활용해 가상의 사용자가 어떤 광고를 클릭할 것인지에 대한 확률을 빠르고 정확하게 예상하는 ML 알고리즘을 만드는 것이 대회의 핵심이었어요.</span></span></span></p><p id="2b7a360d-33e3-8046-84ba-d530d3cca01e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">대회는 예선과 본선 두 단계로 진행되었습니다. 9월 8일부터 10월 13일까지의 예선을 거쳐 상위 30팀이 본선에 진출했고, 최종적으로 총 1,000만 원의 상금과 함께 본선 진출 팀에게는 토스 채용 시 서류 전형 면제 혜택이 주어졌습니다. 처음 진행해보는 ML 경진대회라 참가자가 많지 않으면 어떡하지 걱정했었는데, 무려 2,600명이 넘는 분들이 참가해 주셔서 데이콘에서 진행한 대회 중 역대급 참가자가 몰린 대회가 되었어요.</span></span></span></p><p id="2bca360d-33e3-8092-9fad-d5eb1c45ace3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-80c8-a435-f47f4cc0d8cf" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Toss Next ML Challenge </span><a target="_blank" rel="noreferrer noopener" class="css-iynyr0" href="https://dacon.io/competitions/official/236575/overview/description">문제</a></span></span></h3><p id="2bca360d-33e3-80e6-93b7-d5d6e744f4f1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이번 Toss Next ML Challenge의 문제는 실제 토스 앱 내에서 노출된 디스플레이 광고의 노출과 클릭 로그를 바탕으로 주어진 조건의 광고 클릭 확률을 예측하는 머신러닝 모델을 설계하는 것이었어요.</span></span></span></p><p id="2bca360d-33e3-80e8-aff7-c5fb3896f470" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">제공된 데이터셋에는 약 1,070만 건의 트레이닝 샘플이 포함되어 있고, 성별, 연령대, 광고 지면 ID, 시간, 과거 인기 정보(History) 등 다양한 피처가 있었습니다. 다만, 피처는 익명화되어 있어 ‘무엇을 의미하는지’ 공개되지 않기 때문에 직접적인 의미 해석이 어렵고, 이는 Feature Engineering 및 해석 가능한 모델 설계에 제약이 될 수도 있었어요.</span></span></span></p><p id="2bca360d-33e3-80f4-b148-fdc7ce5d859b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">추가로 실제 서비스 환경에서 ‘실시간 서빙 가능’해야한다는 가점 사항도 있었습니다. 즉, 학습된 모델은 빠르고 가볍게 추론(Inference)되어야 하며, 여러 광고 지면(다양한 Inventory)과 사용자 특성을 포괄해야하므로 피처 상호작용, 희소성(Sparsity), 과적합 방지, 그리고 효율적인 Serving 구조 설계 등 문제를 풀이하며 현실적인 ML 시스템 설계를 직접 풀어볼 수 있었어요.</span></span></span></p><p id="2bca360d-33e3-80a7-992e-ceac33c063bc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-801e-b5b7-da66d3ee7978" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문제 설계 과정: 실무를 문제로 만들기</span></span></span></h3><p id="2b7a360d-33e3-803b-97d3-e11b1a0623f8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스 내부에는 분석할 수 있는 데이터가 정말 많아서, 다양한 원천의 대규모 데이터를 피처로 만드는 Feature Engineering도 필수적인 역량입니다. 그래서 Data Engineering 역량까지도 해커톤에서 살펴볼 수 있도록 가급적 많은 데이터를 준비하고 싶었습니다.</span></span></span></p><p id="2b7a360d-33e3-80c2-b92b-f7bd9c21e067" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">처음 기획했던 데이터 구성은 아래와 같았습니다:</span></span></span></p><aside id="2b8a360d-33e3-808a-a8e6-cfdca580c33f" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b7a360d-33e3-8048-974a-e96f7e94192c" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">광고 도메인의 가장 대표적인 ML 문제인 클릭 예측을 메인 주제로 선정</span></span></span></li><li id="2b7a360d-33e3-8060-85ef-e2bdab3d5cad" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">메인 데이터 20억 건 이상</span></span></span></li><li id="2b7a360d-33e3-8055-a9a9-e3593ba6c614" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">여기에 결합할 수 있는 10개 이상의 로그 및 디멘션 테이블 제공</span></span></span></li></ul></div></aside><p id="2b8a360d-33e3-80f0-8b8f-e3058b9afa18" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-80eb-babe-f67404b757e6" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예상치 못한 난관: 데이터 익명화</span></span></span></h3><p id="2b7a360d-33e3-8001-bb99-ccb840200d15" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그런데 해커톤을 실제 준비하는 과정에서 다수의 테이블을 외부에 반출할 수 있는 방법을 찾지 못했어요.</span></span></span></p><p id="2b7a360d-33e3-80f3-b767-c415e65346ad" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">해커톤의 데이터는 누구나 자유롭게 다운받을 수 있기 때문에 데이터 익명처리가 필요합니다. 다수의 테이블을 각각 익명처리하는 경우, 메인 데이터에 다른 데이터를 Join하며 피처를 생성하는 작업이 불가능해진다는 문제가 있습니다.</span></span></span></p><p id="2b7a360d-33e3-801e-87f0-d3e0772451b8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 결국 해커톤 참여자분들께 제공하려던 Feature Engineering의 재미는 포기할 수밖에 없었고, 기본적인 Feature Engineering을 저희가 직접 수행하여 한 개의 정형 테이블로 문제용 데이터를 구성했습니다.</span></span></span></p><p id="2b8a360d-33e3-8006-bdfd-c6f5d079ba17" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-8055-8aa8-ff63532ad700" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">최종 데이터셋: 익명화와 난이도 사이에서</span></span></span></h3><p id="2b7a360d-33e3-8001-9c7c-d7c098622f6f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">최종 문제용 데이터셋은 이렇게 구성했습니다:</span></span></span></p><aside id="2b8a360d-33e3-8062-a737-d530fe450959" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b7a360d-33e3-804c-9e02-dce1e3056e5b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">모든 피처의 실제 의미를 알 수 없도록 이름을 임의로 변경</span></span></span></li><li id="2b7a360d-33e3-80bc-b49b-e3504715266e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">피처 값들도 임의의 계수로 선형변환</span></span></span></li><li id="2b7a360d-33e3-8066-9fb4-fa81d5edc7eb" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Encoding 처리를 한 피처들도 encoding 여부 혹은 encoding된 값의 의미를 공개하지 않음</span></span></span></li></ul></div></aside><p id="2b7a360d-33e3-80d3-9416-f0df166f3771" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">다만 이렇게만 준비할 경우 문제가 너무 평이할 것으로 우려하여 </span><span class="css-q3ktjb">Sequence 피처 한 개는 최대한 처리하지 않고 데이터셋에 포함</span><span class="css-1kxrhf3">시켰습니다. 해커톤이라면 마땅히 챌린징한 요소가 있어야 하는데, 마지막에 추가한 Sequence 피처가 그 역할을 해주지 않을까 기대했어요.</span></span></span></p><p id="2b7a360d-33e3-805c-a982-d96fa3dada17" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실제로 해커톤 게시판에 해당 피처 가공에 대한 어려움을 말씀하시는 글들이 보이거나, 그 피처를 잘 가공한 팀들이 리더보드 우수 팀으로 등장하는 모습을 보며 다행히 기획 의도가 잘 반영됐다는 점을 확인할 수 있었습니다.</span></span></span></p><p id="2b8a360d-33e3-802e-a66c-e8b8220a1cf4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-804d-bb72-ed80b614ef70" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">출제자의 기대와 실제</span></span></span></h3><p id="2b7a360d-33e3-8069-b951-fd4cdeec43c7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문제를 출제할 때는 데이터 내 각 피처의 의미를 공개할 수 없어서 참가자분들이 피처 엔지니어링보다는 </span><span class="css-q3ktjb">모델 설계에 집중</span><span class="css-1kxrhf3">할 것으로 예상했습니다. 다만 시계열 피처가 있기 때문에 시계열 데이터를 처리할 수 있는 모듈을 쓰시지 않을까 정도를 기대했어요. 그리고 혹시나 경진대회에서의 좋은 아이디어를 실제 적용할 수도 있기에 </span><span class="css-q3ktjb">실무 적용 가능성을 고려하는 접근법</span><span class="css-1kxrhf3">이 있었으면 하는 기대도 있었습니다.</span></span></span></p><figure id="2b8a360d-33e3-80bd-bb51-f2eeeb012ffc" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/106bbd5e-d423-46e4-8b01-d0bdc0846a2e/image.png" alt="" class="css-1pgssrp"/><figcaption class="css-wgpbp3"><span class="css-jfs1hr">예상과 가장 유사한 아키텍처, 출처: aimi 팀 모델개발보고서</span></figcaption></figure><h3 id="2b7a360d-33e3-80bc-825f-ee1c5127e328" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">참가자들의 열정: 숫자로 보는 대회</span></span></span></h3><p id="2b7a360d-33e3-8020-9fde-dcd197d89516" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">해커톤 제출 기한이 지나고 리더보드 상위 30팀은 보고서를 제출해 주셨습니다. 보고서에는 리더보드 상위 팀들 답게 참여자분들의 열의와 창의성이 가득했어요.</span></span></span></p><h3 id="2b7a360d-33e3-8060-9fee-f566a19e86e6" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">간단한 통계</span></span></span></h3><p id="2b7a360d-33e3-8087-a3b9-fb130816694e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">보고서 제출 30팀의 경우:</span></span></span></p><ul class="css-uswsmm"><li id="2b7a360d-33e3-805f-91dc-c165375f51a8" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">모든 팀이 Boosting Tree 계열의 모델을 활용</span><span class="css-1kxrhf3">했습니다.</span></span></span></li><li id="2b7a360d-33e3-800a-bf0d-c75e015173f4" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Deep Learning의 경우 미사용한 팀도 존재했습니다.</span></span></span></li></ul><figure id="2b7a360d-33e3-800b-9a46-c2881198a17a" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/693bb65a-6928-45ab-a2b7-999f68f26422/inner_1202_tech_qa.jpg" alt="" class="css-1pgssrp"/></figure><h3 id="2b7a360d-33e3-8034-9ca0-f3f242a596d4" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">인상 깊었던 세 가지 숫자</span></span></span></h3><p id="2b7a360d-33e3-807f-9395-cff0563774fd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">전체 보고서를 심사하며 인상 깊었던 숫자 세 개를 선정했습니다.</span></span></span></p><p id="2b7a360d-33e3-802e-bba5-d0f8d68b9363" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1️⃣ 30페이지</span></span></span></p><p id="2b7a360d-33e3-809a-b741-f9abcea8a8cd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가장 먼저 30페이지의 보고서였습니다! 대부분이 문자로 꽉 채워진 30페이지의 보고서는 심사위원들을 당황시키기 충분했고, 다른 팀들도 사실 적지 않은 분량으로 한 달간의 여정을 요약하여 정리해 주셨어요.</span></span></span></p><p id="2b8a360d-33e3-80d8-b94c-dd4f7a1f29f4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b7a360d-33e3-8086-9a1e-f85d9d3bbdac" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2️⃣ 260개</span></span></span></p><p id="2b7a360d-33e3-8049-bf17-c568be48df1f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">두 번째로는 260개의 모델을 한 번에 활용하는 솔루션이었습니다. PCTR 추론은 실시간 서빙이 필요하기에 적당한 앙상블을 해야 한다고 생각하고 있었는데, 적당함에 대한 새로운 시각을 제안해 주신 것 같아서 흥미로웠습니다 😊</span></span></span></p><p id="2b8a360d-33e3-8041-bcc0-dfa3ba3b7186" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b7a360d-33e3-808f-8cc5-d7b135241576" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">3️⃣ 37개</span></span></span></p><p id="2b7a360d-33e3-8067-a165-faf6bb013bde" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">마지막으로는 37이라는 숫자를 선정했습니다. Sequence Feature 한 개로 얼마나 많은 파생 피처를 만들 수 있는지, 문제 해결에 대한 집요함을 느낄 수 있는 부분이었습니다.</span></span></span></p><p id="2b7a360d-33e3-8037-9e5c-eb2fc4119e6d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들면, 시퀀스의 총 길이, 고유 토큰 개수부터 시퀀스 내 전이 결속도까지 총 37가지의 파생 변수를 생성하는 집계 방식을 고안하셨고, 한 가지 집계 방법에서 1~N개의 피처가 만들어지기에 꽤나 많은 파생변수가 최종적으로 탄생했습니다. 실무에서도 피처 한 개에 대해 이 정도까지 딥다이브하지 않는 경우가 많기에 정말 흥미로운 부분이었습니다.</span></span></span></p><p id="2b8a360d-33e3-8069-8c54-c741083e8338" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-802a-a37e-d578dc5a3a45" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">성과 요약: 무엇이 리더보드 상위를 만들었나</span></span></span></h3><p id="2b7a360d-33e3-8050-ac21-d89b804e3abc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">전체 보고서를 성과 측면에서 요약하면 다음과 같습니다.</span></span></span></p><aside id="2b8a360d-33e3-8092-83dc-da9b310d9091" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1. [Deep Learning &amp; Boosting Tree] Ensemble 강세</span></span></span></h4><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b7a360d-33e3-80ba-a6b2-dfefeca6b039" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">리더보드 최상위권에는 Boosting tree 계열만 사용한 팀은 없었습니다.</span></span></span></li><li id="2b7a360d-33e3-8055-99b5-e06a37c7f3e3" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Fixed weight ensemble이 아닌 Logit 또는 weighted ensemble을 주로 사용했습니다.</span></span></span></li></ul><p id="2b7a360d-33e3-8097-9edb-db40d11ba84d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2. EDA &amp; Feature Engineering</span></span></span></p><ul class="css-uswsmm"><li id="2b7a360d-33e3-80f2-97e2-c6f259d64604" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">데이터 기반으로 가설을 설정하고 이를 검증하며 모델을 개선했습니다.</span></span></span></li><li id="2b7a360d-33e3-806d-9951-e01f5336380d" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">모델의 구조뿐만 아니라 정량적 피처 엔지니어링에도 정성을 쏟았습니다.</span></span></span></li></ul><p id="2b7a360d-33e3-80f3-835b-de1a7bd1afb4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">3. Validation Strategy</span></span></span></p><ul class="css-uswsmm"><li id="2b7a360d-33e3-8078-a999-e2b8625803f9" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">리더보드와 align되는 검증 데이터를 논리적으로 잘 구성하여 오프라인 실험 결과를 믿고 리더보드 성과를 개선하였습니다.</span></span></span></li></ul><p id="2b7a360d-33e3-8048-b294-fd2f729e1fed" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">4. Sequence Feature</span></span></span></p><ul class="css-uswsmm"><li id="2b7a360d-33e3-80e4-8259-d8806d34bc2a" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">처리하기 부담스러운 속성의 피처지만, 이를 잘 활용해야 리더보드 상위권에 올라올 수 있었습니다.</span></span></span></li></ul></div></aside><p id="2b8a360d-33e3-804c-9fc3-e67d06ec3dbd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-8024-a649-e954b4c708cd" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">리더보드 상위팀을 위한 오프라인 시상식</span></span></span></h3><figure id="2b8a360d-33e3-80f7-80c7-dc64a029ede1" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/b0e33310-1422-4156-b66a-e69b02fb7db4/1764054444347.jpeg" alt="" class="css-1pgssrp"/></figure><p id="2b8a360d-33e3-80c1-ac12-d4393c701eb5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">지난 11월 6일 저녁, Next ML Challenge의 리더보드 상위 30팀을 토스 오피스로 모시고 오프라인 시상식을 진행했습니다. 토스 ML Chapter Lead이신 찬주님이 토스 ML Chapter의 비전에 대해 설명해 주시는 시간을 마련했고, 뒤이어 제가 출제위원 대표로 출제 비하인드에 대해 말씀 드렸어요.</span></span></span></p><div class="css-184j9if"><div class="css-31l7gp"><figure id="2b8a360d-33e3-80f1-bca6-dd9be8bc081a" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/adbd020c-ac18-4138-a715-93375bee42da/1764054441846.jpeg" alt="" class="css-1pgssrp"/><figcaption class="css-wgpbp3"><span class="css-jfs1hr">1위. Merlin XGBoost 팀</span></figcaption></figure></div><div class="css-31l7gp"><figure id="2b8a360d-33e3-80aa-ae8b-dac2ff2760af" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/e28a5b2d-1708-4675-8533-b2dd3fd669a2/1764054452759.jpeg" alt="" class="css-1pgssrp"/><figcaption class="css-wgpbp3"><span class="css-jfs1hr">2위. 상승장 팀</span></figcaption></figure></div><div class="css-31l7gp"><figure id="2b8a360d-33e3-80df-befd-cffd4bac5dd3" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/85022635-3325-4eed-8fd0-bc4db116310c/1764054458820.jpeg" alt="" class="css-1pgssrp"/><figcaption class="css-wgpbp3"><span class="css-jfs1hr">3위. 개인출전 김정무님</span></figcaption></figure></div></div><p id="2b8a360d-33e3-8021-9681-e260f0487882" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이어진 시상식에서는 토스 Head of Data 홍수님이 오셔서 직접 상금 수상자 분들을 축하해주셨어요. 수상소감을 여쭤보았을 때 모든 분이 ‘재밌고 뜻깊은 대회를 열어줘서 감사하다’는 말씀을 해주셔서, 출제위원으로서 매우 뿌듯했답니다.</span></span></span></p><p id="2b8a360d-33e3-8091-99d0-ffd464334d23" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스 현업 ML Engineer 분들과 함께 네트워킹도 진행했습니다. 참석하신 모든 분들이 토스 ML Chapter가 실제로 어떻게 일하는지 많이들 궁금해 하셔서, 정말 열띤 분위기 속에 많은 대화가 오갔어요. 온라인 경진대회에서 참가자 아이디로만 봤던 분들과 실제로 만나서 대화해보니 무척 감회가 새로웠습니다.</span></span></span></p><p id="2b8a360d-33e3-80f1-b525-ff5c369a433d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-80d4-9e59-f25cb5f7f691" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">마치며</span></span></span></h3><p id="2b7a360d-33e3-8076-a746-e2ef6f8f4e15" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">대회를 준비하고 또 평가하며 참여하신 분들의 뜨거운 열정, 간절함, 순수한 즐거움 등의 감정을 저도 함께 느꼈던 것 같아요.</span></span></span></p><p id="2b7a360d-33e3-8010-86f0-ec1e98b93f1e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실무에서는 데이터의 의미를 알고 있기에 도메인 지식을 활용한 피처 엔지니어링이 가능하지만, 이번 대회에서는 그런 정보 없이도 참가자분들이 데이터 분석과 실험을 통해 놀라운 성과를 만들어 내셨습니다. 특히 Sequence 피처 하나에서 37개의 파생 변수를 만들어내신 집요함과, 260개의 모델을 앙상블하는 창의성은 출제자로서도 많은 영감을 받았어요.</span></span></span></p><p id="2b7a360d-33e3-8053-981d-c247292979ca" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">개인적으로는 참여하신 모든 분들께서 이번 대회를 계기로 원하시는 바를 이루는 것에 도움이 되셨길 바랍니다. 토스는 앞으로도 ML 엔지니어들과 함께 성장하고, 실제 비즈니스 문제를 함께 풀어나갈 수 있는 기회를 지속적으로 만들어 나갈 예정입니다.</span></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[레거시 결제 원장을 확장 가능한 시스템으로]]></title>
            <link>https://toss.tech/article/payments-legacy-5</link>
            <guid>https://toss.tech/article/payments-legacy-5</guid>
            <pubDate>Mon, 01 Dec 2025 09:01:00 GMT</pubDate>
            <description><![CDATA[약 20년간 운영되어 온 레거시 결제 시스템을 어떻게 확장성과 회복 탄력성을 갖춘 구조로 전환해 나갔는지, 그 과정에서 마주한 장애들과 해결 경험을 공유합니다.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2b1a360d-33e3-8006-aa8d-c50996425e46" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요, 토스페이먼츠 Server Developer 박순현, 양권성입니다.</span></span></span></p><p id="2b3a360d-33e3-8027-bcc0-f215095a2259" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 온라인 거래의 중심에 있습니다. 사용자가 쇼핑몰에서 ‘결제하기’를 누르는 순간, 보이지 않는 곳에서 수많은 결제가 안정적으로 처리됩니다. 하지만 우리의 시작은 완전히 새로웠던 것이 아닙니다. 2020년 8월, 기존 PG 사업을 인수하면서 토스페이먼츠가 출범했습니다. 이전 시스템은 20년 이상 운영된 레거시 구조였고, 우리가 개선해야 할 기술적 과제는 만만치 않았습니다.</span></span></span></p><p id="2b3a360d-33e3-80cd-ba28-edb5563c8aec" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 과정에서 가장 복잡하면서도 핵심이었던 해결 과제는 </span><span class="css-q3ktjb">결제 원장(Ledger)</span><span class="css-1kxrhf3"> — 결제의 모든 내역이 저장되는 중심 시스템이었습니다.</span></span></span></p><p id="2b1a360d-33e3-8086-ad2e-c722eea09974" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b1a360d-33e3-807c-9d12-ed7b03a2270d" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결제 원장의 역할과 한계</span></span></span></h3><figure id="2b1a360d-33e3-8007-aadd-f49d6359f636" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/e09115ca-8646-4dd4-8a43-09eedca91170/image.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-801a-a956-eea21dfbd9ac" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">‘원장’은 회계 용어에서 유래한 개념으로, 모든 거래 내역을 기록하는 장부를 의미합니다. 결제 원장은 고객의 결제, 취소, 환불 내역이 기록되는 핵심 테이블로, 정산과 회계의 기초 데이터로 사용됩니다. 하지만 이 원장이 오랜 기간 운영되며 여러 문제가 누적되었습니다.</span></span></span></p><p id="2b3a360d-33e3-8005-ad55-ebf351c15461" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-8044-a75e-d3aa6b2d9410" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">문제 1. 일관성 없는 데이터 구조</span></span></span></p><p id="2b1a360d-33e3-803e-8286-e1fc6dafe395" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">레거시 원장은 결제수단별로 테이블 구조가 모두 달랐습니다. 카드 결제의 경우 전체 취소와 부분 취소를 서로 다른 테이블에 저장했고, 계좌이체 결제는 하나의 테이블에 모든 취소 내역을 기록했습니다.</span></span></span></p><p id="2b1a360d-33e3-800a-8c3e-d75064958e20" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들어 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">REFUND</span></code><span class="css-1kxrhf3">라는 테이블 이름은 모든 결제수단의 취소 내역이 들어갈 것처럼 보였지만, 실제로는 </span><span class="css-q3ktjb">계좌이체 취소만 저장</span><span class="css-1kxrhf3">하고 있었습니다. 이런 불일치 구조는 신규 입사자의 온보딩을 어렵게 만들었고, 비즈니스 로직 변경 시 유지보수 난이도와 장애 위험을 높였습니다.</span></span></span></p><p id="2b3a360d-33e3-80d7-b929-deeec46fec81" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-808f-826a-dfb5336e313a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">문제 2. 도메인 간 강한 결합</span></span></span></p><p id="2b1a360d-33e3-8087-8a13-f0dfaee404cf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결제, 정산, 취소, 회계 등 여러 도메인이 동일한 원장 테이블을 공유하고 있었습니다. 또한 같은 컬럼이 도메인별로 서로 다른 의미로 사용되기도 했습니다.</span></span></span></p><figure id="2b1a360d-33e3-80ae-843d-dbbfb19b38a0" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/8fafcfe2-e13a-47be-8b2b-db4b6c086c49/image.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-800b-a474-d6a9d87464c9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 구조에서는 컬럼 하나를 수정할 때마다 여러 팀이 영향도를 분석해야 했고, 결국 서비스 확장 속도와 유연성이 심각하게 저하되었습니다.</span></span></span></p><p id="2b3a360d-33e3-80f5-a72c-c97c89ffe3a5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-8034-8f88-cbf38903f4ee" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">문제 3. 확장성을 가로막는 구조적 한계</span></span></span></p><p id="2b1a360d-33e3-80bf-993e-e6e0be674b6e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기존 시스템은 결제와 결제수단이 </span><span class="css-q3ktjb">1:1 관계</span><span class="css-1kxrhf3">로 묶여 있었습니다. 즉, “한 결제에 여러 결제수단을 사용하는 구조”를 지원할 수 없었습니다.</span></span></span></p><figure id="2b1a360d-33e3-805f-80cc-f8d4a44d20ee" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/1056aa61-1c58-4945-8737-e6cc7fed7d5e/image.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-80bf-8549-fbd88b7f3b30" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들어 하나의 주문을 카드 + 계좌이체로 나누어 결제하거나, 여러 사용자가 금액을 나누어 내는 </span><span class="css-q3ktjb">더치페이(Dutch pay)</span><span class="css-1kxrhf3"> 모델을 구현할 수 없었습니다. 이 구조를 유지한 채로는 비즈니스 확장이 불가능했습니다.</span></span></span></p><p id="2b1a360d-33e3-8050-9874-d2430de23ca7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b1a360d-33e3-8041-b6cd-e1b848b8ff1a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">새로운 시작: MySQL 기반 원장 시스템 구축</span></span></span></h3><p id="2b1a360d-33e3-8027-893d-c4ae5908bd76" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">우리는 단순히 기존 Oracle DB에 테이블을 추가하는 대신, </span><span class="css-q3ktjb">MySQL 기반의 신규 원장을 독립적으로 구축하기로 결정</span><span class="css-1kxrhf3">했습니다.</span></span></span></p><p id="2b1a360d-33e3-80af-83b3-c17cf6d11151" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">MySQL을 선택한 이유</span></span></span></p><aside id="2b3a360d-33e3-8099-83ab-d1453504cbc2" class="css-nv7vyi"><div class="css-1vn47db"><ol class="css-hokoge"><li id="2b1a360d-33e3-800d-bbce-d02512148cb7" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">독립적인 인프라 확보</span></span></span><div class="css-1vn47db"><p id="2b1a360d-33e3-80b6-859d-cb6684429e50" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Oracle DB에는 여러 팀의 데이터가 섞여 있어, 다른 팀의 배포나 작업이 결제 서비스 장애로 이어질 위험이 있었습니다.</span></span></span></p><p id="2b1a360d-33e3-8058-bb3e-e3d3b4cd340f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결제팀만의 전용 DB 인프라를 확보해 이 리스크를 제거했습니다.</span></span></span></p></div></li><li id="2b1a360d-33e3-80c6-af88-f245d98f4b6e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">개발 스택의 일원화</span></span></span><div class="css-1vn47db"><p id="2b1a360d-33e3-80de-9ce7-fd122d03e85b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Oracle + MyBatis 기반 구조는 XML 쿼리 관리와 디버깅이 복잡했습니다.</span></span></span></p><p id="2b1a360d-33e3-80ec-8215-e819bfcc37d8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">반면 토스페이먼츠의 주요 서비스는 MySQL + JPA를 중심으로 구성되어 있었고, JPA Entity 기반의 접근은 데이터 흐름을 파악하기 훨씬 직관적이었습니다.</span></span></span></p></div></li><li id="2b1a360d-33e3-8062-915b-ec6bae4ff277" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">실험과 확장의 자유로움</span></span></span><div class="css-1vn47db"><p id="2b1a360d-33e3-800f-a238-cb5635264ed5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">MySQL은 오픈소스 기반이라 내부 실험 환경을 빠르게 구성할 수 있었고, 새로운 기술 적용에도 제약이 적었습니다.</span></span></span></p></div></li></ol></div></aside><p id="2b3a360d-33e3-809d-a870-d25d816eecf9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b1a360d-33e3-808e-81f3-f1ced8a03b58" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">신규 원장 설계: 세 가지 핵심 전략</span></span></span></h3><p id="2b1a360d-33e3-8025-8901-c07b1d39a60c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1️⃣ 데이터 구조의 일관성 확보</span></span></span></p><p id="2b1a360d-33e3-80f6-bbbf-e8c6c4db446e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">모든 결제 승인 내역을 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">approve</span></code><span class="css-1kxrhf3"> 공통 테이블에 저장하고, 결제수단별 추가 정보는 개별 테이블에 나누어 저장했습니다.</span></span></span></p><figure id="2b1a360d-33e3-8093-9e1f-dd8ea3c5ea7b" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/d235227a-c7fc-40a3-bef2-9a10ebf902e4/image.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-800b-a1c0-de692d74ce42" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">또한 기존에는 취소 시 데이터를 UPDATE 하던 구조를 </span><span class="css-q3ktjb">INSERT-only 원칙</span><span class="css-1kxrhf3">으로 변경했습니다. 이로써 데이터의 불변성을 보장하고, 데드락을 방지하며, 과거 히스토리 추적이 용이해졌습니다.</span></span></span></p><p id="2b1a360d-33e3-805a-ba93-ec60c0595ac8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2️⃣ 도메인 간 결합도 낮추기</span></span></span></p><p id="2b1a360d-33e3-80ca-b475-c30b9fd4a003" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">신규 원장은 각 도메인이 직접 DB를 조회하지 않도록 설계했습니다.</span></span></span></p><figure id="2b1a360d-33e3-80e9-9c74-ef482431c45c" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/5b0da0bf-ce8f-438b-b0cb-2e2b85964d0d/image.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-8063-ae47-c91f4f67f200" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">또 결제가 발생하면 </span><span class="css-q3ktjb">Kafka 이벤트를 발행하고</span><span class="css-1kxrhf3">, 각 도메인은 해당 이벤트를 구독하여 자신의 로직을 수행합니다.</span></span></span></p><figure id="2b1a360d-33e3-8004-a10a-efd271b31c4f" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/1f2db00f-7cef-41c6-8055-5960c831736d/image.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-8098-bb2b-ed5e3ea7962a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이벤트 스트림은 DB의 최신 상태와 동일한 불변 데이터를 전달하며, 조회 없이도 필요한 처리가 가능했습니다. 덕분에 도메인 간 직접적인 의존성이 제거되고 팀별 병렬 개발이 가능해졌습니다.</span></span></span></p><p id="2b1a360d-33e3-800a-8b3c-c87fa3a2ea99" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">3️⃣ 결제와 승인(Approval)의 분리</span></span></span></p><p id="2b1a360d-33e3-8005-a95b-d7f9949c82ce" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기존에는 결제와 승인 개념이 혼재되어 있었습니다. 신규 시스템에서는 ‘결제’는 수단이 확정되지 않은 상태, ‘승인’은 실제 수단이 결정된 상태로 분리했습니다.</span></span></span></p><figure id="2b1a360d-33e3-8018-9196-da584bf6583a" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/5da2c4bb-6073-469d-8e8d-febec5d3ba2d/image.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-808c-be9c-ecb0ccfb3e9a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이제 하나의 결제에 여러 결제수단이 연결될 수 있으며, 복합결제나 더치페이 같은 시나리오도 유연하게 지원할 수 있게 되었습니다.</span></span></span></p><p id="2b1a360d-33e3-80b2-bd7c-ef655570c8cc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b1a360d-33e3-8001-8f63-ce3e80237993" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안전한 마이그레이션 전략</span></span></span></h3><p id="2b1a360d-33e3-80e2-becc-f3fa599f29f3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1️⃣ 비동기 방식의 점진적 적재</span></span></span></p><p id="2b1a360d-33e3-80a1-97fd-f0e0751a9621" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">신규 원장 전환의 첫 단계는 </span><span class="css-q3ktjb">서비스 무중단</span><span class="css-1kxrhf3">이었습니다. 기존 원장에 먼저 데이터를 저장한 뒤, 신규 원장에는 비동기 방식으로 적재했습니다.</span></span></span></p><figure id="2b1a360d-33e3-80d3-aac3-d9938d30da64" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/8e4d0a1d-7c08-48a9-811c-627c6b02bd48/image.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-8042-9c9a-d0dff94acb30" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실패하더라도 서비스 장애로 이어지지 않도록 예외를 처리하고, 모든 실패 케이스를 모니터링 및 알림 시스템으로 관리했습니다.</span></span></span></p><p id="2b3a360d-33e3-8068-b81f-cc4dd9488285" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2️⃣ 리소스 관리와 튜닝</span></span></span></p><p id="2b1a360d-33e3-8085-ace1-e0997c359045" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">비동기 처리는 실서비스 서버에서 수행되므로, CPU·메모리 부담을 최소화해야 했습니다.</span></span></span></p><figure id="2b1a360d-33e3-8097-aceb-ef109a7c6fc4" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/377c9fb2-1762-4b3a-9dc9-e9bd97123c52/image.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-80cf-9210-cd927ecf3066" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">초기에는 ThreadPool을 작게 설정하고, 트래픽을 점진적으로 투입하면서 최적 값을 찾았습니다. ThreadPool이 포화될 경우 해당 작업을 과감히 버리고, 별도 검증 배치를 통해 데이터 누락을 보완하는 구조로 설계했습니다.</span></span></span></p><p id="2b3a360d-33e3-80c5-80bb-f0da8c74708a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">3️⃣ 데이터 정합성 검증</span></span></span></p><p id="2b1a360d-33e3-8033-ac99-e8aa5ee16b21" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">비동기 적재 과정에서 누락될 수 있는 데이터를 보정하기 위해 </span><span class="css-q3ktjb">RO(Read Only) DB 기반의 검증 배치</span><span class="css-1kxrhf3">를 구성했습니다. 매시 5분 간격으로 실행되어 복제 지연을 고려하면서 누락된 데이터를 재적재했습니다.</span></span></span></p><p id="2b1a360d-33e3-8049-b080-e0d2acb2423e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b1a360d-33e3-8097-8732-ddb48081af6c" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">대규모 마이그레이션의 도전</span></span></span></h3><p id="2b1a360d-33e3-80b8-ab90-e58590395c42" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실시간 신규 적재가 안정화된 뒤에는 기존 데이터를 옮겨야 했습니다. 이 과정은 단순한 데이터 복사가 아니라, 수억 건 단위의 INSERT가 동시에 발생하는 고부하 작업이었습니다.</span></span></span></p><p id="2b3a360d-33e3-805d-b8fb-e59fa2be599d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-8097-b5d8-f581138bb60b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">전용 서버 구성:
</span><span class="css-1kxrhf3">작업을 라이브 서버에서 함께 실행하게 되면, 아무리 비동기 처리라 하더라도 같은 컴퓨팅 리소스를 공유하게 되기 때문에, 예상하지 못한 영향을 줄 수 있어서 마이그레이션 서버를 별도로 배포해 실서비스 리소스와 분리했습니다.</span></span></span></p><p id="2b3a360d-33e3-8039-a51e-e88e14915bd9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">또</span><span class="css-q3ktjb"> </span><span class="css-1kxrhf3">RW DB는 AWS에서 하나의 AZ(Availability Zone)에 위치해 있고, 네트워크 지연을 최소화하기 위해 마이그레이션 서버도 같은 AZ에 배포했습니다.</span></span></span><span class="css-1vn47db"><figure id="2b1a360d-33e3-8048-9adc-f7da25a3c6aa" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/cd552f0b-93b4-45a6-af67-d2ebae23b36b/33x.png" alt="" class="css-1pgssrp"/></figure></span></p><p id="2b1a360d-33e3-80ca-b932-ff5c49c8756c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Bulk Insert 도입:
</span><span class="css-1kxrhf3">기존 단건 저장 방식을 개선해 대량 삽입이 가능하도록 저장 인터페이스를 재설계했습니다.</span></span></span></p><p id="2b3a360d-33e3-8082-ab7d-cc98f69314b6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-80f3-8495-f9dbc0ea2944" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">로컬 캐시 적용:
</span><span class="css-1kxrhf3">반복 조회가 필요한 데이터는 서버 메모리에 캐시하여 네트워크 I/O를 줄였습니다.</span></span></span></p><p id="2b3a360d-33e3-80ff-aea4-dc3724b93a54" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-8079-b24a-cf9e772168f8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">네트워크 대역폭 관리:
</span><span class="css-1kxrhf3">IDC(기존 DB)와 AWS(신규 DB) 간 트래픽을 모니터링하며, 다른 서비스에 영향을 주지 않도록 점진적으로 조정했습니다.</span></span></span></p><figure id="2b1a360d-33e3-80b0-9f7f-cef4e8de1df0" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/51cd40a2-f292-4f7c-8d57-e669d74c3279/43x.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-8077-812b-f5d372df93dc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 경험을 통해 단순 데이터 이관을 넘어, 이질적인 인프라 환경 간 데이터 흐름과 병목을 세밀하게 제어하는 노하우를 쌓을 수 있었습니다.</span></span></span></p><p id="2b1a360d-33e3-8013-b0ba-cc991537a578" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b1a360d-33e3-806e-be28-ce6f78ddaa01" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">운영의 현실 - 장애와 대응</span></span></span></h3><p id="2b1a360d-33e3-8020-9383-e4699c38874e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">시스템의 설계와 구현이 아무리 완벽해 보여도, </span><span class="css-q3ktjb">실제 운영 환경에서의 안정성</span><span class="css-1kxrhf3">은 전혀 다른 이야기입니다. 서비스가 실시간으로 수만 건의 거래를 처리하는 순간, 예측하지 못한 병목이나 실패는 언제든 발생할 수 있습니다.</span></span></span></p><p id="2b1a360d-33e3-8006-bda3-ec79ee56640b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">장애 발생: DB 부하 급증
</span><span class="css-1kxrhf3">어느 날, 관제센터로부터 “결제 서버의 응답이 지연되고 있으며, DB 부하가 비정상적으로 높습니다.” 이라는 알림을 받았습니다. 대시보드를 확인하니 MySQL에서 </span><span class="css-q3ktjb">wait 세션 수가 급증</span><span class="css-1kxrhf3">하고 있었습니다.</span></span></span></p><figure id="2b1a360d-33e3-80f4-bf4d-d0886834311e" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/182c354b-e714-410e-bd1b-15e06e8023a1/13x.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-8015-879a-e0443d2378ac" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">우선 MySQL 상위 쿼리 로그를 확인했습니다. 특정 SELECT 쿼리가 지속적으로 높은 CPU와 I/O 부하를 유발하고 있었고, 해당 쿼리는 바로 전날 신규 배포된 기능에서 추가된 것이었습니다.</span></span></span></p><p id="2b1a360d-33e3-807d-aa87-eddf6fdf75da" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-80cf-b087-f00a2bc05253" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">빠른 롤백과 즉시 대응
</span><span class="css-1kxrhf3">문제가 신규 배포된 코드에서 기인함을 확인하자마자 우리는 즉시 </span><span class="css-q3ktjb">이전 버전으로 롤백</span><span class="css-1kxrhf3">을 결정했습니다. 토스페이먼츠는 항상 최근 5개 배포 이미지(Docker Build)를 보관하기 때문에 별도의 빌드 과정 없이 즉시 재배포가 가능했습니다. 롤백 이후 DB 부하는 빠르게 정상화 되었습니다.</span></span></span></p><p id="2b1a360d-33e3-8067-92f7-dcf5ab7035d4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-803d-81f9-eb5c7d2f81d6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">원인 분석: 옵티마이저의 잘못된 판단</span></span></span></p><figure id="2b1a360d-33e3-80f1-8d61-e7da70c58274" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/7e5cfd69-ca0b-458d-a8e5-538ea875a125/23x.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-808d-a546-c5057f25fcb4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">해당 쿼리는 단순한 SELECT 문이었지만, 데이터가 쌓이기 시작하면서 옵티마이저가 의도하지 않은 실행 계획을 선택했습니다. 결국 인덱스를 사용하지 않고 테이블 전체를 스캔하는 </span><span class="css-q3ktjb">풀스캔(Full Scan)</span><span class="css-1kxrhf3"> 이 발생해 결제 승인 서버에 과도한 부하를 일으켰습니다.</span></span></span></p><p id="2b1a360d-33e3-80e6-95e7-e138b1719738" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 경험을 통해 신규 테이블을 설계하거나 기능을 추가할 때는 데이터 양이 증가한 상황에서의 쿼리 동작까지 반드시 고려해야 한다는 교훈을 얻었습니다. 이후 쿼리에 </span><span class="css-q3ktjb">힌트를 추가</span><span class="css-1kxrhf3">해 의도한 인덱스를 사용하도록 보완했습니다.</span></span></span></p><p id="2b3a360d-33e3-8083-9ab1-ef1f21d20a03" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b1a360d-33e3-806d-88e2-caef92120d93" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">장애를 통해 발견된 문제들</span></span></span></h3><p id="2b1a360d-33e3-8083-b487-cba59d736242" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이번 장애를 계기로 여러 연쇄적인 문제들이 함께 드러났는데, 대표적으로 다음 네 가지였습니다.</span></span></span></p><aside id="2b3a360d-33e3-80d9-bded-de15aeb8a38e" class="css-nv7vyi"><div class="css-1vn47db"><ol class="css-hokoge"><li id="2b1a360d-33e3-80d2-86fb-eb1024e9a9a9" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">신규 원장과 기존 원장 간 데이터 불일치</span></span></span></li><li id="2b1a360d-33e3-8000-82f3-fcfe808f5588" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">원천사(카드사, 은행 등)와의 데이터 불일치</span></span></span></li><li id="2b1a360d-33e3-80fd-8831-de97f04cbfa9" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가맹점과의 응답 불일치</span></span></span></li><li id="2b1a360d-33e3-80f4-a202-f8aefe54e954" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결제 이벤트 누락 문제</span></span></span></li></ol></div></aside><p id="2b1a360d-33e3-80f3-af3f-c5ea6ec5a420" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-80a1-b751-cf17773daf64" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">문제 1. 두 원장의 데이터 불일치</span></span></span></p><p id="2b1a360d-33e3-80ec-8060-e392157702cb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">DB 부하가 발생하면서 신규 원장에 일부 데이터가 정상적으로 적재되지 않았습니다.</span></span></span></p><p id="2b1a360d-33e3-8069-8eed-e8f105f25ed2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이로 인해 </span><span class="css-q3ktjb">기존 원장과 신규 원장의 데이터가 불일치</span><span class="css-1kxrhf3">하게 되었습니다. 이 문제는 멀티 데이터 소스를 운영하면서 언제든 두 저장소 간의 데이터는 틀어질 수 있음을 가정하고 있었어서, 승인 서버는 신규 원장이 메인 원장의 지위를 얻기 전까지 </span><span class="css-q3ktjb">정답지인 구원장을 기준으로 자동으로 보정을 하는 배치가 매 5분마다 수행</span><span class="css-1kxrhf3">되고 있었고, 해당 배치에서 불일치는 해소 되었습니다.</span></span></span></p><p id="2b1a360d-33e3-80d0-9b88-ddae48a80e16" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-805c-bfff-ebb729abaef6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">문제 2. 원천사와의 불일치 — 망취소(Network Cancellation)</span></span></span></p><p id="2b1a360d-33e3-8041-852b-faff8a4993d5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">내부 데이터 불일치 외에도, 외부 결제 원천사와의 상태 불일치도 발생했습니다.</span></span></span></p><figure id="2b1a360d-33e3-800e-9540-e27417ffa3e6" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/c70a6901-c5d5-46f4-a083-bc514da9c1ad/53x.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-80fe-a2f6-df196aca3bbd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들어 결제 서버가 카드사로 승인 요청을 보냈지만 네트워크 타임아웃으로 실패한 경우, 카드사에서는 결제가 완료되었지만 토스페이먼츠에서는 실패로 남는 상황이 생길 수 있습니다.</span></span></span></p><figure id="2b1a360d-33e3-801c-b00c-dce7889b0549" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/4df04b0a-e01b-4568-bd87-c4e983b8d346/63x.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-80b1-880a-d92336bac071" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 상황을 대비해, 결제 서버는 타임아웃된 거래건을 별도로 저장하고 원천사로 취소 요청을 보내어 상태를 일치시키는 </span><span class="css-q3ktjb">망취소(Network Cancellation)</span><span class="css-1kxrhf3"> 로직을 운영하고 있었습니다.</span></span></span></p><p id="2b1a360d-33e3-800c-958d-e419e2a38d76" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 과정을 통해 카드사, 은행 등 외부 시스템과의 데이터 정합성을 유지했습니다.</span></span></span></p><p id="2b1a360d-33e3-801c-9d5f-cf88872072d1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-8045-af8e-e7307a3d28d5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">문제 3. 가맹점과의 응답 불일치</span></span></span></p><p id="2b1a360d-33e3-80a6-9514-cab2fe046b0e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가맹점 측에서 수신한 결제 응답과 토스페이먼츠의 실제 처리 결과가 일치하지 않는 사례도 발생했습니다. MSA 기반 구조에서 각 서버의 </span><span class="css-q3ktjb">타임아웃 설정이 불일치</span><span class="css-1kxrhf3">했던 것이 원인이었습니다.</span></span></span></p><figure id="2b1a360d-33e3-8023-8369-d06b4d33b501" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/579f4257-5a86-4b03-af4a-5032f541d717/73x.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-809c-913d-ddaf86d03d8c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들어 PX 서버와 승인 서버 간 타임아웃이 다를 경우, 승인 서버가 정상적으로 결제를 완료하더라도 앞단의 서버는 이미 타임아웃 실패를 반환할 수 있습니다.</span></span></span></p><figure id="2b1a360d-33e3-80e5-832e-c94d683ce970" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/ad677a49-97fc-4354-82db-2d046757a883/83x.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-80ed-998d-f14c3f8bc71e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 문제를 해결하기 위해 승인 서버의 최대 처리 시간을 계산하고, 모든 상위 서버의 타임아웃을 이에 맞추어 재설정하였고, 결제 요청 체인 전체의 타임아웃을 일관되게 맞추면서 가맹점과의 불일치를 해소 하였습니다.</span></span></span></p><p id="2b1a360d-33e3-8080-989b-ee770501afac" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-80e6-aba1-cdc063ae145f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">문제 4. 결제 이벤트 누락과 중복</span></span></span></p><p id="2b1a360d-33e3-8045-9271-db1e5b0a8362" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결제 승인이나 취소 시, 시스템은 각 트랜잭션에 대한 이벤트를 발행합니다. 이벤트 발행은 흔히들 알고 계시는 </span><span class="css-q3ktjb">Outbox 패턴</span><span class="css-1kxrhf3">으로 구현되어 있습니다.</span></span></span></p><p id="2b1a360d-33e3-80e8-8997-eb27919ed169" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">아웃박스 패턴을 썼는데 왜 이벤트 누락이 있지? 라는 의문이 있을 수 있는데, 토스페이먼츠는 가맹점의 결제 서비스 가용성에 좀 더 집중하고 있고, 또 결제 비즈니스의 특성상 외부 원천사 연동에서 롤백을 지원하지 않는 부분도 있어서, </span><span class="css-q3ktjb">Outbox에 저장을 실패한다고 비즈니스 로직 전체를 실패 처리하기보다 별도의 처리를 진행</span><span class="css-1kxrhf3">하고 있습니다.</span></span></span></p><p id="2b1a360d-33e3-8020-b478-e314330c965a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">다행히 Outbox에 저장이 된 이벤트들에 대해서는 성공 여부를 통해 이벤트를 재발송하는 배치가 수행되고 있어서 누락 없이 발송되었습니다.</span></span></span></p><p id="2b1a360d-33e3-80a5-a0b3-e0e8d9b30917" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-8078-bc77-e6d4257544a7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">로그 기반 복구</span></span></span></p><figure id="2b1a360d-33e3-8066-bdd0-eee03a3c014d" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/2d0ad690-c745-43fc-99af-3fae4956c983/image.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-80d8-b635-ec4712eeee55" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">누락된 이벤트는 Outbox에 적재되지 않은 거래건들인데</span><span class="css-1kxrhf3">요. 결제 서버는 영향을 받은 거래건들은 ES에 로그를 적재하고 있고, 로깅 시스템에 문제가 생겼을 때를 대비하여 fallback appender를 통하여 서버 팟의 로컬 디스크에도 저장해두었다가 로깅 시스템 복구 시 로깅을 재처리하고 있기에, </span><span class="css-q3ktjb">영향 거래들을 빠르게 식별해 장애 시간대의 전체 거래의 이벤트를 재발행</span><span class="css-1kxrhf3">할 수 있었습니다.</span></span></span></p><p id="2b1a360d-33e3-80aa-9a18-e56268c5e036" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-803c-bf99-c8f13d2c140c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">이벤트 중복 발행</span></span></span></p><p id="2b1a360d-33e3-80fc-a7b8-e97b9ead2704" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">거기서 추가 문제는 누락된 이벤트를 재발행하면서 이벤트가 중복으로 발행된 것인데, 이벤트를 적재하는 서비스에서 승인 또는 취소가 중복해서 보이는 문제가 있었습니다.</span></span></span></p><figure id="2b1a360d-33e3-80ad-8fe9-e07477f43330" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/ce551397-aa09-4cde-adee-f11fe29cf8e3/image.png" alt="" class="css-1pgssrp"/></figure><p id="2b1a360d-33e3-8049-a1c6-e91ee465877b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 문제는 사용하는 곳에서 동일 이벤트를 중복 처리하지 않을 수 있게 </span><span class="css-q3ktjb">동일 건을 식별할 수 있도록 이벤트의 헤더에 멱등키를 실어 제공</span><span class="css-1kxrhf3">하는 방법으로 보완하였습니다.</span></span></span></p><p id="2b3a360d-33e3-804d-a7e1-d831b64843a1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b1a360d-33e3-8000-85c9-ee58595c9e39" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Lesson &amp; Learn</span></span></span></h3><p id="2b1a360d-33e3-8034-a144-de1b1b8db318" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">처음 이 시스템을 설계할 때의 기대와 달리 운영에 들어가 보니 예기치 못한 이슈들이 정말 많았습니다.</span></span></span></p><p id="2b1a360d-33e3-8064-881f-ec599d691413" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이슈들을 대응하면서 느낀 건 </span><span class="css-q3ktjb">초기 설계만큼이나 중요한 건 그 이후의 운영 대응</span><span class="css-1kxrhf3">이라는 것입니다. 장애가 발생했을 때도 시스템이 스스로 회복할 수 있어야 하고, 잘못된 데이터를 바로잡을 수 있는 구조가 갖춰져 있어야 한다는 것을 배웠습니다.</span></span></span></p><p id="2b1a360d-33e3-8057-a537-e3f00a590a61" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">신규 결제 원장 전환은 단순한 마이그레이션이 아니었습니다.</span></span></span></p><p id="2b1a360d-33e3-806b-8f96-f773fabcaa31" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">운영 중 발생한 장애와 그 복구 과정을 통해, 토스페이먼츠는 시스템이 </span><span class="css-q3ktjb">스스로 회복할 수 있는 구조</span><span class="css-1kxrhf3">로 한 단계 성장했습니다. 이번 경험은 안정성과 확장성을 모두 갖춘 결제 인프라를 지속적으로 발전시키기 위한 중요한 전환점이 되었습니다.</span></span></span></p><p id="2b1a360d-33e3-8040-ad76-f8ad1286e170" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b1a360d-33e3-80bc-a1a9-f11327586fe6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">✅ </span><span class="css-q3ktjb">이번 아티클은 Toss Makers Conference 25의 세션을 바탕으로 재구성되었습니다.</span></span></span></p><figure id="2b1a360d-33e3-807c-b5a0-fd4db68e82e7" class="css-of5acw"><div class="css-oni540"><iframe src="https://www.youtube.com/embed/xTCcXSrbdLY" frameBorder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" class="css-122y91a"></iframe></div></figure><p id="2b1a360d-33e3-805e-a371-c0df591f0836" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[토스의 브랜드 심볼을 찾아서]]></title>
            <link>https://toss.tech/article/43061</link>
            <guid>https://toss.tech/article/43061</guid>
            <pubDate>Mon, 01 Dec 2025 03:01:00 GMT</pubDate>
            <description><![CDATA[인사이트 수준에 머물기 쉬운 추상적인 브랜드 리서치를 실제로 적용한 방법을 알려드려요.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2b9a360d-33e3-80d0-bd6d-c7874da62402" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-802e-ae73-e1f2f84de434" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요. 브랜드 커뮤니케이션 관련 리서치를 중점적으로 담당하고 있는 UX Researcher 김은심입니다. 오늘은 토스가 온라인을 넘어 오프라인 세상으로 나아갈 때, 어떻게 우리만의 얼굴을 정의하고 찾아갔는지, 토스의 브랜드 심볼을 찾아간 과정을 들려드리려고 해요. </span></span></span></p><p id="2b9a360d-33e3-80af-b44f-d853dcfdd5c7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b9a360d-33e3-80e6-8a2f-f5a0996a911d" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">오프라인에서 토스페이를 알리려면 어떤 로고를 써야 할까?</span></span></span></h2><p id="2b9a360d-33e3-80fd-b699-d764450a255f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">브랜드 심볼을 찾는 과정은 토스페이 ‘댕글러(Dangler)’를 만드는 논의에서 시작되었어요. 댕글러는 편의점 계산대나 카페 진열대 위에 놓인 작은 카드형 안내판이에요. 결제 서비스에겐 사용자가 브랜드를 가장 먼저 인지하는 중요한 접점이죠. 토스페이가 오프라인 결제 시장으로 확장되면서, 이 곳에서 토스페이로 결제할 수 있다는 걸 알려주는 댕글러를 새롭게 만들어야 했어요. 어떤 로고를 넣어야 사람들이 토스라는 걸 바로 알아볼 수 있을지 고민했죠. </span></span></span></p><figure id="2b9a360d-33e3-8067-9769-e1a4d0fbf580" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/31571faf-3c77-453f-adfa-3086e245d070/inner-techblog-1.png" alt="" class="css-1pgssrp"/></figure><p id="2b9a360d-33e3-807d-8c18-f2362d866ce1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">초기 논의는 주로 시각적인 요소에 집중돼 있었어요.</span></span></span></p><ul class="css-uswsmm"><li id="2b9a360d-33e3-8020-91a3-f808bca15d3f" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">파란 배경이 더 토스스러울까?</span></span></span></li><li id="2b9a360d-33e3-80eb-b172-fe797b7d4359" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">한글 로고가 직관적일까, 영문이 더 익숙할까?</span></span></span></li><li id="2b9a360d-33e3-80e4-92c2-f3e36291a28a" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">앱 아이콘을 쓰면 토스페이를 더 빠르게 떠올릴까?</span></span></span></li></ul><p id="2b9a360d-33e3-804e-b435-e0eb03b94304" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 이런 논의만으로는 뾰족한 답을 찾기 어려웠어요. </span></span></span></p><p id="2b9a360d-33e3-802a-a181-cba6299f6840" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="2b9a360d-33e3-800f-b73a-e1de835aaaaa" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/2d9d2445-9129-4e53-843c-4f56c6833a3f/inner-techblog-2.png" alt="" class="css-1pgssrp"/></figure><p id="2b9a360d-33e3-80c9-9bf5-e20214421dec" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그동안 토스는 온라인에서 다양한 로고 변주를 시도해왔어요. 온라인에서는 ‘토스’라는 글자와 익숙한 로고 형태만 확보되면, 컬러나 스타일이 조금 달라져도 사용자는 어렵지 않게 브랜드를 알아봤죠.</span></span></span></p><p id="2b9a360d-33e3-805f-bc4d-d1022187f45e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 오프라인은 전혀 다른 환경이었어요. 페이스페이, POS 단말기, 오프라인 매장, 외부 행사처럼 토스가 원래 존재하던 온라인 환경과는 전혀 다른 곳에서 토스를 마주해야 하는거죠. 앱 안에서는 수년 동안 ‘토스다움’을 자연스럽게 학습해왔지만, 오프라인에서도 그대로 작동한다고 장담할 수 없었어요.</span></span></span></p><p id="2b9a360d-33e3-8000-acb6-fdccfe04814d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">낯선 환경인 오프라인에서도 토스를 인지시켜려면, 단순 로고 디자인 논의를 넘어서, 사람들이 토스를 토스로 인식하게 만드는 </span><span class="css-nvohhk">핵심적인 자산</span><span class="css-1kxrhf3">은 무엇인지 파악하는 게 필요했어요.</span></span></span></p><p id="2b9a360d-33e3-80aa-b80f-f9ec2d00dde7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><p id="2b9a360d-33e3-8099-bc6f-f36afb9aab69" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-8029-8f68-f4449df9c9a4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-8093-86e2-de22bbf8a90b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-80f2-a6e5-ea32580bd53f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-807f-85ec-dc57e87467d5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-804d-98f2-d6edf1e0bc58" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-808a-b2be-cb82c52bec84" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-8043-8724-e8ef4171a349" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b9a360d-33e3-80f5-82e8-f5e2a295bc36" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">토스의 핵심 이미지는 </span><span class="css-182qzvh">사용성</span></span></span></h2><p id="2b9a360d-33e3-8023-be81-ce633313c6e8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-804c-9116-f59624279568" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">브랜드의 핵심 심볼은 어떻게 찾을 수 있을까요? 사람들이 특정 브랜드를 떠올릴 때 머릿속에 떠오르는 이미지, 감정, 키워드를 파악하는 것이 중요해요. 단순 설문이나 기능 피드백만으로는 알 수 없는 부분이기 때문에, 깊이 있는 인터뷰를 진행했어요.</span></span></span></p><p id="2b9a360d-33e3-8076-b32b-fdcb607538c2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">특히 참여자 선정이 중요했어요. </span><span class="css-1kxrhf3">브랜드 인상처럼 추상적인 개념을 언어로 설명하지 못하면, “그냥 그런 느낌?” 같은 모호한 결론에 머무를 위험이 있었기 때문이에요. 그래서 스크리닝 단계에서 다음과 같은 질문을 넣어, 자신의 생각을 명확한 언어로 풀어낼 수 있는 참여자를 선별했어요.</span></span></span></p><p id="2b9a360d-33e3-80fe-9bc2-c3acd2e79124" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><blockquote id="2b9a360d-33e3-80b4-9898-d9c2921ad04c" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“토스는 나에게 ______이다.” 이 빈칸을 채우고 그 이유를 적어주세요.</span></span></span></blockquote><blockquote id="2b9a360d-33e3-80a1-8785-d3edeac2fc44" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">팬으로서 애정하거나 응원하는 브랜드는 무엇인가요? 그 이유도 함께 적어주세요.</span></span></span></blockquote><p id="2b9a360d-33e3-803b-abd9-fb7c43ed6cc2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-80b7-80e9-ffb55c5551df" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 선별된 참여자들에게 토스 하면 가장 먼저 떠오르는 이미지는 무엇인지 물어봤죠. 빠지지 않고 등장하는 키워드가 있었어요. “군더더기 없다”, “실용적이다”, “편리하다”. </span></span></span></p><p id="2b9a360d-33e3-80f8-9d07-c958ddc1c2eb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">특히 한 사용자의 답변이 기억에 남아요.</span></span></span></p><blockquote id="2b9a360d-33e3-8053-9e7f-d8aae84ef40f" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1odxvuk">“</span><span class="css-120saye">토스는 천재 공돌이가 엑셀로 만든 프로그램 </span><span class="css-1odxvuk">같아요. 그러나…</span><span class="css-120saye">미적인 이미지는 잘 떠오르지 않아요</span><span class="css-1odxvuk">.” </span></span></span></blockquote><p id="2b9a360d-33e3-8000-84f8-fb252940d21e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-8082-915a-cb5931c26abf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사용자들이 토스를 떠올릴 때 기준이 되는 건 시각적인 요소가 아니라, </span><span class="css-q3ktjb">앱을 사용하면서 느껴지는 경험 자체</span><span class="css-1kxrhf3">였어요. 바로 여기서 문제가 생겼죠. 오프라인에서는 앱 경험을 보여줄 수 없기 때문에, 낯선 환경에서도 “이게 토스다”를 알아볼 수 있는 </span><span class="css-q3ktjb">명확한 시각적 단서</span><span class="css-1kxrhf3">가 필요했어요.</span></span></span></p><p id="2b9a360d-33e3-8032-b67d-c9b8b0d68a57" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 사용자 머릿속에 즉시 떠오르는 </span><span class="css-q3ktjb">하나의 시각적 심볼</span><span class="css-1kxrhf3">은 없었어요. 이 발견은 우리에게 꽤 큰 충격이었고, 동시에 오프라인에서도 통할 </span><span class="css-q3ktjb">브랜드의 핵심 자산을 다시 정의해야 한다</span><span class="css-1kxrhf3">는 과제가 분명해졌죠.</span></span></span></p><p id="2b9a360d-33e3-80f1-a3fa-d54dd07a8303" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-8073-a35a-df7e349a26e2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b9a360d-33e3-8023-8fbc-deca559d69ee" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">3가지 단서로 찾는 토스의 심볼 </span></span></span></h2><p id="2b9a360d-33e3-8079-a742-c1e2cf226318" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">시각적 심볼이 없다는 것은 무엇인지, 그 개념을 세 가지 요소로 나누어 분석했어요. 그리고</span><span class="css-1kxrhf3"> 각각 요소에 대해 어떤 형태를 가장 토스스럽다고 느끼는지 탐구하기 시작했죠.</span></span></span></p><ul class="css-uswsmm"><li id="2b9a360d-33e3-800a-853e-d4bf9d105b6d" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">폰트</span></span></span></li><li id="2b9a360d-33e3-802d-a4ef-ff6c521a89e9" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">컬러</span></span></span></li><li id="2b9a360d-33e3-80ce-b256-c74742e2a5a2" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">로고</span></span></span></li></ul><p id="2b9a360d-33e3-80ec-8280-f2ddfef555fd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b9a360d-33e3-807d-96ae-e13f83207ca9" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">발견 1: 폰트 – 검정색 영문 ‘toss’</span></span></span></h3><figure id="2b9a360d-33e3-80a1-811b-d9140ac23000" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/b08c2607-8aed-43d1-993d-8a43352179d7/inner-techblog-3.png" alt="" class="css-1pgssrp"/></figure><p id="2b9a360d-33e3-80f6-bae9-e55024546cb6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사용자에게 다양한 토스 로고 폰트를 보여주고 가장 익숙하다고 느끼는 것을 선택하도록 했어요. </span><span class="css-q3ktjb">1위는 검정색 영문 ‘toss’ 폰트</span><span class="css-1kxrhf3">였어요. 이유는 단순했어요. 뉴스, 광고, 외부 매체 등에서 가장 자주 접한 형태였기 때문이에요. 앱 안에서는 오히려 폰트를 볼 일이 거의 없거든요.</span></span></span></p><p id="2b9a360d-33e3-8096-acb0-c946befc6055" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-801e-982f-efa498367c39" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b9a360d-33e3-809b-bf0c-dd5b27d3749e" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">발견 2: 컬러 – 예상 밖의 결과</span></span></span></h3><p id="2b9a360d-33e3-80a4-9101-f62818594dab" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">여러분은 토스하면 무슨 색이 떠오르시나요? 저희는 당연히 파란색이라고 생각했어요. 하지만 사용자들의 생각은 달랐죠.</span></span></span></p><blockquote id="2b9a360d-33e3-80f1-87ee-e5b66d9163af" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1odxvuk">“파란색이긴 한데… 바로 떠오르진 않아요.”</span></span></span></blockquote><p id="2b9a360d-33e3-808d-b5ac-f7514de83687" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스를 많이 쓰는 사용자 조차도 즉각적으로 파란색을 떠올리지 못했어요. 사용자에게 각인된 토스의 컬러는 단일 색상이 아니라, ‘흰 배경과 파란 로고’가 만나는 조합 그 자체였기 때문이죠.
</span></span></span></p><p id="2b9a360d-33e3-8009-88bc-d5b12c7c9f54" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b9a360d-33e3-80fa-bc16-cf5336101d74" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">발견 3: 로고 – 앱 아이콘이 곧 심볼</span></span></span></h3><p id="2b9a360d-33e3-80b3-ab40-ee39033009d8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사용자들에게 토스 로고가 어떤 모양인지 알고 있느냐고 물었을 때, 대부분 “파란색 바람개비처럼 생긴 로고요” 정도의 답변만 들을 수 있었어요. 말로만 듣고는 사용자들이 로고를 어느 수준까지 인식하고 있는지 정확히 파악하기 어려웠죠. 그래서 앱을 보지 않은 상태에서 토스 로고를 그려달라고 요청했어요. 여기에서 결정적인 단서를 발견했죠. </span></span></span></p><figure id="2b9a360d-33e3-802e-a1d5-da6a7d7cc05d" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/54975320-eca2-4839-b58e-da93b3c14870/inner-techblog-4.png" alt="" class="css-1pgssrp"/></figure><p id="2b9a360d-33e3-8083-904d-d148ac9da772" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-80a7-a3e8-f0db54492158" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">두 그림의 공통점을 찾으셨나요? 바로 </span><span class="css-nvohhk">네모난 배경</span><span class="css-1kxrhf3">이에요. 즉, 사용자들은 토스의 얼굴을 로고 단독이 아니라 스마트폰 화면 속 </span><span class="css-q3ktjb">‘앱 아이콘(흰 바탕 + 파란 로고 + 사각 배경)’</span><span class="css-1kxrhf3"> 구성으로 인식하고 있던 거에요. </span></span></span></p><p id="2b9a360d-33e3-8041-a7de-c1b64e52f288" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b9a360d-33e3-80f9-87fc-c35554ceadd6" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">시각적 심볼을 찾다 </span></span></span></h2><p id="2b9a360d-33e3-80e4-b700-d7b3a9a3b838" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">리서치를 통해 확인한 ‘사용자가 생각하는 토스의 진짜 심볼’은 다음과 같았어요.</span></span></span></p><ul class="css-uswsmm"><li id="2b9a360d-33e3-80e0-bdc3-cf2c6bded7e2" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">로고:</span><span class="css-1kxrhf3"> 앱 아이콘 형태 (로고 + 사각 배경) </span></span></span></li><li id="2b9a360d-33e3-8077-97da-fa05739495ed" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">폰트:</span><span class="css-1kxrhf3"> 검정색 볼드체 영문</span></span></span></li><li id="2b9a360d-33e3-8017-89b6-f7dbf438bc3f" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">컬러:</span><span class="css-1kxrhf3"> 흰색·파랑·검정의 조합으로 인지</span></span></span></li></ul><p id="2b9a360d-33e3-805f-b9cf-f6f985d0c577" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 세 가지가 결합될 때, 비로소 사용자들은 </span><span class="css-q3ktjb">“이건 토스다”</span><span class="css-1kxrhf3"> 하고 직관적으로 인식했어요. 그리고 이 공식을 실제 디자인에 적용했죠.</span></span></span></p><figure id="2b9a360d-33e3-8090-80c9-e719339c5462" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/6bf09d1f-1d45-4a30-b14e-39a9d94b03ac/inner-techblog-5.png" alt="" class="css-1pgssrp"/></figure><p id="2b9a360d-33e3-805b-aaa0-cee7dab41112" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b9a360d-33e3-80ce-9075-ce5b6c8a28bd" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사례 1. 토스 10주년 캠페인 ‘10 to 100’</span></span></span></h3><figure id="2b9a360d-33e3-80fd-a3ff-effe083ba841" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/8d37a54d-2954-4d3b-88b3-2f5b953a390e/inner-techblog-6.png" alt="" class="css-1pgssrp"/></figure><p id="2b9a360d-33e3-80f7-86c2-ff7cf20a1648" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-8025-b38e-f73a358ec537" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">파란 배경에 흰 글자와 흰 로고 대신,</span><span class="css-q3ktjb"> 흰 바탕 + 검정 글씨 + 파란 로고</span><span class="css-1kxrhf3">조합을 메인으로 사용했어요. 사용자들이 가장 ‘토스스럽다’고 인식하는 구성을 반영한 거죠.</span></span></span></p><p id="2b9a360d-33e3-804a-9249-f34d7e47bde1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b9a360d-33e3-8068-82c2-d77e38fd1c5a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사례 2. 토스페이 결제 화면</span></span></span></h3><figure id="2b9a360d-33e3-806c-9c82-f065a9dbb053" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/80e56080-e75b-4b5d-b6c8-205f602769fc/inner-techblog-7_(1).png" alt="" class="css-1pgssrp"/></figure><p id="2b9a360d-33e3-80e5-8d23-eefd6092d133" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이 결제 화면에서도 파란색 배경 시안을 과감히 걷어냈어요. 대신 </span><span class="css-q3ktjb">흰 바탕 위에 검정 폰트와 파란 로고를 조합한 시안을 채택했죠.</span></span></span></p><p id="2b9a360d-33e3-80a2-8081-d76c5696dee3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-802d-a3a6-dc0d2ae9f779" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b9a360d-33e3-8002-ba49-d594c242e706" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">UX리서처로서 다시 생각해 본 것 </span></span></span></h2><p id="2b9a360d-33e3-80ab-bb89-ca09ce1ea462" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">브랜드 관점의 리서치는 다른 리서치와 다르게, 명확한 불편이나 문제를 바로 드러내주지 않아요. 대부분 형태가 없는 </span><span class="css-q3ktjb">감각·이미지·인식 같은 추상적인 요소</span><span class="css-1kxrhf3">를 다루기 때문이에요.  그래서 리서처에게는 항상 이런 간극이 남습니다.</span></span></span></p><blockquote id="2b9a360d-33e3-80c9-94fc-f7f167ff3dac" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1odxvuk">이게 실제 프로덕트에서는 어떤 의미로 연결될까?
내가 발견한 인사이트는 어떻게 쓰일 수 있을까?</span></span></span></blockquote><p id="2b9a360d-33e3-8029-8a4e-f0503cb8911d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저 역시 이런 고민을 오래 해왔어요. 이번 리서치는 그 간극을 조금이라도 줄여보고 싶은 마음에서 출발했습니다. 추상적인 이미지를 탐구하는 데서 멈추지 않고, 그걸 </span><span class="css-q3ktjb">오프라인이라는 구체적인 형태로 </span><span class="css-1kxrhf3">어떻게 옮길 수 있을지 고민해야 했습니다. 특히 3가지를 신경썼어요.</span></span></span></p><p id="2b9a360d-33e3-8089-9ad9-e1b376afa9dc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><aside id="2bca360d-33e3-803b-bf82-dc011e11117a" class="css-nv7vyi"><div class="css-1vn47db"><h3 id="2b9a360d-33e3-8053-bb81-eae6572e7473" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1. 리서치의 목적을 분명히 하기</span></span></span></h3><p id="2b9a360d-33e3-802f-bee4-c67802909e2a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">단순히 어떤 로고를 선호하는지를 묻는 것보다, 그 로고를 통해 우리가 얻고자 하는 바가 무엇인지 정의했어요.</span></span></span></p><p id="2b9a360d-33e3-80c2-9f1f-feb4655c05e5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b9a360d-33e3-80fc-a83c-faf2e1daa89d" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2. 더 작은 요소로 쪼개서 질문하기</span></span></span></h3><p id="2b9a360d-33e3-8015-a919-d81dae0d9a80" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“우리 브랜드 이미지 어때요?”는 사용자 입장에서 너무 막연하게 느껴질 수 있어요. 폰트·컬러·모양 같은 구체적 요소로 분해해 물어보니, 더 선명한 단서를 얻을 수 있었어요.</span></span></span></p><p id="2b9a360d-33e3-80e0-a965-cb138efab7aa" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b9a360d-33e3-80b2-bce2-dcace6b7b992" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">3. 말로 파악하기 어려운 것은 행동으로 확인하기</span></span></span></h3><p id="2b9a360d-33e3-80e7-8854-c588c3115b9c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">심상을 확인할 때는, 말로 하는 설명보다 사용자가 손으로 그린 그림 한 장이 더 강력한 힌트가 될 수 있어요. </span></span></span></p></div></aside><p id="2b9a360d-33e3-8017-97b2-d08fd42ad7b3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b9a360d-33e3-8089-914b-faeebb0d707f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이건 거창한 원칙이라기보다, 추상적인 컨셉을 실제 결과물로 연결하기 위해 </span><span class="css-q3ktjb">몸으로 배운 방식</span><span class="css-1kxrhf3">에 가까워요. 이번 사례가 그 고민을 조금이나마 덜어주는 데 도움이 되길 바랍니다.</span></span></span></p><p id="2bca360d-33e3-80eb-9151-d8365b1e7f64" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[토스페이먼츠의 Open API 생태계]]></title>
            <link>https://toss.tech/article/payments-legacy-4</link>
            <guid>https://toss.tech/article/payments-legacy-4</guid>
            <pubDate>Fri, 28 Nov 2025 01:00:00 GMT</pubDate>
            <description><![CDATA[20만 개 가맹점이 사용하는 API, 수십 년간 안정적으로 운영하기 위한 토스페이먼츠의 방식]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2b8a360d-33e3-80d6-b911-d88c8fd463dd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요, 토스페이먼츠 Server Developer 허지훈입니다.</span></span></span></p><p id="2b7a360d-33e3-809b-908c-f244321f10ac" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">온라인에서 ‘구매하기’ 버튼을 누르는 그 순간, 사용자는 단 몇 초 만에 결제가 완료되는 경험을 합니다. 하지만 그 짧은 순간 동안, 서버와 서버 사이에서는 수많은 API 호출이 오가며 결제를 처리하고 있죠. 결제창을 띄우는 것부터 승인 요청, 결제 완료, 정산, 그리고 금액 검증까지. 이 모든 과정은 API를 통해 연결됩니다.</span></span></span></p><p id="2b7a360d-33e3-807c-a5b9-f50466ca267c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 이런 흐름의 중심에서 가맹점이 결제 서비스를 연동할 수 있도록 Open API를 제공합니다. 현재 토스페이먼츠의 Open API는 20만 개 이상의 가맹점에서 사용되고 있습니다. 이 수치는 단순히 규모를 넘어, API가 얼마나 오랫동안 안정적으로 운영되어야 하는지를 보여줍니다. 한 번 연동된 API는 수년, 혹은 수십 년 동안 유지될 수 있고, 잘못 설계된 API 하나는 그만큼의 시간 동안 불편과 유지 비용을 낳습니다.</span></span></span></p><p id="2b7a360d-33e3-80d6-bcb2-fc5c071f7e52" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 토스페이먼츠는 Open API를 단순히 잘 동작하는 것을 넘어, 앞으로 수십 년간 안전하게 운영될 인프라라는 관점에서 설계하고 관리하고 있습니다. API는 단순한 통신 수단이 아니라, 토스페이먼츠와 가맹점이 안정적으로 연결될 수 있는 기반이기 때문입니다.</span></span></span></p><p id="2b7a360d-33e3-8068-910b-d2e772b68018" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그렇다면 수십만 개의 가맹점이 사용하는 Open API를 오랫동안 안정적으로 운영하기 위해서는 어떤 것들을 고려해야 할까요?
API 설계 방식은 어떻게 정하고, 외부 개발자에게는 어떤 환경을 제공해야 할까요?
보안은 어떻게 보장하고, 내부적으로는 품질을 어떻게 유지할까요?</span></span></span></p><p id="2b7a360d-33e3-8004-8734-e7d56e1ee606" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 이러한 고민을 다섯 가지 핵심 요소로 정리했습니다.</span></span></span></p><p id="2b8a360d-33e3-801e-b3aa-cde0033c5170" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-8066-8a3b-f722bced7396" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Open API의 5가지 핵심 요소</span></span></span></h3><aside id="2b8a360d-33e3-80f1-b5a6-f4c9c2a0d5b6" class="css-nv7vyi"><div class="css-1vn47db"><ol class="css-hokoge"><li id="2b7a360d-33e3-8097-8319-fa3772e62727" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">인터페이스</span><span class="css-1kxrhf3"> – API와 웹훅, 어떻게 데이터를 주고받을 것인가</span></span></span></li><li id="2b7a360d-33e3-8019-a31d-e7f5632dcb9c" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">외부 생태계(개발자 경험)</span><span class="css-1kxrhf3"> – 문서, 테스트 환경, 도구로 완성하는 개발 여정</span></span></span></li><li id="2b7a360d-33e3-804b-a436-e3f7a7c11964" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">보안</span><span class="css-1kxrhf3"> – 인증, 서명, 암호화로 지키는 안전한 시스템</span></span></span></li><li id="2b7a360d-33e3-8095-a5a6-d5214175665f" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">안정성</span><span class="css-1kxrhf3"> – 고가용성 인프라와 모니터링 체계</span></span></span></li><li id="2b7a360d-33e3-80f6-a389-f7ff8338ef4e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">내부 생태계</span><span class="css-1kxrhf3"> – 조직 차원의 API 품질 관리과 운영 프로세스</span></span></span></li></ol></div></aside><p id="2b7a360d-33e3-8045-a1f3-f8259e2b7695" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이번 글에서는 이 중에서 ‘안정성’을 제외한 네 가지 요소, </span><span class="css-q3ktjb">인터페이스, 외부 생태계, 보안, 내부 생태계</span><span class="css-1kxrhf3">에 대해 이야기하려고 합니다. 토스페이먼츠가 Open API를 어떻게 바라보고, 어떤 방식으로 발전시켜 나가고 있는지를 함께 살펴보겠습니다.</span></span></span></p><p id="2b8a360d-33e3-802f-879f-cf1063e5a004" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b7a360d-33e3-80e2-9132-c0a6a97be57f" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">1. 인터페이스</span></span></span></h2><h3 id="2b7a360d-33e3-8087-8273-e9e88406c24d" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">API(request-response): 리소스 중심 설계</span></span></span></h3><p id="2b7a360d-33e3-8067-a9a4-c7673b203fe6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">서로 다른 시스템이 데이터를 주고받기 위해서는 인터페이스가 필요합니다. 가장 익숙한 방식은 요청(Request)과 응답(Response)을 주고받는 API 방식입니다. 토스페이먼츠는 이 API를 설계할 때 쉽고 간결한 디자인을 지향합니다. 개발자가 빠르게 이해하고 일관된 방식으로 사용할 수 있는 API가 결국 더 좋은 개발자 경험을 만든다고 믿기 때문이죠.</span></span></span></p><p id="2b7a360d-33e3-802f-8a66-e0c4d4d18588" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 위해 API를 구성하는 핵심 요소를 경로(Path), 요청(Request), 응답(Response) 세 부분으로 나누고 각 영역마다 일관된 가이드라인을 세웠습니다. 이 가이드라인은 ‘설명하지 않아도 이해되는 API’를 목표로 합니다.</span></span></span></p><p id="2b8a360d-33e3-802a-aeaf-d888c89dfcee" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-80ac-8d6b-d99199144be4" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">경로</span><span class="css-q3ktjb">: 일관성과 예측 가능성</span></span></span></h3><p id="2b7a360d-33e3-80f7-aabf-c74e67880118" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가맹점이 URL만 보고도 어떤 인터페이스인지 유추할 수 있도록 토스페이먼츠는 path 규칙에 일관성을 부여했습니다. root path에는 버전이 명시되고, 그 다음에는 도메인(리소스의 이름)이 들어갑니다. 특정 리소스를 지정해야 하는 경우에는 그 리소스의 고유 ID를 path 파라미터로 표현합니다. </span></span></span></p><p id="2b7a360d-33e3-80eb-b86c-ea6fb7416688" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 고유 ID가 아닌 값을 기준으로 구분해야 할 때는 path 대신 query 파라미터나 JSON 필드를 사용하도록 했습니다.</span></span></span></p><p id="2b7a360d-33e3-805b-aece-eedf91bf0c4a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들어 GET 요청은 query 파라미터로, POST 요청은 JSON body 필드로 구분하는 식입니다.</span></span></span></p><p id="2b7a360d-33e3-80a7-ba10-f70359e35bda" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 설계하면 API가 직관적이고, 불필요한 규칙을 외울 필요가 없습니다. URL만 봐도 요청을 이해할 수 있습니다.</span></span></span></p><p id="2b8a360d-33e3-80d3-ad95-e35c2507abf7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-804b-b99e-c8b31708a5f9" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">요청과 응답: 구조화된 JSON</span></span></span></h3><p id="2b7a360d-33e3-8032-a0d5-c632296cb1af" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">요청과 응답은 모두 JSON 포맷을 사용합니다. JSON은 계층 구조를 표현할 수 있기 때문에 서로 관련된 정보를 Nested Object 형태로 모듈화해 전달할 수 있습니다. </span></span></span></p><p id="2b7a360d-33e3-806d-94f6-db32170b787e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들어 카드 정보와 현금영수증 정보는 여러 API에서 반복적으로 사용됩니다. 이를 각 응답마다 개별 필드로 두는 대신, 하나의 객체로 묶어 재사용합니다.</span></span></span></p><p id="2b7a360d-33e3-803f-a5f7-e61eb0c84793" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 구조를 사용하면 중복을 줄일 수 있을 뿐 아니라 응답을 더 쉽게 인식하고 예측할 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-803c-9c15-d4583142e4d6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들어 현금영수증이 발급되지 않았다면 cashReceipt 객체가 null로 내려가고, 발급되었다면 그 안에 세부 필드가 채워집니다. 이 방식은 null 체크가 간단하고, 응답의 의미도 명확하게 전달됩니다.</span></span></span></p><p id="2b8a360d-33e3-8047-9f48-c967c5162832" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-800d-ba7b-fc07a090bdf0" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">도메인별 객체 재사용</span></span></span></h3><p id="2b7a360d-33e3-80cc-bdc5-c2473b6b9c91" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하나의 도메인과 관련된 API들은 가능한 한 동일한 객체를 재사용하도록 설계했습니다. 결제 승인, 결제 조회, 결제 취소 API의 응답 구조가 모두 동일한 이유도 여기에 있습니다.</span></span></span></p><p id="2b7a360d-33e3-800c-8517-df41b9f0a3b7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 객체를 재사용하면 개발자가 새로운 API를 사용할 때 별도의 구조를 학습할 필요가 없습니다. 비슷한 API는 비슷한 형태로 응답하므로 사용자는 자연스럽게 응답을 예상할 수 있고, 가맹점 코드의 중복도 줄어듭니다.</span></span></span></p><p id="2b7a360d-33e3-8034-8437-ea5acec4081e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결국 이런 구조적 일관성이 개발자의 인지를 높이고, 연동 진입 장벽을 낮추는 효과를 줍니다.</span></span></span></p><p id="2b8a360d-33e3-808d-9a67-dada7db083aa" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-80c7-ae87-f5e60e1b5e40" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">데이터 표현: 코드를 넘어서 이해하기 쉽게</span></span></span></h3><p id="2b7a360d-33e3-80ab-8d6e-e3ff4733a21e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">API 설계에서 또 하나의 고민은 타입이나 코드 값 같은 Enumeration의 표현 방식입니다. 기존에는 SC0010 같은 코드나 숫자로 표현하는 방식이 많았습니다.</span></span></span></p><p id="2b7a360d-33e3-809b-9521-d1099d2680d5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 방식은 시스템 입장에서는 효율적일 수 있지만 사람이 보기에 직관적이지 않고, 코드 표를 따로 확인해야 한다는 불편이 있습니다.</span></span></span></p><p id="2b7a360d-33e3-8001-bf03-fe3f9f03a406" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 이 문제를 해결하기 위해 응답 데이터를 한글로 표현하도록 했습니다. 예를 들어 카드사는 “현대”, “국민”, “신한”처럼 은행명이나 상태 값도 자연어로 표시됩니다. 하지만 해외 가맹점처럼 한국어를 사용하지 않는 고객도 존재하기 때문에 이 부분은 HTTP의 Accept-Language 헤더를 활용해 해결했습니다. 요청 헤더에 ko를 지정하면 한글 응답이, en을 지정하면 영어 응답이 내려갑니다.</span></span></span></p><p id="2b7a360d-33e3-80ce-9df6-fbf6b81942fe" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 방식은 단순한 번역 지원을 넘어, 응답 데이터의 Localization까지 자연스럽게 구현할 수 있게 해줍니다.</span></span></span></p><p id="2b8a360d-33e3-8041-b695-e2a685ddcd86" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-8050-9d81-ec72d4f8e7ca" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">오류 처리: 투명하고 유연하게</span></span></span></h3><p id="2b7a360d-33e3-8063-b26e-d4368fd77afb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">요청 처리 결과는 HTTP status code를 통해 표현합니다. 200대 응답은 성공, 그 외에는 오류 상황을 의미합니다. 하지만 status code만으로는 어떤 오류가 발생했는지 구체적으로 알기 어렵습니다.</span></span></span></p><p id="2b7a360d-33e3-80c7-b437-e1d648f7923c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 보완하기 위해 토스페이먼츠는 status code가 200이 아닐 경우, 응답 body에 표준화된 오류 객체를 함께 내려줍니다.</span></span></span></p><p id="2b7a360d-33e3-80ef-baf0-cbac1a394c0d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 구조는 두 가지 상황을 모두 고려한 결과입니다. 어떤 가맹점은 오류 메시지를 바로 사용자에게 노출하고 싶어하고, 어떤 가맹점은 자체 메시지로 치환하길 원합니다. 그래서 오류 객체에는 code와 message를 함께 포함시켰습니다. 가맹점은 message를 그대로 노출하거나, code를 기준으로 자체 메시지를 보여줄 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-8090-b5dc-eb4270cc198a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠의 API는 기능 중심이 아닌 리소스 중심 설계(Resource-Oriented Design)를 따릅니다. 일관된 경로 구조, 예측 가능한 응답 형태, 그리고 개발자 친화적인 데이터 표현까지. 이 모든 기준은 개발자가 ‘생각하는 방식’에 맞춘 결과입니다.</span></span></span></p><p id="2b8a360d-33e3-8036-8431-dbf8ad788245" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-802a-821a-d2b47a590568" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">웹훅: API만으로는 부족하다</span></span></span></h3><p id="2b7a360d-33e3-800b-ab49-e2fa1144f8a6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결제 서비스에서는 모든 상황을 API 방식으로 처리할 수 있는 것은 아닙니다. 예를 들어, 비동기 결제에서는 클라이언트가 결제 요청을 하더라도 원천사로 부터 언제 처리될지 알 수 없습니다. 이때 서버가 응답을 반환할 때까지 클라이언트가 계속 기다려야 한다면 비효율적이겠죠.</span></span></span></p><p id="2b7a360d-33e3-8027-8920-c84685ac256a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 경우에는 클라이언트가 요청을 보내면 서버가 “요청을 정상적으로 받았다”는 응답만 먼저 내려주고, 실제 처리가 끝난 시점에 완료 알림을 따로 보내는 것이 더 효율적입니다. 클라이언트는 알림이 올 때까지 다른 작업을 진행할 수 있죠.</span></span></span></p><p id="2b7a360d-33e3-80ba-822b-d9de01522a9b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이처럼 특정 이벤트가 발생했을 때 서버가 클라이언트로 알림을 보내는 방식을 웹훅(Webhook)이라고 합니다. 토스페이먼츠는 결제 서비스를 제공할 때 API와 웹훅, 두 가지 인터페이스를 함께 제공합니다. 즉시 응답이 필요한 작업은 API로, 비동기적으로 결과를 알려줘야 하는 작업은 웹훅으로 처리합니다. 웹훅 인터페이스를 제공할 때는 아래 요소들에 대한 고려가 필요합니다.</span></span></span></p><p id="2b8a360d-33e3-8029-b5e5-d6dc960e222f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-8078-9c3c-d3dcddc97fe9" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ 기능 구분</span></span></span></h3><p id="2b7a360d-33e3-80dd-97c6-e645eda594a5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">웹훅은 기능에 따라 </span><span class="css-q3ktjb">이벤트 타입</span><span class="css-1kxrhf3">을 정의하여 구분합니다. 예를 들어 토스페이먼츠는:</span></span></span></p><ul class="css-uswsmm"><li id="2b7a360d-33e3-8060-b72c-da6c0b7637f8" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결제 상태 변경 이벤트 → </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">PAYMENT_STATUS_CHANGED</span></code></span></span></li><li id="2b7a360d-33e3-80c0-a292-c6f701406bde" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">취소 상태 변경 이벤트 → </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">CANCEL_STATUS_CHANGED</span></code></span></span></li></ul><p id="2b7a360d-33e3-805d-9da8-db182ad68f59" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 이벤트 타입별로 데이터 객체가 달라집니다.</span></span></span></p><ul class="css-uswsmm"><li id="2b7a360d-33e3-8083-bab1-ca7ab8b815e3" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">PAYMENT_STATUS_CHANGED</span></code><span class="css-1kxrhf3"> → </span><a target="_blank" rel="noreferrer noopener" class="css-iynyr0" href="https://docs.tosspayments.com/reference#payment-%EA%B0%9D%EC%B2%B4">Payment 객체</a></span></span></li><li id="2b7a360d-33e3-80c3-94bb-eb45447de4ed" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">CANCEL_STATUS_CHANGED</span></code><span class="css-1kxrhf3"> → </span><a target="_blank" rel="noreferrer noopener" class="css-iynyr0" href="https://docs.tosspayments.com/reference#paymentdetaildto-cancels">Cancel 객체</a></span></span></li></ul><p id="2b8a360d-33e3-8032-a83b-ce7c9a873f78" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-8016-bb2f-f5f7fb24ab9e" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣ 웹훅 Payload</span></span></span></h3><p id="2b7a360d-33e3-802c-8b5d-d748631a0056" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">앞서 소개한 것 처럼 토스페이먼츠의 API는 리소스 중심으로 설계되어 있습니다. 결제 결과, 취소 내역 등 모든 응답은 리소스 객체 형태로 내려갑니다. 웹훅도 동일한 리소스에 대한 처리 이벤트를 주는 것이므로 이 객체 구조를 그대로 사용합니다.</span></span></span></p><p id="2b7a360d-33e3-80ce-801b-dfa54c8f2b5e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">결제 승인 API 응답 </span></span></span></p><p id="2b7a360d-33e3-8061-8ac7-ccbc48135b23" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">PAYMENT_STATUS_CHANGED 웹훅 페이로드</span></span></span></p><p id="2b7a360d-33e3-802a-8ce8-d85acf358a7d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 API와 같은 객체를 사용하게 되면, 사용자 인지 부하가 줄어들고 웹훅 전용 파싱 로직이 불필요해져 복잡도도 낮아집니다.</span></span></span></p><p id="2b8a360d-33e3-807b-9095-f9f58b4d517c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-8027-9acb-f525fa8b1b0a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3️⃣ 웹훅 수신 엔드포인트(Endpoint) 설정</span></span></span></h3><p id="2b7a360d-33e3-8080-9da5-c86bf0b0079c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">웹훅은 서버가 클라이언트로 보내는 것이기 때문에 클라이언트가 사전에 웹훅을 수신할 엔드포인트를 설정해두어야 합니다.</span></span></span></p><p id="2b7a360d-33e3-8058-b6ef-f4a6c3388ddb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">클라이언트가 웹훅 수신 엔드포인트를 등록할 때는 이벤트 타입별로 자유롭게 설정할 수 있어야 서로 다른 객체를 보내는 웹훅 이벤트를 쉽게 처리할 수 있습니다.</span></span></span></p><p id="2b8a360d-33e3-806a-a809-c913d99bfdfd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-8004-afc7-cc41c4f07341" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">4️⃣ 안정적인 재전송</span></span></span></h3><p id="2b7a360d-33e3-8096-aa7b-decdc7c8d2ed" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">웹훅은 항상 성공하지 않습니다. 네트워크 이슈나 수신 서비스의 일시적인 장애 등으로 실패할 수 있죠. 이 때 전송에 실패하더라도 서버는 안정적인 재전송을 통해서 웹훅 시스템의 신뢰성을 보장해야 합니다.</span></span></span></p><p id="2b7a360d-33e3-8078-88a4-cea9c17105e0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 수신 서비스의 장애 상황 같은 경우에는 단순히 즉시 재전송하면 오히려 장애를 악화시킬 수 있습니다. 그래서 웹훅 재전송에는 전략이 필요한데, 토스페이먼츠는 웹훅 수신 서비스가 회복할 수 있는 시간을 주고 불필요한 네트워크 호출을 줄이기 위해 Exponential Backoff 전략을 사용합니다.</span></span></span></p><p id="2b7a360d-33e3-8063-92b3-dbcffde2c9df" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">더 나아가 토스페이먼츠는 개발자센터에서 웹훅 전송 내역 조회와 수동 재전송 기능을 제공하여 문제시 개발자가 직접 후속 처리할 수 있도록 지원합니다</span><span class="css-q3ktjb">.</span></span></span></p><p id="2b8a360d-33e3-80fa-97f6-f1fac185d565" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b7a360d-33e3-802b-ae7e-d363c8f429f3" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">2. 외부 생태계: 개발자 경험이 최우선</span></span></span></h2><h3 id="2b7a360d-33e3-80c3-b232-fc1b2e3d1104" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">개발자 경험이란?</span></span></span></h3><p id="2b7a360d-33e3-8051-84ea-e766cf117142" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">개발자 경험(Developer Experience)은 개발자들이 특정 시스템, API, 프레임워크, 개발 도구를 사용할 때 느끼는 전반적인 경험을 의미합니다. 즉, 얼마나 쉽게 이해하고, 빠르게 연동하며, 효율적으로 개발할 수 있는가를 결정하는 요소입니다.</span></span></span></p><p id="2b7a360d-33e3-80fd-857a-cd6b9691f5f7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Open API는 단순히 기능을 제공하는 것으로 끝나지 않습니다. 아무리 강력한 기능을 담고 있어도, 개발자 경험이 좋지 않다면 결국 외면받게 됩니다. 결국 Open API의 품질은 기능이 아니라 경험의 완성도로 평가됩니다.</span></span></span></p><p id="2b7a360d-33e3-8017-90e8-f6c2a5af156b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 이 점에 주목해 Open API를 설계하고 운영할 때 “좋은 Open API”의 기준을 기능이 아니라 경험으로 정의하고, 개발자가 처음 연동을 시작하는 순간부터 운영 단계까지 전 과정을 돕는 다양한 도구와 지원 체계를 마련했습니다.</span></span></span></p><p id="2b7a360d-33e3-807c-bb81-f26a8ec23cca" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">지금부터 토스페이먼츠가 어떻게 개발자 경험을 중심에 두고 외부 생태계를 구축해왔는지 살펴보겠습니다.</span></span></span></p><p id="2b8a360d-33e3-8079-a51a-cefa6fc0cb6d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-803e-a1e5-e8d984215567" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ 연동 문서</span></span></span></h3><p id="2b7a360d-33e3-8091-bad8-cf24e4a89b31" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Open API를 처음 연동할 때, 개발자가 가장 먼저 찾는 것은 연동 문서입니다. “이 API는 어떻게 동작하지?”, “요청 형식은 뭐지?” 같은 궁금증의 출발점이 바로 연동 문서죠.</span></span></span></p><p id="2b7a360d-33e3-803d-a2a5-f7825df21f25" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 수동으로 작성된 문서는 언제나 최신 상태를 유지하기 어렵습니다. API가 진화하고 새로운 기능이 추가될 때마다 문서를 직접 수정하다 보면 실제 서버와의 일관성을 유지하기가 어려워요. 일관성이 떨어진 문서는 연동하는 개발자를 혼란스럽게 합니다.</span></span></span></p><p id="2b7a360d-33e3-80d4-9241-eb5643394ba5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 토스페이먼츠는 연동 문서를 항상 실제 서버의 API 스펙과 자동으로 동기화하기 위해 </span><a target="_blank" rel="noreferrer noopener" class="css-iynyr0" href="https://docs.tosspayments.com/resources/glossary/oas">OpenAPI Specification(OAS) </a><span class="css-1kxrhf3">기반의 문서 자동화 시스템을 구축했습니다.</span></span></span></p><p id="2b7a360d-33e3-803a-aada-e071639ccae5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">서버가 </span><a target="_blank" rel="noreferrer noopener" class="css-iynyr0" href="https://springdoc.org/">springdoc</a><span class="css-1kxrhf3"> 라이브러리를 통해 OAS를 자동 생성하면, 그 명세를 주기적으로 조회해 연동 문서를 자동으로 업데이트합니다. API의 요청·응답 구조, 인증 방식, 엔드포인트 등의 정보가 서버와 함께 관리되기 때문에 문서와 실제 서비스가 항상 같은 상태로 유지됩니다.</span></span></span></p><p id="2b7a360d-33e3-801b-b4f9-e5dadd1b2f1d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 자동화된 문서 시스템 덕분에 개발자는 “현재 실제로 동작하는 API”를 기준으로 개발할 수 있습니다. 새로운 기능이 추가되거나 파라미터가 변경되더라도 문서가 즉시 반영되기 때문에, 문서와 서비스의 일관성이 항상 유지됩니다. 이 일관성은 결국 개발자가 API를 신뢰할 수 있는 큰 기반이 됩니다. </span></span></span></p><p id="2b7a360d-33e3-80a9-969e-f89b43c585e6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">또한 토스페이먼츠는 연동 문서를 단순한 기술 매뉴얼이 아니라, 개발자가 서비스 전체를 이해할 수 있는 안내서라고 생각합니다. 문서에는 각 API의 역할과 동작 방식, 그리고 서비스 안에서 그 API가 어떤 위치를 차지하는지가 함께 담겨 있습니다. 이를 통해 개발자는 단순히 요청과 응답을 구현하는 데서 그치지 않고, 토스페이먼츠의 결제 시스템이 어떻게 구성되어 있는지를 자연스럽게 이해할 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-80d4-95a2-e789f03bd865" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 완성도 높은 문서를 만들기 위해 토스페이먼츠에서는 Technical Writer가 개발자 관점에서 문서를 검토하고, 문서를 통해 서비스를 더 명확하게 전달할 방법을 고민하며 연동하는 개발자들이 보다 쉽게 서비스를 이해할 수 있도록 돕고 있습니다.</span></span></span></p><p id="2b8a360d-33e3-8043-8497-d4dec58edc2a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-8066-b082-e57e6d9c4a11" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣ 샌드박스</span></span></span></h3><p id="2b7a360d-33e3-806d-bc4c-d3669a9c29dc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">아무리 문서가 잘 되어 있어도, 실제로 한 번도 호출해보지 않은 API를 완전히 이해하기는 쉽지 않습니다. 요청을 보내고, 응답을 받아보며, 그 안에 담긴 데이터가 어떤 의미를 가지는지 직접 확인해야 진짜 ‘감’이 잡히죠.</span></span></span></p><p id="2b7a360d-33e3-80e2-98e4-c4db6bf4e3dd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 이런 개발자 경험을 위해 개발자센터 내에서 바로 실행해 볼 수 있는 </span><a target="_blank" rel="noreferrer noopener" class="css-iynyr0" href="https://developers.tosspayments.com/sandbox">샌드박스</a><span class="css-1kxrhf3">를 제공합니다. 별도의 개발 환경을 세팅하거나 키를 발급받지 않아도, 브라우저에서 즉시 연동을 시작할 수 있는 공간입니다.</span></span></span></p><p id="2b7a360d-33e3-800c-ac22-c527697bd5fe" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">샌드박스는 단순히 예제 코드를 보여주는 수준을 넘어, “보면서, 수정하면서, 실행할 수 있는” 완전한 개발 도구로 한 페이지의 왼쪽에는 실제 API 호출에 사용되는 예제 코드가, 오른쪽에는 코드 실행 결과와 함께 동작하는 UI가 함께 표시됩니다. 개발자는 코드를 직접 수정하고 실행해보면서 결과를 즉시 확인하며 API의 역할과 데이터의 흐름을 눈으로 직접 확인하며 학습할 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-8092-b8b5-fee81bd73692" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 샌드박스의 장점은 ‘빠른 이해’에 있습니다.</span></span></span></p><p id="2b7a360d-33e3-8044-aaa9-fbad4bda7ebb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">별도의 서버 설정이나 인증 과정 없이 브라우저에서 결제를 발생시켜볼 수 있기 때문에, 처음 연동하는 개발자도 전체 결제 프로세스를 손쉽게 이해할 수 있습니다. 테스트를 위해 임시 서버를 세팅하거나 콘솔을 띄우는 시간을 아낄 수 있다는 것도 큰 장점이죠. 개발자는 API 문서를 읽고 머릿속으로 시뮬레이션하는 대신, 직접 코드를 만지고, 눈으로 결과를 확인하면서 배울 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-8055-96d6-f3f0e7ddd6fb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결국 샌드박스는 토스페이먼츠가 추구하는 “경험 중심의 Open API”를 가장 직관적으로 보여주는 공간입니다. 문서로는 전달하기 어려운 서비스의 흐름과 사용 맥락을, 직접 체험을 통해 자연스럽게 이해하도록 돕는 것이죠.</span></span></span></p><p id="2b8a360d-33e3-80ee-b15f-ce5a996dd936" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-80dd-adcd-f19a28f303d2" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3️⃣ 테스트 환경</span></span></span></h3><p id="2b7a360d-33e3-80c1-8dfb-f75660bb6baa" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">연동 문서와 샌드박스를 통해 개발을 마쳤다면, 이제 자신의 서비스 안에서 연동한 기능이 올바르게 동작하는지 테스트해야 합니다.</span></span></span></p><p id="2b7a360d-33e3-8025-9cf8-fbc6f93ff18a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">단순 조회 API라면 크게 부담이 없겠지만, 토스페이먼츠의 Open API는 결제 API로 실제 금전의 이동이 발생하기 때문에 개발자가 마음 놓고 실험하기 어렵습니다.</span></span></span></p><p id="2b7a360d-33e3-8024-941a-d923d5696589" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이처럼 민감한 데이터를 다루는 API는 개발자가 부담 없이 테스트할 수 있는 별도의 환경이 필요합니다. 토스페이먼츠는 이런 부담을 줄이기 위해 실제 운영 환경과 거의 똑같이 동작하지만, 결제는 발생하지 않는 테스트 환경을 제공합니다.</span></span></span></p><p id="2b7a360d-33e3-80fa-aaea-dc81e942d4fd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">테스트 환경을 설계할 때 가장 중요하게 생각한 점은 라이브 환경과의 차이를 최소화하는 것이었습니다. 테스트 결과가 신뢰를 가지려면, 실제 서비스와 동일한 조건에서 실행되어야 하기 때문입니다.</span></span></span></p><p id="2b7a360d-33e3-8030-ab98-dea0f3f7be09" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 동일한 코드 베이스로 라이브 환경과 테스트 환경을 구성하고 있습니다. Spring의 Profile 기능을 이용해 테스트 환경에서는 결제 승인 단계에서 외부 원천사 호출을 Mock으로 대체합니다. 내부 로직은 그대로 수행되지만 실제 결제만 일어나지 않기 때문에, 개발자는 라이브 환경과 거의 동일한 흐름으로 기능을 확인할 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-8042-b1f3-cc38a786e71a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">테스트 환경을 구성할 때 또 하나 중요한 점은 테스트 트래픽이 라이브 환경에 영향을 주지 않아야 한다는 것입니다. 토스페이먼츠는 환경별 서버를 완전히 분리하고, 가맹점의 API 키를 기준으로 게이트웨이에서 요청을 분기합니다. 이 구조를 통해 테스트 트래픽이 라이브 시스템에 간섭하지 않고, 라이브 환경의 안정성을 유지할 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-80a2-8f0d-e0ca3fa9e1af" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결론적으로 아래와 같은 구조로 구성되어 있습니다.</span></span></span></p><figure id="2b8a360d-33e3-8024-9f8f-f89b8f811fef" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/048344e5-15b2-4746-b702-b0d7c5a44f78/image.png" alt="" class="css-1pgssrp"/></figure><p id="2b7a360d-33e3-8076-8cfe-c6f02f6d0b72" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 구축된 테스트 환경에서 개발자는 부담 없이 여러 시나리오를 시도해볼 수 있습니다. 서비스를 출시하기 전 단계에서 충분히 안정성을 확보할 수 있죠. 토스페이먼츠는 개발자가 테스트조차 불안하지 않게 API를 실험하고 검증할 수 있는 환경을 만들고자 합니다.</span></span></span></p><p id="2b8a360d-33e3-8007-914c-ed688469df4f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-803a-a20b-ec8b2809a19d" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">4️⃣ 에러 재현 기능</span></span></span></h3><p id="2b7a360d-33e3-80a4-8662-f818a4707cc5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">API를 테스트할 때는 정상적인 동작만 확인해서는 충분하지 않습니다. 서비스를 운영하다 보면 예기치 못한 오류가 발생할 수 있고, 이때 시스템이 어떻게 반응하는지를 미리 검증하는 것이 중요합니다. 특히 특정 에러에 대한 별도 처리를 구현하는 경우, 에러 상황을 테스트하는 과정은 필수적입니다.</span></span></span></p><p id="2b7a360d-33e3-8047-b3b2-fb6b5bb4a31c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문제는 모든 에러를 직접 만들어내기 어렵다는 점입니다. API 명세를 보고 일부러 잘못된 요청을 보내볼 수도 있지만, 개발자가 API의 모든 에러 케이스를 알고 있을 수는 없습니다. 의도적으로 모든 상황을 재현하는 것은 현실적으로 불가능에 가깝습니다.</span></span></span></p><p id="2b7a360d-33e3-809c-8b9e-ec7316007613" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 이런 문제를 해결하기 위해 테스트 환경에서 에러를 손쉽게 재현할 수 있는 기능을 제공합니다. 테스트 요청의 헤더에 TossPayments-Test-Code 값을 추가하고, 원하는 에러 코드를 지정하면 해당 상황에 맞는 응답이 반환됩니다.</span></span></span></p><p id="2b7a360d-33e3-80e4-bc35-e0b018dfe040" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들어, 카드 번호 결제 API에서 유효기간이 잘못된 상황을 테스트하고 싶다면, </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">INVALID_CARD_EXPIRATION</span></code><span class="css-1kxrhf3"> 에러 코드를 지정해서 요청을 보내면 됩니다. 그럼 실제 결제를 시도하지 않아도 API는 그 오류가 발생한 것처럼 응답을 내려줍니다.</span></span></span></p><p id="2b7a360d-33e3-8046-a0f5-dd5fcd2807ca" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 기능을 통해 개발자는 다양한 에러 케이스를 빠르게 검증하고, 각 상황에서 애플리케이션이 제대로 대응하는지를 확인할 수 있습니다. 예외 처리가 필요한 로직을 사전에 점검할 수 있어, 서비스 운영 중 발생할 수 있는 문제를 미리 방지할 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-8030-8a47-ce7b79045579" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 단순히 API를 제공하는 데 그치지 않고, 개발자가 더 쉽게, 더 안정적으로 테스트할 수 있는 환경을 만들고자 합니다. 에러 재현 기능은 단순한 편의 기능을 넘어, 문제 상황에서도 API가 신뢰할 수 있는 방식으로 동작하도록 만드는 기반이 됩니다.</span></span></span></p><p id="2b8a360d-33e3-80de-b961-e4e046a34ee4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-80fe-aa76-eb8cabbcda31" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">5️⃣ API 로그 조회: 스스로 트러블슈팅하기</span></span></span></h3><p id="2b7a360d-33e3-803d-94ae-f1abc28ea232" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">연동 개발을 하다 보면, 모든 것이 한 번에 완벽하게 작동하기는 어렵습니다. 테스트 중 예상치 못한 오류가 발생하거나, 응답이 기대와 다를 수도 있죠. 이럴 때마다 원인을 확인하기 위해 문의를 남기고 기다려야 한다면, 개발자는 자연스럽게 리듬을 잃게 됩니다.</span></span></span></p><p id="2b7a360d-33e3-809e-a606-d67e044c2c7d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">좋은 개발자 경험은 단순히 문서가 잘 되어 있거나 테스트 환경이 완벽하다고 해서 완성되지 않습니다. 연동 과정에서 발생하는 이슈를 </span><span class="css-q3ktjb">직접 파악하고 해결할 수 있는 경험</span><span class="css-1kxrhf3">, 즉 트러블슈팅의 경험이 함께 뒷받침되어야 합니다.</span></span></span></p><p id="2b7a360d-33e3-801a-979a-d85276b70bc6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 개발자가 스스로 문제를 해결할 수 있도록 개발자센터에서 API 로그 조회 기능을 제공하고 있습니다. 이 기능을 통해 토스페이먼츠 서버가 실제로 어떤 요청을 받았고, 어떤 응답을 내려보냈는지를 직접 확인할 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-805e-aaa6-ceebdcef5ce0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Request body와 header, Response body와 header는 물론, 에러가 발생한 경우에는 해당 에러의 원인과 해결 방법까지 함께 표시됩니다. 즉, 단순히 “에러가 났다”는 수준이 아니라 “왜 났는지, 어떻게 해결할 수 있는지”를 한눈에 파악할 수 있는 구조입니다.</span></span></span></p><p id="2b7a360d-33e3-8093-8a87-dfb25cdac914" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">개발자는 이 로그를 통해 번거로운 문의 절차 없이 스스로 문제를 분석하고 해결할 수 있습니다. 테스트 단계뿐만 아니라 운영 중에도 동일한 방식으로 로그를 확인할 수 있어, 서비스에서 문제가 발생했을 때 원인과 영향 범위를 빠르게 파악할 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-80cf-9f1d-d2b876db385e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 API 로그 조회 기능을 통해 개발자가 스스로 문제를 찾아내고 해결할 수 있는 환경을 만드는 데 집중했습니다.</span></span></span></p><p id="2b8a360d-33e3-80ec-8a0e-ca34edef84b3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-806f-9577-ce93c3767fc7" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">6️⃣ 전문 Technical Account Manager (TAM) 의 실시간 지원</span></span></span></h3><p id="2b7a360d-33e3-809d-a711-d58de7cbef64" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">연동 문서, 샌드박스, 테스트 환경, API 로그 조회 등 다양한 도구를 통해 대부분의 문제를 스스로 해결할 수 있지만, 연동 과정에서 예상치 못한 이슈가 생기거나 고민이 되는 부분이 발생할 때도 있습니다.</span></span></span></p><p id="2b7a360d-33e3-804f-ac3a-cd18210390da" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이럴 때 토스페이먼츠는 Technical Account Manager(TAM)이 실시간으로 소통하며, 가맹점의 상황에 맞는 솔루션을 제시하고 문제를 함께 해결하고 있습니다. 토스페이먼츠의 TAM은 단순히 결제 연동을 돕는 역할을 넘어, 가맹점의 비즈니스 문제를 함께 고민하고 해결책을 제시하며, 가맹점의 성장을 함께 이끄는 동반자의 역할을 수행합니다.</span></span></span></p><p id="2b8a360d-33e3-801e-acb9-fb0818d9f02b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-8013-a047-c0631147aba3" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">7️⃣ API 버저닝: 기존 연동에 영향 없이 진화하기</span></span></span></h3><p id="2b7a360d-33e3-8066-a38c-f36d065a0367" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">수많은 가맹점이 토스페이먼츠의 Open API를 연동해 서비스를 운영하고 있습니다. Open API를 제공하는 입장에서 가장 중요한 것은 API가 언제나 안정적으로 동작할 수 있도록 유지하는 일입니다.</span></span></span></p><p id="2b7a360d-33e3-800b-bf35-ea337e727eaa" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 서비스는 늘 새로운 가치를 제공하기 위해 변화합니다. 이 변화의 과정에서 Open API에도 기능이 추가되거나 스펙이 수정되어야 할 때가 있습니다.</span></span></span></p><p id="2b7a360d-33e3-80c6-b1a2-c6d38ee67eda" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문제는, 이런 변경이 기존에 이미 연동된 서비스에 영향을 줄 수 있다는 점입니다. 예를 들어 해외 결제 기능을 새롭게 도입하면서 결제 금액 필드의 타입이 변경되는 경우처럼, 작은 변경 하나가 연동된 서비스의 오류로 이어질 수 있습니다. 이런 상황을 방지하려면 기존 연동은 그대로 유지하면서도, 새로운 스펙을 함께 제공할 수 있는 구조가 필요합니다.</span></span></span></p><p id="2b7a360d-33e3-80f3-9496-e5bb1a28ac46" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 이를 위해 </span><a target="_blank" rel="noreferrer noopener" class="css-iynyr0" href="https://docs.tosspayments.com/reference/versioning">API 버저닝(API Versioning)</a><span class="css-1kxrhf3">을 적용하고 있습니다. API에 버전을 부여해, 각 버전을 완전히 독립된 API처럼 관리합니다. 서버는 요청에 포함된 버전에 따라 해당 버전에 맞는 요청 검증과 응답 생성을 수행합니다. 덕분에 기존 가맹점의 서비스는 안정적으로 유지되면서, 새로운 기능이나 데이터 구조는 새로운 버전을 통해 확장할 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-800f-893b-e5c16e5ee7a7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">새로운 버전이 출시되면 어떤 변경이 있었는지, 이전 버전과 어떤 차이가 있는지를 </span><a target="_blank" rel="noreferrer noopener" class="css-iynyr0" href="https://docs.tosspayments.com/resources/release-note">릴리즈 노트</a><span class="css-1kxrhf3">를 통해 명확하게 안내합니다. 이를 통해 개발자는 불필요한 시행착오 없이 필요한 시점에 새로운 버전으로 전환할 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-808d-87f3-c964d8394da4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 API를 변화시키는 과정에서도 기존의 안정성과 신뢰를 지키는 것을 최우선으로 합니다. 버저닝은 그 철학을 지탱하는 가장 기본적인 원칙이며, API가 오래도록 안전하게 발전할 수 있는 기반이 되고 있습니다.</span></span></span></p><p id="2b8a360d-33e3-8096-8ccb-e13ea605dec4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b7a360d-33e3-8054-b926-c1b5274ab673" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">3. 보안: 신뢰할 수 있는 시스템 만들기</span></span></span></h2><p id="2b7a360d-33e3-80a4-bd28-c1bca4c481dc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Open API를 제공한다는 것은 데이터와 시스템에 대한 접근 경로를 외부에 개방한다는 의미입니다. 누구나 접근할 수 있는 만큼, 보안에 대한 철저한 관리가 필요합니다.</span></span></span></p><p id="2b7a360d-33e3-8027-b2ce-de5ad4be393b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">권한이 없는 사용자가 민감한 데이터에 접근하지 못하도록 방지하고, 사용자가 언제나 안전하게 시스템을 이용할 수 있도록 보호해야 합니다. 토스페이먼츠는 이러한 원칙 아래, 여러 보안 계층을 통해 Open API 생태계를 지키고 있습니다.</span></span></span></p><p id="2b8a360d-33e3-802a-a294-c190093c79d5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-8065-960b-e66eebb35461" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1️⃣ 인증과 서명</span></span></span></h3><p id="2b7a360d-33e3-80f5-b0ef-c302e8f8c74b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">인증(Authentication)은 API를 사용하는 사용자가 누구인지 식별하는 과정입니다. 인증을 통해 사용자의 권한을 검증하고, 요청이 신뢰할 수 있는 사용자로부터 온 것임을 보장합니다.</span></span></span></p><p id="2b7a360d-33e3-80c2-a595-ce2926512b47" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">API: API Key</span></span></span></p><p id="2b7a360d-33e3-8078-abd5-c5d5e6e29e36" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 가맹점별로 고유한 API Key를 발급하고, API 요청 시 이를 사용해 요청 주체를 식별합니다. 이 인증 과정을 통해 토스페이먼츠는 요청이 어디서 왔는지 명확하게 판단할 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-808d-ad01-fe1565247c58" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Webhook: Webhook-Signature</span></span></span></p><p id="2b7a360d-33e3-80c8-8729-e913387526ef" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">웹훅(Webhook) 역시 동일한 원칙이 적용됩니다. 웹훅은 토스페이먼츠가 가맹점의 서버로 이벤트를 전송하는 구조이기 때문에, 가맹점 입장에서는 “이 요청이 정말 토스페이먼츠가 보낸 것인지”를 검증할 수 있어야 합니다.</span></span></span></p><p id="2b7a360d-33e3-8089-86e5-c949580fe9a4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 위해 토스페이먼츠는 </span><a target="_blank" rel="noreferrer noopener" class="css-iynyr0" href="https://docs.tosspayments.com/reference/using-api/webhook-events#웹훅-헤더">웹훅 헤더로 webhook-signature</a><span class="css-1kxrhf3">를 제공합니다. 웹훅의 payload를 사전에 교환한 키로 서명한 뒤 헤더에 담아 전송하며, 가맹점은 이 값을 통해 실제 토스페이먼츠에서 보낸 요청인지, 또 데이터가 중간에서 변조되지 않았는지를 확인할 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-8054-b259-d587453058c1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 API 제공자뿐 아니라 생태계 안에 있는 모든 참여자의 보안 수준이 함께 강화되어야 한다고 생각합니다. 그래서 웹훅을 수신하는 쪽의 보안 검증 절차까지 가이드하고 있습니다.</span></span></span></p><p id="2b8a360d-33e3-80ef-ab1e-cca1f5e69513" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-8024-8449-e7e6e5d29093" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣ 안전한 통신 채널: TLS</span></span></span></h3><p id="2b7a360d-33e3-809d-bfa3-fce5917efde8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">보안의 기본은 안전한 통신 채널입니다. 인증 키나 민감한 데이터가 전송되는 과정에서 노출된다면 어떠한 인증 방식도 무용지물이 되기 때문입니다.</span></span></span></p><p id="2b7a360d-33e3-8051-9090-d2e977729fbf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 TLSv1.2를 지원할 뿐 아니라 가장 최신 보안 규격인 </span><span class="css-q3ktjb">TLSv1.3</span><span class="css-1kxrhf3">을 전사 모든 네트워크 엔드포인트에 적용하고 있습니다. TLSv1.3은 더 강력한 암호화와 함께 왕복 지연(RTT)이 줄어들어 보안성과 성능을 동시에 향상시킵니다. 현재 토스페이먼츠 전체 트래픽의 80% 이상이 TLSv1.3을 통해 통신하고 있습니다.</span></span></span></p><p id="2b7a360d-33e3-8017-bce7-c45952e27370" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이로써 데이터가 전송되는 과정에서 탈취되거나 변조될 가능성을 크게 줄였습니다. 하지만 HTTPS만으로는 완벽하지 않습니다. 중간자 공격(Man-in-the-Middle Attack)과 같은 위협을 완전히 차단하려면 애플리케이션 레이어에서도 추가적인 보안 조치가 필요합니다.</span></span></span></p><p id="2b8a360d-33e3-80bf-aba5-dc6aefce7ff3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-809b-989f-f2fae96ffc40" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3️⃣ 애플리케이션 레이어 암호화: Encryption Mode</span></span></span></h3><p id="2b7a360d-33e3-8085-948b-d779b7d8b532" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 통신 채널 보안과는 별개로 요청과 응답 데이터를 인터페이스 레벨에서 암호화하는 </span><a target="_blank" rel="noreferrer noopener" class="css-iynyr0" href="https://docs.tosspayments.com/guides/v2/payouts#encryption-%EB%B3%B4%EC%95%88">Encryption Mode</a><span class="css-1kxrhf3">를 제공합니다. 이 기능을 사용하면 요청이나 응답이 중간에서 탈취되더라도 공격자는 그 안의 데이터를 읽을 수 없습니다.</span></span></span></p><p id="2b7a360d-33e3-803a-9261-ebb5b11dc8c0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Encryption Mode는 API 스펙을 그대로 유지하면서 요청과 응답의 데이터 부분만 추가로 암호화하는 방식으로 동작합니다. </span></span></span></p><p id="2b7a360d-33e3-8041-a4b0-dbac5533c26e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 개발자 경험을 해치지 않기 위해 표준화된 방법이자 많은 언어에서 쉽게 사용할 수 있는 JWT 기반의 JWE(JSON Web Encryption) 방식을 선택했습니다.</span></span></span></p><p id="2b7a360d-33e3-80c7-b967-fcafc8e14e66" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">암호화된 데이터의 헤더에는 암호화 알고리즘 정보(alg, enc)와 요청의 생성 시각(iat), 고유 식별자(nonce)가 포함됩니다. 서버는 이 값을 활용해 요청이 생성된 후 일정 시간 이내의 요청만 허용하고, 중복 요청은 거부합니다. 이를 통해 재전송 공격(Replay Attack)을 효과적으로 방지할 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-803a-94bd-f95082477325" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 이 Encryption Mode를 통해 API의 중요도에 따라 다른 보안 정책을 적용하여 가맹점을 보호하고 있습니다.</span></span></span></p><p id="2b8a360d-33e3-8033-9b4f-c25be30526cd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-80ab-a6b2-da8be76d1294" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">4️⃣ Rate Limiting: 악의적 사용 방지</span></span></span></h3><p id="2b7a360d-33e3-80f3-9618-ff34447626b2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 시스템의 자원이 악의적인 사용자에 의해 과도하게 사용되는 것도 방지하고 있습니다.</span></span></span></p><p id="2b7a360d-33e3-80c0-a3ff-e715727dae5c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 위해 </span><span class="css-q3ktjb">Rate Limiting</span><span class="css-1kxrhf3"> 정책을 운영합니다.</span></span></span></p><p id="2b7a360d-33e3-80a0-97ed-feb4f3778e57" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">특정 요청이 비정상적으로 많이 들어오거나 동일한 요청이 반복되는 경우에는 429 에러를 반환해 API의 남용을 차단합니다. 이를 통해 서비스 안정성을 유지하고, API 키가 유출되었을 때 악의적인 사용자가 대량의 결제나 취소를 수행하는 속도를 제한하여 사고 규모를 최소화할 수 있습니다.</span></span></span></p><p id="2b7a360d-33e3-8086-87ad-fe4eee1a0778" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Rate Limiting은 단순히 트래픽을 제어하는 기술이 아닙니다. 예상치 못한 트래픽 급증이나 공격 시도를 빠르게 감지하고, 서비스 전체의 안정성을 지키는 최후의 방어선 역할을 합니다.</span></span></span></p><p id="2b8a360d-33e3-8091-b15e-f55a5b0a82a5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b7a360d-33e3-80c2-b464-dad337709991" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">4. 내부 생태계: 조직이 함께 만드는 API 품질</span></span></span></h2><p id="2b7a360d-33e3-8095-871d-eab117105ec6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">지금까지 Open API를 제공하기 위해 필요한 요소들을 살펴봤습니다. 인터페이스 설계, 외부 생태계 구축, 인증과 보안 등은 모두 필수적인 부분입니다.</span></span></span></p><p id="2b7a360d-33e3-8019-a35f-ebd8a7c4cf1e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 또 한가지 중요한 요소가 있는데 바로 </span><span class="css-q3ktjb">내부 조직의 생태계</span><span class="css-1kxrhf3">입니다. 내부 조직이 Open API를 얼마나 일관성 있고 효율적으로 개발하고 운영하느냐가 결국 외부로 제공되는 품질을 결정하기 때문입니다.</span></span></span></p><p id="2b8a360d-33e3-8023-8493-d43707884d56" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-8086-bb6d-d7d6426dbe44" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ 공통 라이브러리로 일관성 유지</span></span></span></h3><p id="2b7a360d-33e3-80ca-8e34-f1b3126a4e4a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠의 내부 시스템은 여러 도메인으로 나뉘어 있습니다. 결제, 취소, 정산 등 각 도메인마다 별도의 서버가 존재하고, 이 서버들이 각자의 역할에 맞는 Open API를 생산합니다.</span></span></span></p><p id="2b7a360d-33e3-8039-95cf-e71d15cab8f8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 가맹점의 입장에서 토스페이먼츠는 ‘하나의 결제 서비스’로 보입니다. 그렇기 때문에 어떤 도메인의 API를 사용하더라도 동일한 방식으로 인증이 이루어지고, 같은 규칙으로 문서화되며, 같은 형태의 응답을 받을 수 있어야 합니다.</span></span></span></p><p id="2b7a360d-33e3-80cb-945f-fac0cd1d2464" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 일관성을 각 서버가 개별적으로 맞추려면 운영 비용이 급격히 커지는 문제가 발생하는데,  토스페이먼츠는 이런 문제를 해결하기 위해 Open API와 관련된 공통 로직을 내부 라이브러리 형태로 제공하고 있습니다. 각 서버는 이 라이브러리를 통해 인증, 암호화, 에러 응답, 문서 자동화 등 공통된 규약을 쉽게 적용할 수 있습니다. </span></span></span></p><p id="2b7a360d-33e3-8067-8cac-f5ccf273f99d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">build.gradle.kts</span></span></span></p><p id="2b7a360d-33e3-8010-b82c-e9a7b4c42cfe" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Controller 예시</span></span></span></p><p id="2b7a360d-33e3-8036-a40c-c229283589f9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 통해 모든 도메인에서 동일한 품질의 API를 제공할 수 있게 되었고, 각 팀은 비즈니스 로직에 더 집중할 수 있게 되었습니다. 즉, 개발자는 인터페이스 구현에 신경 쓰기보다 고객에게 더 나은 가치를 제공하는 기능 개발에 집중할 수 있는 환경이 만들어졌습니다.</span></span></span></p><p id="2b8a360d-33e3-80cf-9188-cc3bc9592dc2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b7a360d-33e3-80fd-a262-c9cc18fbd7d3" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣ Open API Committee: 품질 기준 유지</span></span></span></h3><p id="2b7a360d-33e3-8005-bb97-efb8c4405c1a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">내부 생태계의 또 다른 축은 </span><span class="css-q3ktjb">Open API Committee</span><span class="css-1kxrhf3">입니다. 토스페이먼츠는 도메인별로 다양한 팀이 API를 개발하고 있기 때문에 조직 전체 차원에서의 기준과 조율이 필요했습니다.</span></span></span></p><p id="2b7a360d-33e3-8022-9921-d7903a37c91e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Open API Committee는 이러한 표준화와 품질 관리를 담당합니다. Committee는 새로운 API가 개발될 때마다 설계 표준과 가이드라인을 검토하고, 보안 정책과 품질 기준을 준수하는지 함께 논의합니다.</span></span></span></p><p id="2b7a360d-33e3-8044-b929-d646c967db17" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 Committee의 역할은 단순한 검토에 그치지 않습니다. 토스페이먼츠 전반에서 Open API가 더 잘 만들어질 수 있는 환경을 조성하고, 지속적인 품질 개선을 이끌어가는 중심 역할을 하고 있습니다. 예를 들어, API 명세 작성 방식이나 버저닝 정책, 테스트 기준과 릴리즈 절차 등도 Committee에서 논의되고 정립됩니다.</span></span></span></p><p id="2b7a360d-33e3-8077-8ca4-df2f5e31f2db" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 통해 각 도메인이 독립적으로 일하더라도 결과물은 하나의 서비스처럼 일관된 품질을 유지할 수 있습니다.</span></span></span></p><p id="2b8a360d-33e3-80a1-9f90-d53acda41457" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b7a360d-33e3-8078-bf8b-ed33a8c52226" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-q3ktjb">마치며: 수십 년을 함께할 API</span></span></span></h2><p id="2b7a360d-33e3-807b-a5f3-e59610928f11" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Open API를 제공한다고 하면 보통 “API를 잘 설계하고 문서만 공개하면 되지 않을까?” 라고 생각하기 쉽습니다. 하지만 실제로는 인터페이스부터 개발자 생태계, 보안, 내부 운영 프로세스까지 생각보다 훨씬 많은 요소들이 유기적으로 맞물려 있어야 합니다. API는 단순한 스펙의 나열이 아니라, 수많은 가맹점과 개발자가 오랜 기간 안정적으로 사용할 수 있는 하나의 서비스이기 때문입니다.</span></span></span></p><p id="2b7a360d-33e3-800c-858c-ede2e85ee768" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 지금도 가맹점에게 </span><span class="css-q3ktjb">더 쉽고, 더 편리하며, 더 믿을 수 있는 Open API</span><span class="css-1kxrhf3">를 제공하기 위해 계속해서 고민하고 있습니다. API 설계 기준을 다듬고, 개발자 경험을 개선하고, 보안과 품질을 높이는 과정은 지금 이 순간에도 이어지고 있습니다.</span></span></span></p><p id="2b7a360d-33e3-80ff-9ddd-eb4d464bffa4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 글을 읽고 계신 분들 중 토스페이먼츠 Open API를 이미 연동해 사용 중인 개발자분도 계실지 모르겠습니다. 앞으로도 여러분의 서비스가 안정적으로 성장할 수 있도록, 그리고 토스페이먼츠의 API가 그 여정의 든든한 기반이 될 수 있도록 오랫동안 함께하고 싶습니다.</span></span></span></p><p id="2b8a360d-33e3-809a-b785-c67891b52142" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b7a360d-33e3-80cd-b699-d09ec3576500" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">✅ </span><span class="css-q3ktjb">이번 아티클은 아래 Toss Makers Conference 25의 세션을 바탕으로 재구성되었습니다.</span></span></span></p><figure id="2b7a360d-33e3-809d-9c63-fdf5f98b403e" class="css-of5acw"><div class="css-oni540"><iframe src="https://www.youtube.com/embed/Ul8uxP4X6ng" frameBorder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" class="css-122y91a"></iframe></div></figure><aside id="2b8a360d-33e3-807f-9116-d3ec7f89a7f6" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">토스페이먼츠와 함께 대한민국의 결제 인프라를 만들어가고 싶다면?</span></span></span></h4><div class="css-1vn47db"><p id="2b7a360d-33e3-802a-8088-c800c46a2082" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">20만 개 가맹점이 신뢰하는 Open API 생태계를 설계하고 운영하는 경험을 하고 싶다면, 토스페이먼츠에 합류하세요. 수십 년을 유지될 시스템을 설계하고, 개발자 경험을 최우선으로 생각하는 팀과 함께 일할 기회가 기다리고 있습니다.</span></span></span></p></div></aside></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[누구나 리서치 하는 시대, UX리서처의 생존법]]></title>
            <link>https://toss.tech/article/uxr-survival</link>
            <guid>https://toss.tech/article/uxr-survival</guid>
            <pubDate>Thu, 27 Nov 2025 09:25:00 GMT</pubDate>
            <description><![CDATA[AI가 인터뷰까지 대신하는 시대, 리서처는 어디에 집중해야 할까요? 변화 속 UX리서처의 진짜 역할을 이야기해보려 해요.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2b8a360d-33e3-80e1-9f9c-e12b6ad1da38" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1odxvuk">“누구나 쉽게 유저를 만나고, AI가 인터뷰까지 대신해주는 시대에, UX리서처는 뭘 할 수 있을까?”</span></span></span></p><p id="2b8a360d-33e3-8065-8d0d-e61bdd8da7d2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8054-a61c-c95269e34dc4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이미 해외 뿐만 아니라 국내에도 AI 모더레이터가 유저와 공감하며 인터뷰를 진행하거나, 대규모 글로벌 리서치를 자동으로 수행하는 도구들이 등장하고 있어요. 게다가 synthetic user(합성 유저) 같은 개념이 보편화되면서, 프롬프트 몇자만 적으면 실제 유저를 리크루팅 하지 않아도 정량조사, 심지어 그룹 인터뷰까지 진행할 수 있는 세상이 되었어요.</span></span></span></p><p id="2b8a360d-33e3-808b-b586-e8570a88d468" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실제로 최근 한 보고서에 따르면 조직 내에서 리서처가 아닌 디자이너·기획자·PM/PO들이 직접 리서치를 수행하는 회사의 비율이 약 84%에 달한다고 해요. 리서치는 더 이상 ‘특수한 역할’이 아닌 ‘모두가 쓰는 도구’가 된 것이죠.</span></span></span></p><p id="2b8a360d-33e3-808d-ad35-e60f4c64430d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그렇다면, </span><span class="css-q3ktjb">이런 변화 속에서 UX리서처의 존재 이유는 무엇일까요? </span><span class="css-1kxrhf3">오늘은 이 질문에 대한 제 생각을, 제품 개발의 세 단계로 나눠 이야기해보려고 해요.</span></span></span></p><p id="2b8a360d-33e3-803a-82ce-ca9de80fe6a0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><p id="2b8a360d-33e3-80e7-8165-c3076dbdb979" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b8a360d-33e3-8065-83de-e67df0b2133e" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">1. 아이디어 단계 - 퍼즐의 테두리부터 맞추기</span></span></span></h2><p id="2b8a360d-33e3-807f-866b-e569b32f1f03" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">여러분도 퍼즐을 맞춰보신 적 있으시죠? 큰 퍼즐일수록 막막하지만, 테두리 조각을 맞추면 전체 그림의 윤곽이 잡히기 시작해요. </span></span></span></p><p id="2b8a360d-33e3-80c0-9a01-e4cec8cf0981" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">제품 기획 초기 단계도 마찬가지예요. 기술도 있고 아이디어도 넘치지만 어디부터 시작해야 할지 막막한 상태죠. 이때 UX리서처는 </span><span class="css-q3ktjb">&quot;유저 관점&quot;이라는 테두리 조각부터 맞추는 작업을 해요. </span><span class="css-1kxrhf3">팀의 관점을 &#x27;우리가 무엇을 만들 수 있을까?&#x27;에서 &#x27;우리는 유저의 어떤 문제를 풀 것인가?&#x27;로 전환시키는 역할을 하는 거죠.</span></span></span></p><figure id="2b8a360d-33e3-806d-a1a8-edaaf7ee6378" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/c422c159-1ac6-4e36-bcfc-43688eb8cab4/스크린샷_2025-11-27_오후_3.01.48.png" alt="" class="css-1pgssrp"/></figure><p id="2b8a360d-33e3-805b-982e-dd5cfa5cb601" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8098-97d1-f33c7604bf91" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">보통 제품을 만드는 입장에서는 새로운 서비스를 기획할 때 시장, 비즈니스 임팩트에 대한 생각부터 하게돼요. 이때 리서처는 사용자 관점으로 서비스의 뼈대를 잡는 역할을 해야해요.</span></span></span></p><ul class="css-uswsmm"><li id="2b8a360d-33e3-803c-bea3-e4cff895ff34" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 </span><span class="css-nvohhk">유저의 어떤 문제</span><span class="css-1kxrhf3">를 해결할 수 있나?</span></span></span></li><li id="2b8a360d-33e3-804f-84a6-dc3a5b6e546a" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-nvohhk">유저는 어떤 새로운 가치</span><span class="css-1kxrhf3">를 얻게 되나?</span></span></span></li></ul><p id="2b8a360d-33e3-8017-90c5-ec74290c34ba" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 질문을 던지면서 우리가 해결할 유저의 문제와 제공할 핵심 가치를 먼저 명확히 정의하는 거죠.</span></span></span></p><p id="2b8a360d-33e3-80a8-8de2-ffd6d400bc11" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8086-9741-d3e0a0fc333a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80b4-ba24-c5dff6531eab" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-80a2-83a3-f78757941e89" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사례: AI 실시간 시장 이벤트 해석 서비스</span></span></span></h3><p id="2b8a360d-33e3-809d-ada4-fa743aca5e85" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 프레임워크로 제품 컨셉을 구체화했던 사례를 소개해볼게요. 바로 </span><span class="css-q3ktjb">인공지능(AI)이 주가 변동의 이유를 직접 해석하고 요약해주는 시장 분석 서비스 ‘AI 시그널’</span><span class="css-1kxrhf3">이에요. </span></span></span></p><figure id="2b8a360d-33e3-8086-8bb6-f4fae5fd7370" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/52482cf3-a8a2-47ba-b792-7440cf016d57/20eb242c-7f68-4414-a357-d0f057695fec.png" alt="" class="css-1pgssrp"/></figure><p id="2b8a360d-33e3-800d-b990-e9cf764304df" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8048-a9e6-ca7e9d636479" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">투자 시장은 방대한 뉴스, 공시, 데이터가 실시간으로 쏟아지며 개인투자자가 의미있는 정보를 선별하기 점점 더 어려워지고 있어요. </span></span></span></p><p id="2b8a360d-33e3-807b-846b-dfae27e54e18" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">만약 AI가 실시간으로 주가 변동 및 시장 흐름을 분석해, 증시가 흔들릴 때마다 그 이유를 알기 쉽게 해석해주는 서비스가 있다면 정보 탐색과 해석에 소모하던 시간을 줄이고, 핵심만 빠르게 파악할 수 있게 될 것이라고 생각했어요.</span></span></span></p><p id="2b8a360d-33e3-80da-a59f-fd49d5220ca8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기획하는 시점에 세웠던 가설은 아래와 같아요.</span></span></span></p><ul class="css-uswsmm"><li id="2b8a360d-33e3-80ce-a12d-f8b1b1cae622" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 서비스를 론칭하면 </span><span class="css-q3ktjb">뉴스 소비와 재방문율</span><span class="css-1kxrhf3">이 높아질 것이다.</span></span></span></li><li id="2b8a360d-33e3-8014-b122-d832ca30ffb4" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이걸 통해 </span><span class="css-q3ktjb">종목 탐색을 더 자주 반복</span><span class="css-1kxrhf3">하게 될 것이다.</span></span></span></li><li id="2b8a360d-33e3-809f-ac01-c3acfc076785" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">비즈니스 임팩트</span><span class="css-1kxrhf3">를 낼 수 있을 것이다.</span></span></span></li></ul><p id="2b8a360d-33e3-80b6-91d8-fab38cfc0fa0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8060-aa62-f1f351c12a7b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">무언가 빠져있지 않나요? 바로 사용자 관점이에요. 제품이 얼마만큼의 임팩트를 낼 수 있는지 가늠해보는 것은 반드시 필요한 과정이에요. 하지만 성공 지표에 사용자 관점이 포함되지 않는다면, 서비스 자체가 길을 잃을 수도 있어요. 극단적인 예를 들어볼게요.</span></span></span></p><p id="2b8a360d-33e3-807a-a47e-c0a091f54995" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">재방문율을 높인다는 목표에만 집중하면, 맥락을 고려하지 않고 무분별하게 콘텐츠를 노출하게 할 수도 있겠죠. 탐색을 더 자주 하게 만든다는 목적에만 집중하면, 사용자의 관심을 끌기 위해 새로운 정보를 계속 보여주게 될 수도 있고요. 이런 UX는 오히려 불필요한 탐색을 하게 하고, 사용자는 나와 관련 없는 내용에 피로감을 느낄 수도 있어요.</span></span></span></p><p id="2b8a360d-33e3-80c4-8e20-d4296ce3a579" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">공급자 입장에서의 가치가 아니라 사용자의 문제와 가치에 집중하는 작업이 필요했어요. 그래서 제품팀과 함께 사용자 관점으로 문제를 정렬해봤죠.</span></span></span></p><p id="2b8a360d-33e3-8013-a6e8-e81136ab4aae" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8038-a22e-cfc47079f981" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">사용자는 어떤 문제를 겪고 있을까?</span></span></span></p><aside id="2b8a360d-33e3-80d4-bddf-d308ff0e91c4" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b8a360d-33e3-80d0-b449-f696b8703689" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">증시 관련 정보는 넘치지만, 나와 연결된 정보를 스스로 골라내야 하는 부담이 크다.</span></span></span></li><li id="2b8a360d-33e3-80ed-85db-ff7b1090dd06" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">주가 변동 이유에 대한 설명이 부족해, 정보 간 연결이 안 되고 탐색에 피로만 누적된다</span></span></span></li></ul></div></aside><p id="2b8a360d-33e3-8016-bb67-fc56f7a4b901" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80c7-b34e-e4bd4e8a70a9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">우리 서비스에서 사용자는 어떤 가치를 느껴야 할까?</span></span></span></p><aside id="2b8a360d-33e3-80f9-92dd-c695c79dcac8" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2b8a360d-33e3-8029-b38a-e7e2bc29c232" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기능적 가치 : 흩어진 시장 정보를 한 곳에 모아, ‘지금 중요한 정보&#x27;만 빠르게 파악할 수 있다.</span></span></span></li><li id="2b8a360d-33e3-801d-8261-e655c70ffdf5" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">인지적 가치 : 시장의 변화를 실시간으로 감지하고 해석해, &#x27;먼저 이해하고 판단할 수 있는 상태&#x27;에 도달한다.</span></span></span></li><li id="2b8a360d-33e3-8033-8d2b-f72bed484d68" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">심리적 가치 : 정보에 끌려다니는 게 아니라 내가 먼저 발견하고 해석하고 있다는 주도감을 느낀다.</span></span></span></li></ul></div></aside><p id="2b8a360d-33e3-8061-9394-d1092a1e663c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8078-abca-c255240f8320" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 정리를 하고 나면, 우리 제품이 향해야 할 </span><span class="css-q3ktjb">명확한 방향</span><span class="css-1kxrhf3">, 일종의 </span><span class="css-1odxvuk">북극성</span><span class="css-1kxrhf3">이 생깁니다. 퍼즐의 테두리를 먼저 맞추면 전체 그림이 또렷하게 보이듯, 문제와 가치를 분리해 정리하는 과정은 제품의 윤곽을 분명하게 만들어줘요.</span></span></span></p><p id="2b8a360d-33e3-80aa-a36c-d63bfa84e7dc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그리고 이렇게 정의된 문제와 가치는 이후 결정하는 모든 액션 아이템의 </span><span class="css-q3ktjb">체크리스트</span><span class="css-1kxrhf3">가 됩니다. 우리가 만든 시안이 정말 사용자의 문제를 해결하고 있는지, 또 우리가 설정한 가치가 실제로 사용자에게 ‘가치’로 받아들여지는지. 사용자를 만날 때마다 이 두 가지를 계속 확인하는 거죠.</span></span></span></p><figure id="2b8a360d-33e3-8081-9c3e-c2dad1e62684" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/9f3eb6ec-9457-496b-bc2f-eb666b49ab76/Frame_228.png" alt="" class="css-1pgssrp"/></figure><p id="2b8a360d-33e3-809a-8198-ecfbbfc4c772" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80ed-868f-dc043c7728bf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-808f-8db1-e255d64e8df1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80b2-803c-f2d16f6d9580" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><h2 id="2b8a360d-33e3-8004-97ba-d714a8e80031" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">2. 개선 단계 - 흩어진 생각을 하나의 방향으로</span></span></span></h2><p id="2b8a360d-33e3-80c4-a497-cfab10bf9ee7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사용자들이 이미 사용하고 있는 제품을 더 나은 방향으로 개선해야 할 때 리서처는 어떤 역할을 해야 할까요? 흩어져 있는 문제를 사용자 목표 중심으로 정리하고, 그에 맞는 개선 기준을 만들어야해요.</span></span></span></p><p id="2b8a360d-33e3-8005-a651-df5091f1a7cc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-802b-8e67-c20e5ce2827e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8088-9730-c6113c39eb33" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-803c-a83f-d9a35c9e8f23" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사례: 토스증권 증시 캘린더</span></span></span></h3><p id="2b8a360d-33e3-803d-843b-e5c30fc9f50d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">증시 캘린더는 주식 시장에 영향을 미칠 만한 주요 경제 이벤트나 기업들의 일정을 달력 형태로 보여주는 기능이에요. 미국 금리 발표, 기업 실적 발표 등을 표시해주죠.</span></span></span></p><figure id="2b8a360d-33e3-805e-8479-df6ca9c0241e" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/bd47c300-efe1-41c3-9c63-fd8c675aeb28/스크린샷_2025-11-25_오후_9.34.00.png" alt="" class="css-1pgssrp"/><figcaption class="css-wgpbp3"><span class="css-jfs1hr">현재 토스증권 증시캘린더</span></figcaption></figure><p id="2b8a360d-33e3-8024-9fc1-dec3d05b1fda" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8098-970d-ccbee2eddbaf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스증권의 증시캘린더에는 다른 곳에서는 보기 어려운 특별한 기능들이 있어요. 예를 들면 한 주의 이슈를 자동으로 정리해주는 </span><span class="css-q3ktjb">AI 주간 요약</span><span class="css-1kxrhf3">, 복잡한 지표를 한눈에 이해할 수 있도록 풀어주는 </span><span class="css-q3ktjb">지표 해석 기능</span><span class="css-1kxrhf3">이 대표적이죠.</span></span></span></p><p id="2b8a360d-33e3-80a1-a22a-c996629e5fd9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-805c-aa8d-ce4a001433ed" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스증권의 캘린더도 처음에는 이런 기능 없이, 말 그대로 </span><span class="css-1odxvuk">일정만 보여주는 단순한 형태</span><span class="css-1kxrhf3">였어요.</span></span></span></p><p id="2b8a360d-33e3-803b-9d46-e07d356e3ef6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그런데 실제 투자자들을 관찰해보니 유튜브, 커뮤니티 등 여러 채널을 돌아다니며 주요 증시 일정을 적극적으로 찾아보고 있더라고요. 사용자의 니즈가 확실하다고 생각했고,  캘린더가 단순 일정 표시를 넘어 투자 흐름을 정리해주는 도구가 된다면 훨씬 좋겠다고 생각했어요. 그래서 기능 고도화를 위한 개선을 시작했죠.</span></span></span></p><p id="2b8a360d-33e3-80c9-a0dd-ca6225762fb1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80df-a892-c1ee2a43eff4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그런데 막상 이 캘린더의 어떤 지점을 개선해야 할지 이야기를 나눠보니, 팀원마다 바라보는 지점이 모두 달랐어요.</span></span></span></p><ul class="css-uswsmm"><li id="2b8a360d-33e3-804c-b87d-cccced87dba2" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">&quot;캘린더인데 캘린더처럼 안 생겼다.&quot;</span></span></span></li><li id="2b8a360d-33e3-80e5-bfd3-d09d5f7fb64e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">&quot;정보 위계가 없다.”</span></span></span></li><li id="2b8a360d-33e3-80dd-b016-cefe0b3276df" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">&quot;이벤트 종류가 너무 많다.”</span></span></span></li></ul><p id="2b8a360d-33e3-80c1-bd04-de6b6f7b5c95" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8016-89b5-fef3d51e199d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 상태로는 무엇부터 해결해야 하는지가 모호한 상황이었죠. 캘린더처럼 보이도록 UI를 바꾸면 될까요? 중요한 정보는 더 강조처리를 해야할까요? 눈앞에 보이는 문제만 따라가다 보면, 개선은 금방 끝나지만 </span><span class="css-q3ktjb">본질은 놓칠 수도</span><span class="css-1kxrhf3"> 있어요. UI를 조금 고치는 수준에서 멈춰버리는 거죠.</span></span></span></p><p id="2b8a360d-33e3-8039-8861-eabaf7c45a31" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 이때 리서처가 문제 해결 구조를 잡아줘야 해요. “어디서부터 어떻게 개선해야 할까?”라는 </span><span class="css-q3ktjb">막연한 질문을 구체적인 단계</span><span class="css-1kxrhf3">로 바꿔주는 거죠.</span></span></span></p><p id="2b8a360d-33e3-809e-b3a9-d62e40ca773c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80ba-b5d7-f6e944de6918" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-80d4-aabb-de1f4493f847" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">① 유저가 이 기능을 통해 이뤄야 하는 것 먼저 정의하기</span></span></span></h3><p id="2b8a360d-33e3-8025-a8bc-e15dc4a16964" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">먼저 여태까지의 리서치 내용을 전부 펼쳐놓고, 사용자들이 ‘증시 캘린더’를 통해 진짜로 이루고 싶은 목표를 다시 정리했어요.</span></span></span></p><p id="2b8a360d-33e3-80fd-978e-f7ebbf22a440" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">캘린더는 단순히 ‘일정 확인 도구’가 아니라, 사용자가 </span><span class="css-q3ktjb">투자를 잘하기 위해 필요로 하는 도구</span><span class="css-1kxrhf3">라는 게 명확해졌죠.</span></span></span></p><aside id="2b8a360d-33e3-80ad-9c1b-df25600741d3" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">사용자의 목표</span></span></span></h4><div class="css-1vn47db"><ol class="css-hokoge"><li id="2b8a360d-33e3-8012-b692-d2419af4f1a3" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1y26ms3">불안 해소</span></code><span class="css-1kxrhf3">
중요한 이벤트를 놓쳐서 나만 뒤처질까 봐 불안하니, 내 투자에 영향을 줄 핵심 이슈를 놓치지 않고 챙기고 싶다.</span></span></span></li><li id="2b8a360d-33e3-807c-9709-c1a0055a6a35" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1y26ms3">자신감 확보</span></code><span class="css-q3ktjb">
</span><span class="css-1kxrhf3">정보가 너무 많아 갈피를 잡기 힘든 상황에서, 시장을 이해하고 내 투자 판단에 확신을 갖고 싶다.</span></span></span></li><li id="2b8a360d-33e3-8086-8818-fa8f2078e4d7" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1y26ms3">매수/매도 타이밍 포착</span></code><span class="css-1kxrhf3">
예측 가능한 이벤트를 미리 알고 대응해 수익을 높이거나 손실을 줄이고 싶다.</span></span></span></li></ol></div></aside><p id="2b8a360d-33e3-80fa-b92c-f941f600b93d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 과정을 통해, 우리가 만드는 캘린더가 해결해야 하는 사용자의 ‘목표’가 선명해졌어요.</span></span></span></p><p id="2b8a360d-33e3-803b-8ba1-c00c8bf28c67" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-807c-848d-ed7d535c2d20" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">② 목표 달성을 막는 ‘방해요인’ 찾기</span></span></span></h3><p id="2b8a360d-33e3-804d-afad-f4e603fa5cbc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">다음 단계는 현재 캘린더가 왜 목표 달성을 돕고 있지 못하는지 파악하는 일이었어요. 문제는 크게 세 가지였어요.
</span></span></span></p><figure id="2b8a360d-33e3-8057-8b27-ebe9d77c3e91" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/819da437-4890-4539-b1e2-930b1047bdd1/Gemini_Generated_Image_38n86z38n86z38n8.png" alt="" class="css-1pgssrp"/></figure><aside id="2b8a360d-33e3-8096-a67d-ef965f179e1b" class="css-nv7vyi"><div class="css-1vn47db"><ol class="css-hokoge"><li id="2b8a360d-33e3-8040-9335-e100a65ff600" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">위계없이 나열된 리스트
</span><span class="css-1kxrhf3">이벤트의 중요도, 영향도, 성격이 뒤섞여 있어 무엇을 먼저 봐야 하는지 판단하기 어려웠어요.</span></span></span></li><li id="2b8a360d-33e3-80ac-ac85-e026ffe2c42a" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">월 단위 일정
</span><span class="css-1kxrhf3">한 달 단위로 모든 정보가 보여져, 당장 이번 주에 중요한 이슈가 무엇인지 파악하기 힘들었어요.</span></span></span></li><li id="2b8a360d-33e3-8092-9e41-d6e517aca336" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">설명 없는 상세 페이지
</span><span class="css-1kxrhf3">이벤트의 의미를 이해하기 어려워서 결국 유튜브/커뮤니티에서 추가 정보를 찾아야 했어요.</span></span></span></li></ol></div></aside><p id="2b8a360d-33e3-80d5-b059-d3ea109fec85" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8029-827d-d64ecd8bec5d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 방해 요소들을 정리하고 나니, 우리가 만들어야 할 제품의 방향이 자연스럽게 그려졌어요.</span></span></span></p><blockquote id="2b8a360d-33e3-8065-9bca-f1baccfede06" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“정보만 모아둔 공간이 아니라,
정보를 이해하고 대비할 수 있는 공간이어야 한다.”</span></span></span></blockquote><p id="2b8a360d-33e3-80a4-a694-e93d045a3b6e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">즉, ‘일정 나열 페이지’가 아니라 투자자가 시장을 이해하고 판단하는 데 도움을 주는 도구가 되어야 했던 거죠.</span></span></span></p><p id="2b8a360d-33e3-80d4-9597-c4e2afd17124" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-80a0-9175-fa667706514d" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">③ “잘 쓴다”의 기준을 먼저 합의하기</span></span></span></h3><p id="2b8a360d-33e3-80d7-9260-dc084e5fab4e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">리디자인을 할 때 가장 중요한 지점이 있는데요. 바로 “이 서비스를 잘 쓴다는 건 무엇인가?”를 먼저 팀원들과 합의하는 거죠.</span></span></span></p><p id="2b8a360d-33e3-8055-bd4e-efed2dd7c5e4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 ‘증시 캘린더를 잘 쓴다’를 이렇게 정의했어요.</span></span></span></p><ul class="css-uswsmm"><li id="2b8a360d-33e3-8090-a9b2-c7a2f4ba325c" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이번 주 어떤 이슈가 있는지 </span><span class="css-q3ktjb">인지하고</span><span class="css-1kxrhf3">,</span></span></span></li><li id="2b8a360d-33e3-807d-a3be-f7cb141ddb4f" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그 이슈가 왜 중요한지 </span><span class="css-q3ktjb">이해하고</span><span class="css-1kxrhf3">,</span></span></span></li><li id="2b8a360d-33e3-8016-9954-e127bdf39d51" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">거기에 맞춰 내 투자 계획을 </span><span class="css-q3ktjb">준비할 수 있다.</span></span></span></li></ul><p id="2b8a360d-33e3-8073-a897-c69c25675d80" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 UT를 진행할 때도 </span><span class="css-q3ktjb">인지 → 이해 → 준비의</span><span class="css-1kxrhf3"> 세 단계가 자연스럽게 이어지는지 계속 점검했어요. 시안을 여러 번 수정하며, 의도가 잘 전달될 수 있는 화면을 계속 찾아 나갔죠.</span></span></span></p><p id="2b8a360d-33e3-80eb-af21-d2599756b3f8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 과정을 거치고 나니, 우리의 디자인이 왜 그렇게 되어야 하는지 모두 설명할 수 있게 되었어요. 우리가 만드는 건 단순히 일정을 나열하는 페이지가 아니라, 투자자가 시장을 이해하고 스스로 판단할 수 있는 기반을 만들어주는 제품이라는 점이 명확해졌죠.</span></span></span></p><p id="2b8a360d-33e3-8015-8472-faf49ff36663" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-803c-9118-c261d46ef907" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 경험을 통해 가장 크게 느낀 건, UX 리서처는 단순히 “더 나은 UX를 찾는 사람”이 아니라는 점이었어요. 이 제품은 어떤 문제를 해결해야 하며, 왜 이런 모습이어야 하는지 기준을 세워주는 사람이었죠. 그리고 그 기준은 언제나 사용자의 목표에서 시작해야 하고요. </span></span></span></p><p id="2b8a360d-33e3-80ff-988a-cb3484cbde68" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80d6-9b44-ea0595ff5590" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8007-ba9e-fdcacd058725" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80ee-a8fd-eb9ba1362e0a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><h2 id="2b8a360d-33e3-8048-b2c3-c9de00742bc6" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">3. 성장이 필요한 단계 - 제품의 정체성을 다시 정의하기</span><span class="css-q3ktjb">
</span></span></span></h2><p id="2b8a360d-33e3-8004-846f-df012e5d9a82" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">마지막으로, 성장이 멈췄을 때는 리서처가 어떤 역할을 하게 되는지 이야기를 해보려고 해요. 제품이 성숙기에 접어들어서 성장세가 완만해진 상황이 아니라, </span><span class="css-q3ktjb">초기 단계에서 더 나아가지 못하고 멈춰버린 경우</span><span class="css-1kxrhf3">에 대한 이야기예요.</span></span></span></p><h3 id="2b8a360d-33e3-805c-8e8a-f6ad25fd5dda" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사례: 토스증권 PC </span></span></span></h3><figure id="2b8a360d-33e3-80c7-aacb-ed2d5732cb3b" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/cf209ea0-db4b-4a57-9cdd-37daf12a827a/toss-securities-mts-wts-apng_(1).png" alt="" class="css-1pgssrp"/></figure><p id="2b8a360d-33e3-8035-9b7d-eead9233fdb0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2024년, ‘토스증권 PC’ 제품이 출시됐어요. 기존 HTS(PC 주식 플랫폼)는 기능도 복잡하고 인터페이스도 난해해, 마치 전문가만 쓸 수 있는 요새 같았죠. 그래서 토스증권은 모바일 앱의 강점인 </span><span class="css-q3ktjb">간결함</span><span class="css-1kxrhf3">과 </span><span class="css-q3ktjb">직관성</span><span class="css-1kxrhf3">을 PC 환경에도 그대로 살려, 누구나 쉽게 거래할 수 있는 경험을 만들고자 했어요.</span></span></span></p><p id="2b8a360d-33e3-8006-b363-f991857f54a5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 기대만큼의 성과는 나오지 않았어요. PC로 거래하고 싶은 유저도 많고, 기능도 분명 충분한데 말이죠. 처음엔 문제를 UX나 기능에서 찾았어요. “찾기 어려운 버튼이 있나?”, “어떤 기능이 부족한가?” 같은 질문들이었죠. 하지만 곧 이 문제는 기능 차원이 아니라, 더 </span><span class="css-q3ktjb">근본적인 질문</span><span class="css-1kxrhf3">에서 출발해야 했다는 걸 깨달았어요.</span></span></span></p><blockquote id="2b8a360d-33e3-8071-9389-f0e73e250511" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 제품이 PC라는 환경에서 제공해야 하는 ‘새로운 가치’는 무엇일까?</span></span></span><div class="css-1k9y0sc"><p id="2b8a360d-33e3-8028-8d98-c69697be34f0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">모바일을 큰 화면에 그대로 옮긴 건 아닐까?</span></span></span></p></div></blockquote><p id="2b8a360d-33e3-80bd-8b80-c22e24373e41" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스증권에서 말하는 ‘심플함’은 사실 모바일이라는 맥락에서 정의된 가치였어요. 모바일은 언제든 빠르게 보고, 한 손으로도 거래할 수 있는 환경이었죠.</span></span></span></p><p id="2b8a360d-33e3-800f-a565-c7ebbe309ae1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 PC는 전혀 다른 세계예요. 책상 앞에 앉아 더 깊게 분석하고, 여러 창을 띄워 비교하고, 시간을 들여 판단하는 공간이죠. 모바일의 강점이 PC에서는 가볍다는 </span><span class="css-q3ktjb">한계</span><span class="css-1kxrhf3">로 느껴질 수 있었던 거예요.</span></span></span></p><p id="2b8a360d-33e3-80a3-8b2b-c0192185330f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">즉, 문제는 UX 세부 요소가 아니라 “</span><span class="css-q3ktjb">이 제품이 어떤 환경에서 어떤 역할을 해야 하는가</span><span class="css-1kxrhf3">”라는 정체성이었어요. 그래서 기능 개선보다 먼저, PC라는 맥락 안에서 이 제품이 어떤 가치를 제공해야 하는지부터 다시 점검했어요.</span></span></span></p><p id="2b8a360d-33e3-80a9-92d9-d27197ff54ba" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8003-beed-c93a9b525e77" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-80d2-a578-e72eca4552c9" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사용자를 만났을 때 보게 된 현실</span></span></span></h3><p id="2b8a360d-33e3-8059-a8b9-cd1b82bc86b1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 이 제품을 가장 잘 쓸 거라고 예상했던 ‘코어 타겟’을 만났어요. 토스증권 앱을 잘 쓰고, PC에서도 투자를 자주 하는 분들이었죠. 그런데 돌아온 얘기는 의외였어요.</span></span></span></p><p id="2b8a360d-33e3-80e2-aabe-f568dd14eb2a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><aside id="2b8a360d-33e3-805f-a68c-c840f33856c5" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1odxvuk">“들어가본 적은 있어요. 근데 모바일로도 다 되니까, 굳이 PC에서 쓸 필요는 없는 것 같아요.”</span></span></span></h4></aside><aside id="2b8a360d-33e3-803b-af96-dba43cd1088b" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1odxvuk">“모바일로 쓰는 게 더 익숙해서요.”</span></span></span></h4></aside><p id="2b8a360d-33e3-803c-a69b-c7ff9b09c454" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">우리가 ‘완전히 새로운 PC 경험’이라고 생각했던 제품은, 사용자 눈에는 사실상 </span><span class="css-q3ktjb">모바일의 복사본</span><span class="css-1kxrhf3">처럼 보였던 거예요.</span></span></span></p><p id="2b8a360d-33e3-8012-966f-e0a38ddde10b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 다시 출발점으로 돌아갔어요. 제품–유저–시장 관계를 입체적으로 이해하기 위해, 모든 정보를 한데 모아 펼쳐봤죠. </span></span></span></p><ul class="css-uswsmm"><li id="2b8a360d-33e3-8005-8a38-d6534e22b464" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">데이터:</span><span class="css-1kxrhf3"> 유저는 어떤 화면에서 이탈하고, 어떤 기능을 거의 쓰지 않을까?</span></span></span></li><li id="2b8a360d-33e3-8063-be41-e3a97d6961fb" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">인터뷰와 설문:</span><span class="css-1kxrhf3"> 그렇게 행동한 이유는 무엇일까?</span></span></span></li><li id="2b8a360d-33e3-804e-b275-f1732060a583" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">다른 제품:</span><span class="css-1kxrhf3"> 다른 PC 주식 서비스는 어떤 가치를 전면에 내세우고 있을까?</span></span></span></li><li id="2b8a360d-33e3-80a0-b638-ffe11006c048" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">시장 트렌드:</span><span class="css-1kxrhf3"> PC 기반 거래 환경은 어떻게 변화하고 있을까?</span></span></span></li></ul><p id="2b8a360d-33e3-800d-85c4-f123f3ca7505" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80e2-90ac-f175c48c3bfe" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2b8a360d-33e3-8034-88bb-fda4adba9494" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">팀과 함께 방향 찾기</span></span></span></h3><figure id="2b8a360d-33e3-804f-b2b4-deb53255f75c" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/c5167e40-1e47-4fbc-900a-ed790cbf63b8/Frame_229.png" alt="" class="css-1pgssrp"/></figure><p id="2b8a360d-33e3-8059-981f-dc61fa16e716" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 모든 인사이트를 바탕으로 제품·디자인·전략·마케팅 등 유관팀과 워크숍을 진행했어요.  지금까지 분석한 내용을 모두가 함께 보고, &quot;지금 우리 제품은 어디에, 어떤 모습으로 존재해야 가장 가치 있을까?&quot;에 대한 다양한 가능성을 탐색했죠. 그 중 우리가 가장 잘 해낼 수 있는 방향으로 생각을 모아나갔어요.</span></span></span></p><p id="2b8a360d-33e3-804c-95c1-c685aa1b5128" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이번 리서치는 특정 기능을 고치기 위한 작업이 아니었어요. 더 중요한 건 </span><span class="css-q3ktjb">제품이 앞으로 어떤 모습으로 성장해야 하는가</span><span class="css-1kxrhf3">에 대한 팀 전체의 합의와 공감대를 만드는 일이었죠.</span></span></span></p><p id="2b8a360d-33e3-806d-9438-cb4ab8b85169" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“남들도 저기 있으니까 우리도 따라가자”가 아니라, “</span><span class="css-q3ktjb">우리의 강점을 고려했을 때 지금 가장 의미 있는 방향은 이곳</span><span class="css-1kxrhf3">이다”를 찾는 과정이었어요.</span></span></span></p><p id="2b8a360d-33e3-809d-9c14-cb39648bfdcc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-807d-9213-fd487c92186f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 경험을 통해, 정체기 단계의 리서치는 단일 정답을 찾는 일이 아니라는 걸 다시 느꼈어요. 제품이 어떤 자리를 차지해야 가장 가치 있을지, 그 </span><span class="css-q3ktjb">본질적인 위치를 탐색하는 과정 </span><span class="css-1kxrhf3">이었죠.</span></span></span></p><hr class="css-1ifza5r"/><p id="2b8a360d-33e3-800c-8234-e7f9083f63c8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b8a360d-33e3-801b-ac0f-c4f7a8c4c4f7" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">결론</span></span></span></h2><aside id="2b8a360d-33e3-80a3-aef8-eaf571b17b77" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">기획 단계 : 사용자의 문제와 가치를 먼저 정의하기</span></span></span></h4><div class="css-1vn47db"><p id="2b8a360d-33e3-8062-8d4d-f7aec8520659" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">제품 개발 과정에서 의사결정의 기준이 되고, 팀이 같은 방향을 바라보게 만들어줘요.</span></span></span></p></div></aside><aside id="2b8a360d-33e3-8083-aa14-c3788f3d4ae4" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">개선 단계 : &#x27;잘 쓴다&#x27;의 정의를 팀과 합의하기</span></span></span></h4><div class="css-1vn47db"><p id="2b8a360d-33e3-8081-9e13-c8b6c9ba6193" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">&quot;무엇을 고칠까?&quot;보다 &quot;유저가 어떤 가치를 느끼려고 이 기능을 쓰는가?&quot;부터 질문해보세요. 그리고 그 목표를 달성하는 걸 &#x27;잘 쓴다&#x27;로 정의하고, 팀 모두가 그 기준에 동의하게 만드는 거예요.</span></span></span></p></div></aside><aside id="2b8a360d-33e3-804a-8dfc-c1e6870ecee7" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">정체기 단계 : 제품의 정체성부터 다시 질문하기</span></span></span></h4><div class="css-1vn47db"><p id="2b8a360d-33e3-802b-b3c1-d7173efb7154" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">개별 기능의 문제가 아니라 제품 전체의 정체성을 다시 질문해야 할 때일 수 있어요. 데이터, 정성 리서치, 시장 분석을 입체적으로 모아보고, 팀과 함께 &quot;우리 제품이 있어야 할 자리&quot;를 찾아보세요.</span></span></span></p></div></aside><p id="2b8a360d-33e3-8063-828a-f24cf0897fc9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8048-8c7e-ec170ef49685" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2b8a360d-33e3-807f-aad7-d9322ef52c4e" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">UX리서처로서 다시 생각해본 것</span></span></span></h2><p id="2b8a360d-33e3-80ae-83cd-da73d124c695" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예전에는 UX 리서처란 리서치 자체를 잘하는 사람, 마치 &#x27;방망이를 깎는 장인&#x27; 같은 역할이라고 생각했어요. 인터뷰 스킬이 뛰어나고 날카로운 인사이트를 잘 발견해서 논리적으로 전달하는 사람이 최고의 리서처라고 믿었죠.</span></span></span></p><p id="2b8a360d-33e3-80d7-83a0-ce560351819f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 토스증권에서 일하며 제가 깨달은 것은 조금 달랐어요. 그런 방망이 깎는 일은 언젠가 쉽게 대체될 수 있는 일이고, 진짜 중요한 것은 리서치 스킬 너머에 있다는 거였어요.</span></span></span></p><p id="2b8a360d-33e3-80a0-97bf-cf5646488dd8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">제품과 산업 전체를 조망하는 &#x27;넓은 시야&#x27;, 그리고 흩어진 팀의 생각을 구조화하고 더 깊은 논의로 이끌어 결국 팀을 움직이게 만드는 &#x27;UX 리더십&#x27; 같은 것들이죠.</span></span></span></p><p id="2b8a360d-33e3-80b9-979a-f38f520db25e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">&quot;그렇다면 지금의 당신은 그런 리서처인가?&quot; 라고 물으시면, 솔직히 자신 있게 &quot;네&quot;라고 답하기는 어려워요. 하지만 저는 토스증권에서 이런 리서처가 되어야 한다는 중요한 사실을 배웠고, 훌륭한 동료들과 함께 매일 부딪히고 성장하며 그렇게 되기 위해 노력하는 중이에요.</span></span></span></p><p id="2b8a360d-33e3-807d-ad91-d255f4caf98b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">오늘 제 이야기가, 여러분이 각자의 자리에서 마주한 질문에 작은 힌트가 되었기를 바라요.</span></span></span></p><p id="2b8a360d-33e3-80ea-9172-ce198bdd035d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-8000-94bd-d12c1b8e4ccc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80e3-a68f-c15862bac7b0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><p id="2b8a360d-33e3-80d9-a26e-cee1879addef" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">✅ </span><span class="css-q3ktjb">이번 아티클은 Toss Makers Conference 25의 세션을 바탕으로 재구성되었습니다.</span></span></span></p><p id="2b8a360d-33e3-8090-85f9-c5f87b10de27" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="2b8a360d-33e3-805f-a1e9-cc6400a73c22" class="css-of5acw"><div class="css-oni540"><iframe src="https://www.youtube.com/embed/qcI_HsqOrLs" frameBorder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" class="css-122y91a"></iframe></div></figure><p id="2b8a360d-33e3-8099-8c61-cb6c8366da76" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2b8a360d-33e3-80fc-9fb6-de79aaedb209" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[LTV를 넘어 서비스의 가치를 측정하는 새로운 지표, MTVi]]></title>
            <link>https://toss.tech/article/toss-da-mtvi</link>
            <guid>https://toss.tech/article/toss-da-mtvi</guid>
            <pubDate>Thu, 20 Nov 2025 01:54:00 GMT</pubDate>
            <description><![CDATA[토스가 자체 개발한 지표 MTVi를 통해 플랫폼 관점에서 데이터를 분석하고 활용하는 방법을 소개합니다.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2a9a360d-33e3-8002-afb2-e7eb167f6c32" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요, 토스 Director (Data Analytics) 우찬희입니다. </span></span></span></p><p id="2aaa360d-33e3-8022-8991-eb04de08b7d0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저는 Data Intelligence and Analytics Team을 이끌면서 전략, UX, IR 등 전사 관점의 데이터 분석하고 더 좋은 의사결정을 위한 분석 프레임워크를 만드는 업무를 하고 있어요.
오늘은 그중에서도 토스코어에서 자체개발한, 그리고 의사결정에 활발히 사용되고 있는 새로운 지표에 대해 소개해드릴게요.</span></span></span></p><p id="2aaa360d-33e3-8058-afdb-c734f3e1566d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2a9a360d-33e3-80d1-9434-f82a11dabc51" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">“이 서비스, 재무적 가치가 있나요?”</span></span></span></h3><p id="2a9a360d-33e3-808b-9582-e563570b31a8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">서비스를 분석하다보면 자주 듣게되는 질문 중 하나입니다.</span></span></span></p><p id="2a9a360d-33e3-8098-bf10-f73ca06e8e17" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">서비스 MAU(Monthly Active User), Retention Rate, AMPU(Average Margin per User) 등 다양한 지표를 볼 순 있지만 이 서비스가 플랫폼 관점에서 얼마나의 가치를 만들어 내는지는 명확히 설명하기 어렵습니다. 특히 유저에게 혜택을 주면서 유도하는 서비스는 더욱 힘들어요.</span></span></span></p><p id="2a9a360d-33e3-8065-8f2f-df04b1800249" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스의 ‘만보기’ 서비스를 예로 들면,</span></span></span></p><aside id="2aaa360d-33e3-8037-9feb-db7d1c67774b" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2aaa360d-33e3-809e-9e63-d640854e1739" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">서비스 사용 유저에게 혜택을 주면서 비용이 발생하지만,</span></span></span></li><li id="2aaa360d-33e3-800f-a82e-e0d377b6dbe7" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이로 인해 유저가 토스앱을 더 자주 접속하고,</span></span></span></li><li id="2aaa360d-33e3-801e-bbca-eafef957aeda" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그러면서 다른 서비스를 사용할 확률이 높아지고,</span></span></span></li><li id="2aaa360d-33e3-80a6-b5bb-c1b2593a6e23" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실제로 다른 서비스를 사용하면서 또다른 매출과 비용이 발생하게 됩니다.</span></span></span></li></ul></div></aside><p id="2aaa360d-33e3-8034-af08-f2aba6c29886" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">만보기 서비스를 사용하지 않았다면 발생하지 않았을 매출과 비용도 만보기 서비스의 가치로 볼 수 있는 것이죠. 이런 부분을 함께 고려해야 하는데 그게 쉽지 않습니다. 마이데이터, 송금 서비스 등 토스에서 제공하는 수많은 제품이 비슷한 조건을 갖고 있어요.</span></span></span></p><p id="2aaa360d-33e3-8018-8210-d8d514d71e8d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a9a360d-33e3-8026-bbc7-f3267ef873f9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 데이터 분석가는 ‘언제’와 ‘얼마나’를 숫자로 증명해야 해요.</span></span></span></p><p id="2a9a360d-33e3-80ed-b00a-f41c681b8fb2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 저희는 이렇게 </span><span class="css-q3ktjb">플랫폼 관점에서 서비스가 만들어내는 재무적 가치를 표현할 방법</span><span class="css-1kxrhf3">을 고민했고, 그 답으로 </span><span class="css-q3ktjb">MTVi (Mid term Value - incremental)</span><span class="css-1kxrhf3"> 지표를 만들었습니다.</span></span></span></p><p id="2a9a360d-33e3-801e-a8ea-fb34de9330dd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2a9a360d-33e3-80b5-9fee-df6211b4f72a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">기존 LTV의 한계</span></span></span></h3><p id="2a9a360d-33e3-80d1-b4af-d203da5cc093" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">UE(Unit Economics) 관점으로 재무적 가치를 이야기할 때 흔히 쓰는 지표로는 </span><span class="css-q3ktjb">LTV(LifeTime Value)</span><span class="css-1kxrhf3">가 있습니다. 하지만 우리가 보고자하는 뷰에서 LTV는 한계가 명확했습니다 .</span></span></span></p><p id="2a9a360d-33e3-8094-970e-fa39f07f532e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1️⃣ 기간이 너무 길다</span></span></span></p><p id="2a9a360d-33e3-809b-a243-cbe14ec4bd55" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">LTV는 보통 3년, 5년, 혹은 ‘평생’을 전제로 계산됩니다.
그러다 보니, 단기간의 서비스 개선이 실제로 어떤 영향을 주었는지를 확인하기 어렵습니다.
빠르게 판단하고 의사결정 해야하는 토스의 특성 상 한계가 있었어요.</span></span></span></p><p id="2aaa360d-33e3-8015-b8a8-ef9e5d35c08d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a9a360d-33e3-80ac-9da2-cb3e6bfa6e92" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2️⃣ 투자·회수 주기가 맞지 않는다</span></span></span></p><p id="2a9a360d-33e3-80bd-9511-e419c8cadb1e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">보통 마케팅을 할 때 CAC(Customer Acquisition Cost)를 LTV의 1/3 수준으로 설정합니다.
LTV는 보통 5년을 보니까 이론적으로 약 1.7년에 걸쳐 투자금을 회수한다는 의미가 됩니다.
토스의 사일로는 짧은 주기로 실험하고 개선하고 이 과정을 수없이 반복합니다.
그래서 빠르게 판단해야 하는 의사결정에는 적합하지 않습니다.</span></span></span></p><p id="2aaa360d-33e3-8031-8852-fa5f5c8d3771" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a9a360d-33e3-80b3-83c5-f5db9acc79ef" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">3️⃣ ‘증분’을 구분하지 못한다</span></span></span></p><p id="2a9a360d-33e3-8024-9769-f97d73f44207" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">LTV는 유저 전체의 평균적인 가치를 계산합니다.
즉, 서비스가 실제로 가치를 ‘얼마나 더’ 높였는지는 알 수 없습니다.
’서비스 효과를 분리해서 측정하는 것’이 불가능했던 거죠.</span></span></span></p><p id="2a9a360d-33e3-8085-85ce-fdfdb6ff4fd4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a9a360d-33e3-8036-8b7a-d6a765f92ac2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 세 가지 이유 때문에, LTV만으로는 서비스의 진짜 임팩트를 설명할 수 없었습니다. 우리는 더 빠르고, 더 구체적으로, </span><span class="css-q3ktjb">서비스를 이용함으로써 만들어진 순수한 변화</span><span class="css-1kxrhf3">를 보고 싶었습니다.</span></span></span></p><p id="2a9a360d-33e3-80ad-9da8-d46c6e66282d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그 한계를 해결하기 위해 등장한 것이 바로 </span><span class="css-q3ktjb">MTVi</span><span class="css-1kxrhf3"> 입니다.</span></span></span></p><p id="2a9a360d-33e3-80c3-bf90-db56133ceae5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2a9a360d-33e3-8074-88da-c9b039bac1a6" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">MTVi란 무엇인가</span></span></span></h3><p id="2a9a360d-33e3-80d8-8094-c48e820853d0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">MTVi는 이렇게 정의됩니다.</span></span></span></p><blockquote id="2a9a360d-33e3-807c-aae2-c2e5d4f99b01" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“유저가 특정 서비스를 새로 경험했을 때,
그로 인해 향후 1년간 만들어내는 순증 재무가치.”</span></span></span></blockquote><p id="2a9a360d-33e3-80bf-bb97-d8b1b3594c3d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">여기서 핵심은 ‘증분(Incremental)’입니다.</span></span></span></p><p id="2a9a360d-33e3-8072-860f-cfd8091f87a8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">단순히 서비스 이용자의 평균이 아니라, </span><span class="css-q3ktjb">그 서비스 때문에 추가로 생긴 변화를</span><span class="css-1kxrhf3"> 측정해요. </span></span></span></p><p id="2aaa360d-33e3-80b0-a65f-f7ba4f391c8a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이건 단순히 수익이 늘었는지를 보는 지표가 아닙니다. 유저가 서비스를 통해 앱 안에서 더 많은 활동을 하고, 다른 기능을 더 자주 쓰며, 결과적으로 더 큰 가치를 만들어내는 </span><span class="css-q3ktjb">전환의 크기</span><span class="css-1kxrhf3">를 수치로 표현한 것이죠.</span></span></span></p><p id="2a9a360d-33e3-80a3-b21c-f197bb80b0cf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2a9a360d-33e3-80a9-b454-ccef4727e17f" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">MTVi를 어떻게 구하는가</span></span></span></h3><p id="2a9a360d-33e3-808c-b40e-f8e0f712d25c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">제일 정확한 방법은 A/B테스트를 하는 것입니다. 하지만 이 주제에서는 A/B테스트를 할 수가 없었어요. 수십 개의 서비스 조합별로 각 서비스를 열고 닫는 것은 사실상 불가능하니까요.</span></span></span></p><p id="2a9a360d-33e3-8020-acc5-fb1090fd9809" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 MTVi는 인과추론 방법론 중 하나인 </span><span class="css-q3ktjb">DID(Difference-in-Difference)</span><span class="css-1kxrhf3"> 추정법을 사용합니다. ‘서비스가 없었더라도 일어났을 변화’를 제거하고, </span><span class="css-q3ktjb">서비스로 인해 발생한 순수한 변화만</span><span class="css-1kxrhf3"> 남깁니다.</span></span></span></p><p id="2a9a360d-33e3-802d-84a3-c31abe187653" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="2a9a360d-33e3-8064-862c-e5e403ee8362" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/8552fe8b-ea17-4043-ae7e-e4e353d214a5/1118-img-inner-techblog-1_(1).png" alt="" class="css-1pgssrp"/></figure><p id="2a9a360d-33e3-8006-8026-f9831f793100" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><div data-table-wrapper="true" class="css-1m7s5mg"><div role="table" class="css-crnt2r"><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1y26ms3">그룹</span></div><div role="cell" class="css-8vl804"><span class="css-1y26ms3">설명</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1y26ms3">NAU(Newly Activated User)</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">특정 월에 서비스를 처음 경험한 유저</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1y26ms3">NEVER</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">특정 월까지 한 번도 경험하지 않은 유저</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1y26ms3">EVER</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">과거에 사용한 적이 있는 유저 (분석에서는 제외)</span></div></div></div></div><p id="2a9a360d-33e3-807c-8bab-d2d4d04750a3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">NAU 그룹은 ‘처음 써본 유저’, NEVER 그룹은 ‘아직 안 써본 유저’. 이 두 그룹은 하나의 차이만 있습니다 - </span><span class="css-q3ktjb">‘그 서비스를 경험했는가, 아닌가’</span></span></span></p><p id="2a9a360d-33e3-807a-b596-cc467b6d1d80" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">DID 추정법을 활용한 비교를 통해 우리는 서비스가 없었더라도 일어났을 변화(자연 성장)를 통제한 채 서비스의 순수한 효과만 볼 수 있습니다. 즉, MTVi는 </span><span class="css-q3ktjb">A/B 테스트가 어려운 환경에서의 준실험(Quasi-experiment)</span><span class="css-1kxrhf3"> 구조로 산출됩니다.</span></span></span></p><p id="2a9a360d-33e3-8094-a209-e2aa14e1eb00" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="2a9a360d-33e3-8032-abf8-f0a2745c9bf5" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/f00df582-1c2f-40b9-ab0a-d1efd559cc4f/image_(14).png" alt="" class="css-1pgssrp"/></figure><p id="2aaa360d-33e3-8029-aff8-e4a5bc530d49" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2a9a360d-33e3-80b4-88da-d6fe0d547740" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">이러면 완전할까?</span></span></span></h2><p id="2a9a360d-33e3-804d-8fe0-faeb962a261a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 단순히 NAU 그룹과 NEVER 그룹을 비교하면 서비스의 효과 뿐만 아니라 </span><span class="css-q3ktjb">유저의 특성 차이</span><span class="css-1kxrhf3">가 같이 측정됩니다. 예를 들어, NAU 그룹은 원래 앱을 자주 여는 유저일 수 있고 NEVER 그룹은 토스를 가볍게 쓰는 유저일 수도 있죠.</span></span></span></p><p id="2a9a360d-33e3-80d6-b5b7-c252bae2bfe7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 이것을 </span><span class="css-q3ktjb">세그먼트 단위로 측정해서 이 점을 보완했습니다. </span><span class="css-1kxrhf3">이것이 DID 추정법의 핵심이자 MTVi의 핵심이에요.</span></span></span></p><div data-table-wrapper="true" class="css-1m7s5mg"><div role="table" class="css-crnt2r"><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1y26ms3">기준</span></div><div role="cell" class="css-8vl804"><span class="css-1y26ms3">변수</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1y26ms3">연령대</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">연령 구간별</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1y26ms3">활동 규모</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">직전 3개월 평균 앱오픈 횟수</span></div></div><div role="row" class="css-1obf64m"><div role="cell" class="css-8vl804"><span class="css-1y26ms3">등등</span></div><div role="cell" class="css-8vl804"><span class="css-1mjnzsq">등등</span></div></div></div></div><p id="2a9a360d-33e3-806d-8f48-d116ff0bf70d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">각 세그먼트 안에서 NAU 그룹과 NEVER 그룹을 비교합니다.</span></span></span></p><figure id="2a9a360d-33e3-805e-a819-e665401bb80d" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/7d22c0d2-40aa-46f6-a193-083bf0ace968/1118-img-inner-techblog-2.png" alt="" class="css-1pgssrp"/></figure><aside id="2a9a360d-33e3-809e-a7c7-f93dbe4cdba5" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Segment 1 → (NAU₁ vs NEVER₁) → MTVi₁
Segment 2 → (NAU₂ vs NEVER₂) → MTVi₂
Segment 3 → (NAU₃ vs NEVER₃) → MTVi₃</span></span></span></h4><div class="css-1vn47db"><p id="2a9a360d-33e3-80a6-8299-eea9cb4b19fc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">...
전체 MTVi = Σ(세그먼트의 MTVi × NAU 내 세그먼트 구성비율)</span></span></span></p></div></aside><p id="2a9a360d-33e3-8067-a20c-f3e16f0477f2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a9a360d-33e3-80db-a38d-cabad04d21b5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 접근 덕분에 MTVi는 단순한 평균값이 아니라 </span><span class="css-q3ktjb">동질한 집단 내에서의 순수한 변화량</span><span class="css-1kxrhf3">을 계산할 수 있습니다. 세그먼트를 나누지 않으면 활동적인 유저에게만 서비스가 효과가 있는 것처럼 왜곡될 수 있어요. MTVi의 완성도는 바로 이 세그먼트 기반 분석에서 나오게 됩니다.</span></span></span></p><p id="2aaa360d-33e3-80ac-9abf-c8ee286e1341" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2aaa360d-33e3-8047-a2ba-dd5384e83a36" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">MTVi의 구성</span></span></span></h3><p id="2aaa360d-33e3-8045-a2cd-fc332321f5a6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">위 방법대로 계산된 MTVi는 이렇게 구성됩니다.</span></span></span></p><aside id="2aaa360d-33e3-801a-97a7-c2267f978364" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">서비스 MTVi = (A) + (B)</span></span></span></h4><div class="css-1vn47db"><p id="2aaa360d-33e3-80b4-8d81-d06b97c9506f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">(A) : 해당 서비스를 지속적으로 쓰면서 발생하는 가치</span></span></span></p><p id="2aaa360d-33e3-8082-91e7-d1e9a591e7a1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">(B) : 해당 서비스 외 다른 서비스로 Cross Activation 되고 사용하면서 발생하는 가치</span></span></span></p></div></aside><p id="2aaa360d-33e3-80af-a2c5-df993d7a8f94" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">처음에 들었던 예시를 다시 가져와보면, 만보기 서비스는 사용하는 유저에게 지속적으로 혜택을 주니까 (A)가 음수일 거예요.
그런데 만약 (B)가 (A)의 절댓값보다 더 크다면(즉, (A) + (B) &gt; 0이라면) 만보기 서비스는 그 자체로는 재무적 가치가 없는 것처럼 보일지라도 플랫폼 관점에서 재무적 가치가 있다고 결론낼 수 있는 것입니다. 마이데이터, 송금 서비스도 같은 관점으로 볼 수 있습니다. 토스에서는 이런식으로 플랫폼 관점에서 서비스의 가치를 바라보고 있습니다.</span></span></span></p><p id="2aaa360d-33e3-8052-959e-ddba192a5255" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2a9a360d-33e3-8059-9280-c264e8fdf6be" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">MTVi가 바꾼 것들</span></span></span></h3><p id="2a9a360d-33e3-80da-9054-ff2eec53eb03" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1️⃣ 명확한 의사결정의 기준</span></span></span></p><p id="2a9a360d-33e3-8047-b6c1-dfc778282f38" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">감이 아니라 데이터로 이야기합니다.
“이 서비스는 유저당 1년간 평균 N 원의 가치를 만든다.”
모든 팀이 같은 단위로 대화할 수 있습니다.</span></span></span></p><p id="2aaa360d-33e3-80a4-9584-cad928a44b9f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a9a360d-33e3-80c0-8d47-c62126bc002f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2️⃣ 투자 효율 판단의 기반</span></span></span></p><p id="2a9a360d-33e3-808b-9971-cc7f254565e9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">MTVi는 마케팅비, 운영비, 신규 투자 판단의 근거가 됩니다.
CAC는 MTVi를 초과할 수 없습니다.
이 기준 덕분에 </span><span class="css-q3ktjb">투입 대비 효율을 정량적으로 평가</span><span class="css-1kxrhf3">할 수 있습니다.</span></span></span></p><p id="2aaa360d-33e3-8090-8a3c-cf8f588091a3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a9a360d-33e3-802c-a5b6-e22509bb12cd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">3️⃣ 공통 언어의 탄생</span></span></span></p><p id="2a9a360d-33e3-80b2-b4b1-ec6aacd4b3b4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">MTVi는 여러 사일로와 팀이 함께 사용하는 지표입니다.
서로 다른 목표를 가진 팀들이
’서비스의 가치’를 같은 언어로 이야기할 수 있게 되었습니다.</span></span></span></p><p id="2aaa360d-33e3-8095-95cd-db1eccdcc36f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a9a360d-33e3-8004-9a31-ea976ca3f98d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">4️⃣</span><span class="css-q3ktjb"> 우선순위 선정 가능</span></span></span></p><p id="2a9a360d-33e3-80e4-af74-f3e04dd02810" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">투자, 마케팅 관점에서 모든게 다 급하고 중요합니다.
MTVi라는 공통의 언어로 어떤 우선순위로 의사결정을 해야하는지 명확히 세울 수 있었습니다.</span></span></span></p><p id="2a9a360d-33e3-80da-96c9-ea87a2afaebc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2a9a360d-33e3-800b-a166-fb829775fc0b" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">MTVi의 다음 단계</span></span></span></h3><p id="2a9a360d-33e3-802f-b08a-f3be56947ceb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">MTVi는 여전히 진화중입니다.</span></span></span></p><aside id="2aaa360d-33e3-800d-8fda-d2936136fb18" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2a9a360d-33e3-80e4-8223-dd7147941072" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">세그먼트 기준 고도화</span></span></span></li><li id="2a9a360d-33e3-8000-b7f2-ef8b0725712b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">서비스별 가중치를 통한 보정</span></span></span></li><li id="2a9a360d-33e3-809b-a26c-fac1cc1fa43b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">서비스 부활, 토스앱 신규, 토스앱 부활 등 다양한 관점의 MTVi 생성 및 생태계 구축</span></span></span></li><li id="2a9a360d-33e3-80b9-ba9d-cb28de710dd6" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">DID 외의 Matching, Causal ML 같은 다양한 인과추론 방법론 적용</span></span></span></li></ul></div></aside><p id="2a9a360d-33e3-804a-a60f-c16819c58443" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 고도화가 진행된다면, MTVi는 단일 지표가 아니라 토스 전체의 서비스가 만들어내는 ‘가치 지도(Value Map)’가 될 것이라고 생각합니다. 그 지도 위에서 우리는 “어떤 서비스의 액션으로 유저들이 움직이고, 이 움직임이 어떤 영향력이 있는지”를 데이터로 명확히 볼 수 있게 될 거예요.</span></span></span></p><p id="2a9a360d-33e3-8037-a119-de58577a6810" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2a9a360d-33e3-80c8-956d-f6b97e79fe8d" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">마무리하며</span></span></span></h3><p id="2a9a360d-33e3-8086-bcdc-cc6bed71818d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">MTVi의 진짜 의미는 단순히 그 숫자에 있지 않습니다. 플랫폼 관점에서 각 제품의 변화가 유저의 행동에 어떤 영향을 끼치는지를 이해할 수 있는 것에 있어요.</span></span></span></p><p id="2a9a360d-33e3-80a3-b810-d7860da3d3c2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희 팀은 이런 지표를 개발하고 분석 프레임워크를 만들고 있습니다. 방대한 데이터를 바탕으로 유저의 행동을 분석하고, 이를 바탕으로 합리적인 의사결정을 이끄는 것에 관심이 있으신 분들은 많은 관심 부탁드립니다.</span></span></span></p><p id="2a9a360d-33e3-80eb-a20f-ecc503e4ae88" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a9a360d-33e3-8040-a393-d4b771feecb7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a9a360d-33e3-80e4-be96-ceaa97506dbc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a9a360d-33e3-8023-897b-c6423e8d841d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a9a360d-33e3-80f6-b174-e72d585d0cff" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a9a360d-33e3-8085-ab85-edc38639a79a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[100년 가는 프론트엔드 코드, SDK]]></title>
            <link>https://toss.tech/article/payments-legacy-3</link>
            <guid>https://toss.tech/article/payments-legacy-3</guid>
            <pubDate>Fri, 14 Nov 2025 06:00:00 GMT</pubDate>
            <description><![CDATA[SDK를 개발하며 마주한 다양한 상황과 기술적 어려움, 그리고 이를 해결하기 위해 우리가 설정한 핵심 가치와 달성해온 과정을 공유합니다.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="2a5a360d-33e3-8007-8a9c-f66ca2a6c68c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1odxvuk">만약 여러분이 결제를 연동하는 개발자라면, 어떤 걸 해야한다고 생각하시나요? </span></span></span></p><p id="2a5a360d-33e3-80e6-9db4-ce2d9e8d75ef" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실제로 결제창을 띄우고 PG사에 결제를 요청하려면 꽤 번거로운 작업이 필요합니다. UI 구현, 보안을 위한 인증 흐름, HTML Form과 결제 요청을 위한 비동기 처리, 그리고 다양한 예외 처리까지 고려해야 하죠. 이 과정에서 많은 개발자가 어려움을 겪습니다.</span></span></span></p><p id="2a5a360d-33e3-8063-9d17-f1818087e4e7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠는 이러한 문제를 해결하기 위해 결제 SDK를 만들었습니다. 개발자가 보다 쉽게 결제를 연동할 수 있도록 번거로움을 줄이는 것이 목표였죠. 그렇다면 토스페이먼츠 결제 SDK를 사용하면 실제로 결제를 어떻게 구현할 수 있을까요?</span></span></span></p><p id="2a5a360d-33e3-8052-bb8d-f636465868b9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a5a360d-33e3-8012-967a-e93d77a795ea" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="29da360d-33e3-80f2-835c-eb741c7afafd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">단 몇 줄로 결제 화면을 띄우고 PG사로 결제를 요청하는 코드가 완성되었습니다. 간단하지 않나요? 하지만 이런 연동 경험을 제공하기까지 SDK의 운영과정은 쉽지 않았는데요. 몇가지 사례를 소개해 볼게요.</span></span></span></p><p id="2a5a360d-33e3-8061-869d-efa66a472e2f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="29da360d-33e3-807c-aa43-e505cbc1ef29" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-q3ktjb">FE 개발과는 다른 SDK 개발의 특수성</span></span></span></h2><h3 id="29da360d-33e3-8009-ade2-f82e81135eed" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">1️⃣ 로그를 추가했는데 결제가 안된다?</span></span></span></h3><p id="29da360d-33e3-8031-9604-f7530ad2ec86" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">운영 중 SDK 특정 메서드의 사용량을 분석하고 싶을 때가 있습니다. 저희도 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">getSelectedPaymentMethod</span></code><span class="css-1kxrhf3">라는 메서드의 사용량을 확인해 달라는 요청을 받았고 이를 위해 메서드 호출 시 로그를 보내도록 코드를 추가했습니다.</span></span></span></p><p id="29da360d-33e3-806e-9f32-fb9442f64698" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그런데 가맹점에서 “결제가 안된다”는 문의가 들어왔습니다. 원인은 해당 가맹점이 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">getSelectedPaymentMethod</span></code><span class="css-1kxrhf3">를 매우 짧은 간격으로 여러 번 호출하고 있었기 때문이었죠. 로그 추가로 인해 네트워크 의존성이 생겼고, 요청이 브라우저에 빠르게 쌓이면서 결제 페이지 전체가 느려지고 다운되는 문제가 발생했습니다. 결과적으로 추가한 로그가 우리 로그 서버에 부하를 주는 상황이 된 셈입니다.</span></span></span></p><p id="2a6a360d-33e3-80da-a8fd-eede55fff8c8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29da360d-33e3-807f-a8b7-e60f831d675c" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">2️⃣ startsWith is not a function</span></span></span></h3><p id="29da360d-33e3-80ed-bb80-cb8404f29792" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">특정 가맹점에서는 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">customerKey</span></code><span class="css-1kxrhf3">라는 고객 식별자 대신 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">secretKey</span></code><span class="css-1kxrhf3"> 라는 클라이언트에 노출되면 안되는 보안키를 실수로 넣는 경우가 있었습니다. 가맹점의 보안 또한 토스페이먼츠의 중요한 가치이기 때문에, </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">customerKey</span></code><span class="css-1kxrhf3">에 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">secretKey</span></code><span class="css-1kxrhf3">가 들어가면 에러를 발생시키도록 처리했습니다.</span></span></span></p><p id="2a6a360d-33e3-80d7-8b37-fa2b121dbf91" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">문제는 일부 가맹점에서 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">customerKey</span></code><span class="css-1kxrhf3">에 string 타입이 아닌 number를 보내면서 발생했습니다. number 타입에는 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">startsWith</span></code><span class="css-1kxrhf3"> 없기 때문에 해당 메서드를 호출하는 부분에 문제가 발생했고 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">startsWith is not a function</span></code><span class="css-q3ktjb"> </span><span class="css-1kxrhf3">에러가 발생한 것이죠.</span></span></span></p><p id="2a6a360d-33e3-80a4-844c-d4ec56c0259f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a6a360d-33e3-8012-ae95-ee0e906e6ffe" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이처럼 SDK 개발은 일반 프론트엔드 개발과 많이 달랐습니다.</span></span></span></p><ul class="css-uswsmm"><li id="2a6a360d-33e3-80a8-a256-cf7526ab56d6" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">가맹점 코드 속에 깊숙이 박혀</span><span class="css-1kxrhf3">, 가맹점 코드와 동일한 수명을 가졌고</span></span></span></li><li id="2a6a360d-33e3-80a1-84cb-e65a6e9de158" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">가맹점의 연동 방식과 런타임 환경에 따라</span><span class="css-1kxrhf3"> 호출되었습니다.</span></span></span></li><li id="2a6a360d-33e3-80f8-8a90-eb36f0064e86" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">뿐만 아니라 결제 연동의 시작점인 만큼,</span><span class="css-q3ktjb"> 가맹점과 만나는 기술 커뮤니케이션의 시작점</span><span class="css-1kxrhf3">이었습니다.</span></span></span></li></ul><p id="2a6a360d-33e3-805f-9b27-efd3dfe3d86b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">SDK는 단순히 API를 소비하는 것이 아니라, </span><span class="css-q3ktjb">결제 서비스를 제공하는 API 제공자의 역할</span><span class="css-1kxrhf3">까지 수행해야 했습니다.</span></span></span></p><p id="2a9a360d-33e3-80a0-a981-cc943215c6d8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2a8a360d-33e3-804f-844e-e199a1a39292" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">V1 SDK</span></span></span></h2><p id="2a9a360d-33e3-80fb-bb93-fdc9ba17133d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 SDK의 특성 측면에서 기존 토스페이먼츠의 SDK는 많은 한계와 문제점들이 존재했습니다.</span></span></span></p><aside id="2aba360d-33e3-80ad-9aa9-da95d3cad339" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2a9a360d-33e3-80f6-938a-dce5e0bae58d" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가맹점의 환경에서 가맹점에 의해 호출됨을 인지하지 못한 채 기능 개발. 해당 문제점을 추적하고 감지하는 시스템의 미비.</span></span></span></li><li id="2a9a360d-33e3-8069-877f-f7b7bc729a1f" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가맹점들의 다양한 요구사항을 수용할 수 있는 확장성있는 소프트웨어 구조 부족. 비용이 저렴한 개발 선택으로 인한 여러 맥락 오염.</span></span></span></li><li id="2a9a360d-33e3-806b-9e7f-c47bbf3bcd18" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사용자의 경험을 고려하지 못한 API 제공. 잘못된 내용의 docs과 문제지점의 파악 어려움. 가맹점 개발자와 토스페이먼츠의 커뮤니케이션 비용 증가.</span></span></span></li></ul></div></aside><p id="2a9a360d-33e3-80e2-aa71-dd520e7a1a9b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">시스템의 미비로 버그는 잦은 빈도로 발생하고 가맹점의 요구사항으로 소프트웨어는 여러 맥락과 복잡도를 감당해야만 했어요. 또한 최적의 연동 경험이라고 하기에는 연동 개발자들의 고충은 여전히 존재했습니다. 저희는 이런 V1 SDK의 한계를 해결해야 하겠다는 문제의식을 갖기 시작했고 새로운 SDK, V2 SDK를 만들자라는 결론을 도출했어요.</span></span></span></p><p id="2a5a360d-33e3-80b7-a894-f9d43d206d18" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="2a5a360d-33e3-8056-8109-c793ea5d855a" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-q3ktjb">V2 SDK의 시작</span></span></span></h2><p id="2a5a360d-33e3-800c-a385-d73b87c4e416" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">앞선 사례를 통해 SDK에 새로운 가치가 필요하다는 것을 느꼈습니다. 기존 목표인 “가맹점 연동을 쉽게”에서 나아가, </span><span class="css-q3ktjb">안정성, 확장성, 명확성</span><span class="css-1kxrhf3">을 목표로 하는 고도화된 SDK가 필요했죠.</span></span></span></p><aside id="2aba360d-33e3-8072-96bc-e0c9bfbd01f9" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">🛡️ 안정성</span></span></span></h4><div class="css-1vn47db"><p id="29da360d-33e3-80bb-be33-ea5f66d3c5fd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">결제 장애가 나지 않고 결제가 꾸준히 나면서 가맹점의 비즈니스 연속성 보장
</span><span class="css-1kxrhf3">→ SDK는 언제 어디서 호출되어도 안정적으로 서비스를 제공해야 한다</span></span></span></p><p id="2aba360d-33e3-80b6-a254-ff79efb0179e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="29da360d-33e3-8080-9f1d-c717ef3842fb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">🔧 확장성</span></span></span></p><p id="29da360d-33e3-8020-bc83-f3d60253c137" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">다양한 요구사항을 수용하며 가맹점의 비즈니스 확장성 보장
</span><span class="css-1kxrhf3">→ 다양한 가맹점의 커스터마이징 요소를 확장 가능하게 처리해야 한다</span></span></span></p><p id="2aba360d-33e3-80a1-9626-e2217c4b2430" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="29da360d-33e3-803b-9876-c73d55b3fcdf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">📝 명확성</span></span></span></p><p id="29da360d-33e3-808d-a7c2-eda40306273d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">최고의 연동 경험을 제공함으로써 가맹점 개발자의 생산성 보장
</span><span class="css-1kxrhf3">→ 가맹점 개발자가 예측할 수 있는 명확한 인터페이스와 동작을 확보해야 한다</span></span></span></p></div></aside><p id="29da360d-33e3-804a-ad75-e9d0d9c57de5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 저희는 SDK가 지켜야 할 핵심가치를 세우고 이를 위한 장치들을 V2 SDK에 하나둘씩 마련해가기 시작했습니다.</span></span></span></p><p id="2aba360d-33e3-805a-b313-ee2565eb4028" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="29da360d-33e3-80ce-b586-c38634f6a4d5" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-q3ktjb">안정성을 향해</span></span></span></h2><p id="29da360d-33e3-8057-a5ad-ed5eb99fa1a8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">앞서 말한 사례들처럼 SDK는 가맹점에 의존적인 라이프사이클을 가지기 때문에, 예측하기 어려운 문제들이 발생했었습니다. 일반적인 QA로는 알 수 없는 문제들이 존재했죠. 그래서 안정성을 중요한 목표로 세우고, 사이드 이펙트가 없도록 안전 장치를 하나씩 마련하기 시작했습니다.</span></span></span></p><p id="2a6a360d-33e3-804e-a592-f66fb207422d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">우선 가장 빠른 피드백을 확보할 수 있는 테스트 코드에서부터 안정성을 챙겼습니다. 비즈니스 로직을 검증하는 단위 테스트를 300개 이상 작성했고, 여러 결제 제품의 유즈케이스를 기반으로 E2E 통합 테스트 500개 이상을 확보했습니다. 또, 배포 후에도 문제 상황을 빠르게 탐지하고 회복 탄력성을 확보하기 위해 촘촘하게 작성된 로그를 기반으로 ElasticSearch를 이용한 대시보드와 얼럿 시스템을 구축했습니다.</span></span></span></p><p id="2a8a360d-33e3-8034-aa30-d6ad03899381" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29da360d-33e3-80b0-9616-d94f9dd50e98" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">하지만 테스트코드만으로는 부족했다</span></span></span></h3><p id="29da360d-33e3-80fc-bdc5-e9abd1401a95" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그럼에도 불구하고 안정성을 확보하는 과정은 쉽지 않았습니다. 다양한 가맹점의 환경과 유스케이스를 파악하는 데 한계가 있었죠. 가맹점의 연동 방식은 항상 저희의 상상을 뛰어넘었어요. 그래서 저희는 ‘좀 더 빠르고 쉽게, 결제 이상 지점을 파악할 수 없을지’ 고민하기 시작했습니다.</span></span></span></p><p id="29da360d-33e3-8047-995a-c62030725515" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">운영을 하면서 느낀 건, 결제 장애는 일정한 패턴이 있다는 것이었습니다.</span></span></span></p><ul class="css-uswsmm"><li id="29da360d-33e3-8002-afde-c3e227a717e8" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">대부분 잘 작동하지만 특정 가맹점에서만 안된다.</span></span></span></li><li id="29da360d-33e3-804a-a3e1-e12123a5baaf" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">PC에서는 되는데 모바일에서 안된다. 웹에서는 잘 되는데 웹뷰에서는 안된다.</span></span></span></li></ul><p id="29fa360d-33e3-8050-aea5-ed83fe9b55c0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">특정 연동 환경을 가진 가맹점이나 특정 런타임 환경에서 예측하지 못한 문제가 발생했고, 이는 개발자가 가장 예측하기 어려운 영역이었습니다. 매 개발마다 가맹점의 모든 연동 유즈케이스와 환경을 파악하는데에는 무리가 있었고 해당 지점에서 가장 많은 장애가 발생했죠. 그래서 우리는 이러한 예측 불가능 지점을 빠르게 파악하기 위한 토스페이먼츠 결제제품만의 </span><span class="css-q3ktjb">특별한 모니터링 도구</span><span class="css-1kxrhf3">를 만들었습니다.</span></span></span></p><p id="29fa360d-33e3-80d8-b9eb-fe4ba157c200" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29da360d-33e3-80d5-9680-f6caf2dc40f0" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Global Trace ID와 모니터링 CLI</span></span></span></h3><p id="2a6a360d-33e3-80c4-8152-d4368e09d85b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스페이먼츠에는 </span><span class="css-q3ktjb">global trace id</span><span class="css-1kxrhf3">라는 지표가 있습니다. FE, BE 관계없이 가맹점 결제 페이지에서 결제를 시작하고 성공하기까지 모든 과정을 global trace id와 함께 로깅하고 있습니다. 이 식별자만 검색하면 시스템 레이어 전체를 쉽게 추적할 수 있습니다. global trace id에 대한 소개는 </span><a target="_blank" rel="noreferrer noopener" class="css-iynyr0" href="https://www.youtube.com/watch?v=Ifz0LsfAG94">SLASH 23 - 분산 추적 체계 &amp; 로그 중심으로 Observability 확보하기</a><span class="css-1kxrhf3">에서 더 자세하게 확인해 볼 수 있어요.</span></span></span></p><p id="2a6a360d-33e3-80ae-9558-cd22a131ec91" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">우리는 이 global trace id를 이용해서 </span><span class="css-q3ktjb">결제 요청은 했지만 실제로 결제가 성공하지 못한 건</span><span class="css-1kxrhf3">을 추릴 수 있었습니다. 시스템에 처음 들어온 결제 요청 로그와 시스템의 마지막 수행인 결제완료 로그를 매핑해서 그 추이를 한눈에 볼 수 있었습니다. 그리고 그 로그를 </span><span class="css-q3ktjb">가맹점별, 런타임 환경별로 구분</span><span class="css-1kxrhf3">하여 결제 성공 평균치를 계산하고, 자체 해석을 더한 모니터링 CLI를 개발했습니다.</span></span></span></p><p id="2a6a360d-33e3-8001-9a6b-e1271febf125" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a6a360d-33e3-80a4-b8c1-eba8d372309c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">배포 이후에 모니터링 CLI를 실행한 결과를 함께 볼게요.</span></span></span></p><figure id="2a5a360d-33e3-8010-ae49-fffdcd736142" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/9f433311-7662-421e-8fc7-186c71944a07/inner-techblog-1.png" alt="" class="css-1pgssrp"/></figure><p id="2a5a360d-33e3-80af-abd2-eda6a8c41ecf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">진영몰의 결제 성공건이 41건에서 0건으로 중단되었습니다. 배포 전에는 평균 41건 성공했는데, 배포 후에는 어떤 요청도 성공하지 못한 것이죠.
</span></span></span></p><figure id="2a6a360d-33e3-80be-85b6-cfb1e437ff65" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/38c9ef2c-f90e-4f9c-8263-aca44d771fb4/inner-techblog-2.png" alt="" class="css-1pgssrp"/></figure><p id="2a5a360d-33e3-80db-b3af-fe39f4b4cde1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그리고 해당 가맹점의 런타임 환경별로도 추이를 확인할 수 있습니다. 배포 전에는 PC Chrome, Android WebView, iOS Webview 에서 결제가 잘 발생했지만 배포 후에는 환경 관계없이 모두 0건이 된걸 확인할 수 있습니다.</span></span></span></p><p id="2a8a360d-33e3-80fa-b675-c0a19a9ad374" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="29da360d-33e3-8036-ac2c-f1170a68423d" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-q3ktjb">확장성을 향해</span></span></span></h2><p id="29da360d-33e3-8066-82ad-ea54695d267f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">SDK가 가맹점과 소통하는 창구인만큼 가맹점들마다 존재하는 다양한 요구사항을 수용해야 했었습니다. 특정 가맹점에게만 유효성을 검증 로직을 추가해줘야 한다던가, 특정 가맹점의 경우 카드 할부 개월수를 고정한다던가, 특정 가맹점의 프로모션 정보를 특정 값으로 고정해 줘야할 때가 존재했고 저희는 이런 요구사항을 어떻게 개발해야 할지 고민해야 했습니다.</span></span></span></p><h3 id="29da360d-33e3-80d3-b4e1-ed55f8c3badf" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">if문은 싸다</span></span></span></h3><p id="29da360d-33e3-8014-acb0-d306009c3079" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">처음에는 간단한 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">if</span></code><span class="css-1kxrhf3"> 문으로 처리하려 했습니다. 실제로 초기 코드는 아래처럼 구성되어 있었습니다.</span></span></span></p><p id="2a5a360d-33e3-8013-9e09-f16771df6809" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="29da360d-33e3-809a-8c8a-d9a60eab76f4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 요구사항이 늘어나니 상황이 달라졌습니다.  요구사항이 늘어나면서</span><span class="css-q3ktjb"> 중요한 비즈니스 로직을 파악하기 어려워지고, 특정 가맹점의 요구사항을 추적하는 것도 비용이 늘어나기 시작했어요. </span><span class="css-1kxrhf3">중요 비즈니스 로직을 읽어야 할 때는 특정 가맹점의 요구사항을 함께 읽어야 하고 반대로 특정 가맹점의 요구사항을 읽어야 할 때는 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">isTossMall</span></code><span class="css-1kxrhf3"> 와 같은 분기문을 code search를 해서 잡히는 파일들을 전부 열어서 파악해야 했습니다.</span></span></span></p><p id="29fa360d-33e3-8062-abd9-d97e24713ae6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29da360d-33e3-8084-a803-cd0435e68a1e" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">조립 가능한 SDK</span></span></span></h3><p id="2a6a360d-33e3-80eb-b64f-ff44560bbc4a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 이 문제를 해결하기 위해 소프트웨어가 구성하는 </span><span class="css-q3ktjb">메시지에</span><span class="css-1kxrhf3"> 집중했습니다. &quot;결제를 요청한다&quot;는 메시지만 남기고 핵심 로직과 특정 가맹점의 로직을 분리하기 시작했어요. 모든 가맹점은 동일한 메시지를 따르지만, 필요하다면 자신만의 구현을 가질 수 있도록 만들었습니다.
</span></span></span></p><figure id="2a6a360d-33e3-80af-91df-e7e4619cb0be" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/9f683a53-31cc-4b7f-baf9-e3000cbd2d1d/inner-techblog-3.png" alt="" class="css-1pgssrp"/></figure><p id="2a6a360d-33e3-8089-baff-c53cbcb40f39" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저희는 구현을 </span><span class="css-q3ktjb">작은 레고 블록 단위</span><span class="css-1kxrhf3">로 구성해서, 가맹점의 요구사항을 레고 블록을 바꾸는 것만으로 대응할 수 있도록 설계했습니다. 블록 간의 중복은 줄이고, 가맹점의 커스텀 요구사항은 한 블록으로 격리했습니다. 이렇게 하면 모든 커스텀 요구사항을 더 적은 비용으로 빠르게, 기존 동작에 영향을 미치지 않고 구현할 수 있다고 </span><span class="css-1kxrhf3">생각했</span><span class="css-1kxrhf3">어요.</span></span></span></p><p id="2a5a360d-33e3-8036-a711-d00a057703d2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29da360d-33e3-80ff-bd72-de70cfc5d038" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">조립의 단위</span></span></span></h3><p id="29da360d-33e3-80bd-acdd-d479040b06d5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그런데 레고 블록이라면 서로 맞물리는 부분이 있고, 그 부분끼리 조립을 해야 하는데요. 그러다보니 자연스럽게 어떤 기준으로 맞물리는 부분을 만들어야 할지 고민하게 되었어요. 이를 위해 소프트웨어 설계 관점으로 문제를 고민하다가  업계에 유명한 격언에서 인사이트를 얻었습니다. </span><span class="css-q3ktjb">&quot;변경의 원인이 되는 곳을 따라서 경계를 그어라&quot;</span><span class="css-1kxrhf3">. 저희는 이 격언을 따라서 두 가지 경계를 긋고 세 가지의 계층을 도출 할 수 있었습니다.</span></span></span></p><ul class="css-uswsmm"><li id="29da360d-33e3-8064-881a-dde5d264d52b" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Public Interface Layer:</span><span class="css-1kxrhf3"> 가맹점이 사용하는 메서드의 형태에 따라 바뀌는 곳. 이 레이어의 코드는 가맹점과의 메시지에 따라 변경됨을 의미.</span></span></span></li><li id="29da360d-33e3-8073-8911-db388672d318" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Domain Layer:</span><span class="css-1kxrhf3"> 도메인 정책, 비즈니스 로직에 따라 바뀌는 곳. 이 레이어의 코드는 우리의 도메인, 비즈니스로직에 따라 변경됨을 의미.</span></span></span></li><li id="29da360d-33e3-803f-ab9a-d6c019110601" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">External Service Layer:</span><span class="css-1kxrhf3"> 서버 API, Web API 등 외부 의존성에 따라 바뀌는 곳. 도메인이나 가맹점과의 메시지가 아닌 외부 의존성의 변경이나 기술적 변경에 따라 변경됨을 의미.</span></span></span></li></ul><p id="2a5a360d-33e3-802a-acc7-d8215d86340a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29da360d-33e3-80a6-8f79-cb957f6aafe1" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">‘결제를 요청한다’는 메시지의 구현</span></span></span></h3><p id="29da360d-33e3-80eb-836a-dedb7eb6f1bb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">‘결제를 요청한다’는 메시지가 각 레이어마다 어떤 구현을 가지는지 한번 살펴볼까요?</span></span></span></p><p id="2a5a360d-33e3-8005-a37a-c2498ddb082a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">첫 번째로 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">Public Interface Layer</span></code><span class="css-1kxrhf3"> 계층입니다. 가맹점과 약속한 인터페이스를 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">WidgetPublicInterface</span></code><span class="css-1kxrhf3"> 라는 인터페이스로 명시하고 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">WidgetSDK</span></code><span class="css-1kxrhf3"> 라는 구현체는 해당 인터페이스를 구현하도록 작성했습니다. Public Interface Layer 계층은 가맹점과의 인터페이스를 관심사로 삼고 이를 변경의 원인으로 삼기 때문에 인터페이스의 약속을 검증하거나 도메인 계층으로 메시지를 보내기 전에 도메인 계층에 맞게 번역하는 역할을 수행합니다. 반대로 도메인 레이어에서 나온 응답값을 가맹점과 약속한 인터페이스에 맞게 번역하는 역할 또한 수행하죠.</span></span></span></p><p id="2a5a360d-33e3-8011-b52d-d4c426cf0361" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a5a360d-33e3-8056-9d08-eb2ba558457c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">두번째는 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">Domain Layer</span></code><span class="css-1kxrhf3"> 계층입니다. 여기에서는 가맹점과의 인터페이스나 특정 기술에 대한 구현의 맥락 없이 “결제를 요청한다” 라는 유즈케이스의 일련의 비즈니스 로직이 기술되어있습니다. </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">Domain Layer</span></code><span class="css-1kxrhf3"> 계층은 도메인을 변경의 원인으로 삼기 때문에 도메인이나 비즈니스 요구사항이 변경될때 해당 변경사항을 반영하는 역할을 수행합니다. 반대로 스스로 수행하기 어려운 로직은 External Service Layer의 외부의존성에 요청하는 역할을 수행합니다.
</span></span></span></p><p id="2a5a360d-33e3-80d4-aed7-c323d8720ee4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">마지막으로 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">External Service Layer</span></code><span class="css-1kxrhf3"> 계층입니다. 여기에서는 서버, 웹 api 등등 기술에 대한 의존성을 가진 계층이고 SDK의 도메인이 아닌 로직들을 이 계층에서 담당하고 있습니다. 도메인이나 가맹점과의 계약이 아닌 이외의 의존성들의 기능을 사상하고 변경을 반영하는 </span><span class="css-1kxrhf3">역할을 </span><span class="css-1kxrhf3">수행합니다.</span></span></span></p><p id="2a5a360d-33e3-8063-bf04-c945173967e6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="29da360d-33e3-80bd-bac8-cbbf700097fb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">여기에서 중요한점은, 경계를 넘어선 구현을 참조할 때는 모두 인터페이스를 기준으로 의존성을 주입받는 형태로 구성되어 있다는 것입니다. 예를 들어서 Domain Layer에서 External Service Layer로 저장된 customer key를 요청한다고 할 때, 세션 스토리지에서 가져올지 로컬 스토리지에서 가져와 같은 구현사항은 런타임 시점에 의존성을 조립할 때 결정되고 Domain Layer 에서는 오직 customer key를 불러온다는 인터페이스만 참조하는 형태라는 것이죠. 레이어 간의 경계에서는 의존성을 역전시키고 각 레이어의 구현에 대한 의존성을 끊어냄으로써 좀 더 유연하고 확장성있는 구조를 확보했습니다.</span></span></span></p><p id="2a5a360d-33e3-807b-b971-f0bda4ec5a7c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29da360d-33e3-808a-9da1-d6910f0f7e52" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">표준 SDK + 커스텀 SDK</span></span></span></h3><p id="29da360d-33e3-80c9-8f31-fbe43e559c68" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">특정 가맹점에게 유효성 검사를 추가해 달라는 예시로 돌아와 보겠습니다. 유효성 검사는 비즈니스 로직이기 때문에, 진영몰을 위한 새로운 도메인 코드 블록만 만들어서 유효성 검사 로직을 추가하면 됩니다.</span></span></span></p><p id="29da360d-33e3-80ff-9b49-c15a25f24133" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그리고 기존에 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">StandardWidgetRequestPaymentUsecase</span></code><span class="css-1kxrhf3">라는 레고 블럭을 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">JinyoungMallWidgetRequestPaymentUsecase</span></code><span class="css-1kxrhf3"> 레고 블럭으로만 변경하고, 해당 가맹점에게 커스텀 SDK를 제공하면 표준 SDK를 오염시키지 않고 새로운 요구사항을 깔끔하게 대응할 수 있게 되죠.</span></span></span></p><p id="2a5a360d-33e3-80da-84df-f96b8e3f249b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="29da360d-33e3-8010-890d-e97d6d9d5679" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-q3ktjb">명확성을 향해</span></span></span></h2><p id="29da360d-33e3-80b3-b570-e2b791d6d00e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">다음은 가맹점이 결제 요청을 보내는 파라미터의 일부를 가져와 봤습니다. 실제로 아래와 같은 많은 결제 파라미터들을 </span><code style="font-family:Consolas, Menlo, Monaco, source-code-pro, &quot;Courier New&quot;, monospace;font-size:0.9em;background-color:var(--adaptiveOpacity100);border:1px solid var(--adaptiveOpacity200);border-radius:3px"><span class="css-1mjnzsq">requestPayment</span></code><span class="css-1kxrhf3"> 메서드를 통해 보내고 있었고 이때 각 파라미터 각각마다 많은 제약사항과 의미가 담겨있었습니다. 가맹점 개발자들을 이 내용을 모두 학습하여 페이먼츠와 약속한 형태로 해당 값들을 전달하고 있었습니다.</span></span></span></p><figure id="2a5a360d-33e3-80b0-8bf2-cd756d629859" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/1669f912-5e63-4a14-bacb-b170cebd1dc4/image.png" alt="" class="css-1pgssrp"/></figure><p id="2a8a360d-33e3-80b9-830b-d010e4ab558d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런점들에서 파라미터, 그리고 더 나아가 SDK 인터페이스는 단순한 함수가 아니였습니다. 어떤 값을 어떻게 보내야 하는지 가맹점과 SDK가 약속한 하나의 계약이자 명세였죠. SDK와 가맹점은 오래 함께 하는 사이인 만큼 그 접점에 있는 인터페이스는 단순한 인터페이스가 아니라 가맹점과 우리 사이의 &#x27;공식 언어&#x27;이자 공동으로 학습해야 하는 지식이었습니다.</span></span></span></p><p id="2a5a360d-33e3-801a-8ad4-eb6e9ff199d3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29da360d-33e3-8093-938c-da827623c922" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">인터페이스를 계약으로 바라보다</span></span></span></h3><p id="29da360d-33e3-80fe-93e5-c69f15e56bac" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 저희는 인터페이스를 함수를 넘어서 </span><span class="css-q3ktjb">계약</span><span class="css-1kxrhf3">으로 바라보기 시작했습니다. 약속을 더 명확하게 하기 위해 계약으로 분리함으로써 구현에 오염되지 않고 오직 인터페이스만 존재하는 구조로 경계 설정했어요. 인터페이스가 계약이 됨으로써 </span><span class="css-q3ktjb">코드 그 자체이면서도 문서이고 스펙이고 약속이 되게</span><span class="css-1kxrhf3"> 만들었습니다. 단순히 함수의 시그니처를 인터페이스로 분리한 게 아니라. jsdoc을 이용해서 함수가 반환하는 에러와 응답, 타입으로 나타내기 어려운 명세를 담은 주석까지 가맹점과의 모든 &quot;약속&quot;을 명시했어요.</span></span></span></p><p id="2a5a360d-33e3-8082-a8b8-d55a55b1e13d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="29da360d-33e3-802e-9008-ebbe3250cdb4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">또, 이런 계약을 npm 패키지로 분리하여 단일 계약 패키지의 형태로 </span><span class="css-1kxrhf3">제공했</span><span class="css-1kxrhf3">습니다. 구현과의 물리적 경계를 형성해서 구현과의 변경의 시점을 분리했습니다.</span></span></span></p><p id="2a5a360d-33e3-808c-93a0-ddca1570d2fd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 SDK 인터페이스를 &#x27;계약&#x27;으로 분리하면서 이 계약을 다양하게 활용할 수 있었는데요. 그 중 몇 가지 활용을 이야기해 보겠습니다.</span></span></span></p><p id="2a5a360d-33e3-805b-8212-e7afdfa3a85c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29da360d-33e3-8016-821b-fd93ccc304a7" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Git이 계약서이자 히스토리북이 되다</span></span></span></h3><p id="2a5a360d-33e3-8044-89ac-f50d651cbb34" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기존 v1 SDK의 문제들 중 가장 큰 문제는 히스토리 파악이 어렵다는 것이었습니다. 이 파라미터가 왜 추가되었는지 어떤 논의를 거쳤는지 왜 이렇게 변경되었는지를 알 수 없었죠. 슬랙이나 노션을 찾아가며 이전에 개발한 개발자가 구두로 논의한게 아닌 어딘가 기록을 해두었기를 바랄 수 밖에 없었습니다.</span></span></span></p><p id="2a5a360d-33e3-80ca-bb28-dacd9f277116" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 문제를 해결하기 위해 인터페이스를 관리하는 git을 계약 명세서이자 히스토리북의 역할이 되도록 만들었습니다. 계약을 관리하는 git의 커밋 컨벤션을 만들어서 git diff만 봤을 때 누구에 의해 어떤 계약이 언제 변경됐는지 알 수 있게 했죠. 아래는 이런 git을 관리하기 위한 커밋 컨벤션의 일부를 가져왔습니다.</span></span></span></p><aside id="2aaa360d-33e3-80ca-9c07-f4e44009a2d1" class="css-nv7vyi"><div class="css-1vn47db"><h3 id="2aaa360d-33e3-80fb-9819-eeb2f7f14fa3" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">Convention</span></span></span></h3><ul class="css-uswsmm"><li id="2aaa360d-33e3-80ea-84db-d536227bd377" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하나의 커밋은 단 하나의 변경만을 담아야 합니다.</span></span></span></li><li id="2aaa360d-33e3-8082-b3ee-de213988ff05" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">커밋 메시지만 보고도 변경의 의도를 충분히 파악할 수 있도록 자세히 작성해 주세요.</span></span></span></li><li id="2aaa360d-33e3-804b-8408-ce81d07ef8a3" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">변경을 수월하게 추적하기 위하여 파일의 이름이나 위치가 변경되어 replace가 일어나는 경우 별도의 커밋으로 분리해 주세요. 그렇지 않으면 기존 파일에 존재하던 git history를 추적하기 어렵습니다.</span></span></span></li><li id="2aaa360d-33e3-809d-a190-c6f65f50204d" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">PR을 작성하기 전에 변경된 파일들의 git history 를 열고 3년 뒤 내가 아닌 누군가가 이 메시지들을 읽었을 때 변경의 의도를 충분히 파악할 수 있을지 예상해 보세요.</span></span></span></li><li id="2aaa360d-33e3-80f6-b364-d54a3ff6694e" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">커밋 메시지 작성 예시</span></span></span><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2aaa360d-33e3-8052-b391-c112e7292319" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">(변경 내용) 제품 [결제위젯, 브랜드페이, 결제창] 요소 [API, 파라미터, 응답]의 목적을 [추가, 변경, 삭제]</span></span></span><div class="css-1vn47db"><p id="2aaa360d-33e3-8049-9baa-edc0f8fbaad6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">▪ e.g. 결제위젯 WidgetPaymentMethodWidget Model 에 ‘customRequest’ 이벤트가 삭제됩니다.</span></span></span></p></div></li><li id="2aaa360d-33e3-8081-bbf0-f822781fd2de" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">(변경의 이유) XXX 가맹점의 YYY 유즈케이스를 지원하기 위해 ZZZ 를 변경합니다. - 요구사항이 인입된 슬랙이나 요구사항 설계 문서가 있다면 함께 첨부해 주세요.</span></span></span></li><li id="2aaa360d-33e3-8089-80bb-f73c0c48fdcf" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">(설계 의도) 기존에 XXX 는 YYY 로 주로 사용되는 파라미터였지만… - 계약이 왜 이런 형태로 설계되었는지 의사결정 과정을 함께 기록해주세요. Open API Spec Review 문서가 있다면 함께 첨부해 주세요.</span></span></span></li></ul></div></li></ul></div></aside><p id="2a5a360d-33e3-80b4-af06-c8e151047280" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그리고 해당 컨벤션을 기반으로 작성된 실제 git diff 중 일부입니다. 실제로 통화를 나타내는 currency라는 파라미터의 diff를 추적해보면 USD 통화가 언제 누가 왜 추가되었는지를 알 수 있었죠. 이를 통해서 문서나 사내 메신저 등 중복된 출처가 아니라 Git이 히스토리의 단일 신뢰 지점이 되게 할 수 있었고 예전엔 특정 사람만 알고 있던 히스토리를 이제는 시스템 차원에서 추적할 수 있었습니다.</span></span></span></p><figure id="2a5a360d-33e3-803d-afa0-c9ede49adb95" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/4b2d7ec3-9127-498d-92e1-9a50996f80d6/image.png" alt="" class="css-1pgssrp"/></figure><p id="2a5a360d-33e3-8097-9e2b-e261550e5da7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29da360d-33e3-8067-9c97-fb9586d4823f" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">살아있는 연동 문서</span></span></span></h3><p id="2a5a360d-33e3-80cd-bb6b-d73e6d541341" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">기존 V1 SDK의 문제들 또 하나의 문제는 문서와 실제 동작이 다른 경우가 발생한다는 것이었습니다. 매번 사람이 수동으로 작성하는 SDK 문서는 개발 사이클과 멀어지고 관리되지 못하는 경우가 빈번히 발생했고 누군가 제보를 주거나 개발자가 발견하지 않으면 docs에 작성된 내용은 수정되기가 어려웠습니다.</span></span></span></p><p id="2a5a360d-33e3-8007-842a-c88db591e482" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 위해 Typescript 기반으로 작성된 계약을 활용하여 문서를 자동으로 생성될 수 있도록 만들었습니다.  Typescript의 컴파일러를 이용해서 Typescript Interface와 Jsdoc을 읽고 이를 Mdx 로 추출해서 정적 서비스를 서빙하는 docs 서비스에 업로드 하는 방식으로 변경했습니다. 그리고 해당 로직을 계약에 변경사항이 생길 때마다 CI를 통해 자동으로 돌아갈 수 있도록 설정했습니다.</span></span></span></p><p id="2a5a360d-33e3-807a-b218-ce20d00fae32" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실제로 docs에서 제공하고 있는</span><a target="_blank" rel="noreferrer noopener" class="css-iynyr0" href="https://docs.tosspayments.com/sdk/v2/js#paymentrequestpayment"> v2 SDK docs</a><span class="css-1kxrhf3">는 이 계약 인터페이스를 기반으로 자동으로 생성된 문서입니다. 실제로 계약이 변경되면 아래의 docs에도 해당 변경사항이 자동으로 반영되게 됩니다.</span></span></span></p><figure id="2a5a360d-33e3-8098-9c9b-c9e7df2dbea9" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/804a400a-1d3b-4286-91de-4d5219e4a962/image.png" alt="" class="css-1pgssrp"/></figure><p id="2a5a360d-33e3-80a5-a2bf-c872a50d0e4f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="29da360d-33e3-803c-8ff8-e17d1c7a7ef2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 통해 구현된 코드의 시그니처가 문서와 동일하게 됨으로써 문서와 코드 간의 불일치를 해결할 수 있었습니다. 또한 문서를 자동 생성되게 만듦으로써 별도의 연동문서를 관리하는 관리 비용도 감소 할 수 있었습니다. 무엇보다 이제 계약이 가맹점 개발자에게 공개된다는 의미가 생겼고 이를 통해 좀 더 가맹점 개발자에게 친화적인 형태로 계약이 발전할 수 있었습니다.</span></span></span></p><p id="2a5a360d-33e3-8083-b755-f19bc2463a19" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29da360d-33e3-8064-8b2d-d5884da934ed" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">유효성 검증 계층</span></span></span></h3><p id="2a5a360d-33e3-80aa-b9f0-edf7762bc904" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">v1 SDK를 운영하면서 느낀건 연동하는 개발자가 무엇이 잘못된건지 알기 어렵다는것이었습니다. 필수값을 보내지 않았거나 약속된 타입이 아닌 타입을 보내는 등등 여러 연동실수를 했지만 쉽게 이해할 수 없는 에러메시지로 인해 문제지점을 찾기 어려웠습니다. docs에 작성된 내용이 었지만 여러 내용들에 가려져 놓치기 쉽다보니 이런 연동 실수는 자주 발생하곤 했었어요.</span></span></span></p><p id="2a5a360d-33e3-80b2-9565-ea5186233bc7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a5a360d-33e3-8006-9e7c-c8965f24a7d9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">마찬가지로 해당문서를 해결하기 위해 Typescript 기반으로 작성된 계약을 활용하기로 했습니다. Typescript 컴파일러를 이용해 Typescript Interface를 zod schema로 변환하고 이를 기반으로 런타임 시점에 Validation 할 수 있도록 작성했습니다. 또 이때 발생하는 에러의 원인을 명시적으로 나타낼 수 있도록 에러메시지를 변환하여 어떤 필드가 어떻게 잘못되었는지를 알 수 있게 만들었습니다.</span></span></span></p><p id="2a5a360d-33e3-8025-8d6c-c34eccf217af" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 통해서 잘못된 연동에 대해서 개발자에게 빠르게 피드백 할 수 있었습니다. 어떤 부분이 문제인지를 에러를 이용해서 피드백하고 이를 통해서 SDK의 연동 경험을 향상 시킬 수 있었어요. 뿐만 아니라 잘못 연동한 값이 SDK의 도메인 계층까지 흘러들어가지 않도록 하는 오류방지계층의 역할하는 이점 또한 챙길 수 있었습니다.</span></span></span></p><p id="2a5a360d-33e3-8034-9dff-f4c71a7f9c1a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="29da360d-33e3-809c-9a8b-e3745f3de35e" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">V2 SDK를 만들며</span></span></span></h2><p id="29da360d-33e3-80a6-bacf-decec0e75598" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이렇게 V2 SDK를 만들면서 다양한 임팩트들을 얻을 수 있었습니다.</span></span></span></p><aside id="2aba360d-33e3-80bb-b0c6-f0b3467bf75f" class="css-nv7vyi"><div class="css-1vn47db"><ul class="css-uswsmm"><li id="2a5a360d-33e3-800a-bbb2-e89ab3c4ba68" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">최적화된 모니터링 도구와 촘촘한 그물망을 만듦으로써 안정적이고 회복탄력성을 갖춘 서비스가 될 수 있었고 이를 통해 가맹점의 비즈니스 연속성을 보장할 수 있었습니다.</span></span></span></li><li id="2a5a360d-33e3-80e6-aefb-eb4abac02a7d" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">조립 가능한 SDK를 확보함으로써 다양한 가맹점의 커스텀 요구사항을 수용할 수 있었고 이를 통해 가맹점의 비즈니스 확장성을 보장할 수 있었습니다.</span></span></span></li><li id="2a5a360d-33e3-8053-ae94-ea98591fbc42" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가맹점과 약속한 인터페이스를 계약으로 명세하고 이를 연동문서와 유효성 검증으로 최적의 연동 경험을 제공할 수 있었고 이를 통해 가맹점 개발자의 생산성을 확보할 수 있었습니다.</span></span></span></li></ul></div></aside><p id="29da360d-33e3-80ca-bac6-ddadacd82cac" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29da360d-33e3-807d-9821-c292f64d4ddd" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">마치며</span></span></span></h3><p id="2a5a360d-33e3-802c-b9b9-ead11ac4cefd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결제 SDK를 만든다는 건 단순히 결제 서비스를 제공하는 일이 아니었습니다. 가맹점의 비즈니스가 안정적으로 돌아가도록 돕고, 개발자가 결제를 손쉽게 연동할 수 있게 만드는 것. </span></span></span></p><p id="2a9a360d-33e3-8064-bc98-faf2a5db7f93" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결국 </span><span class="css-q3ktjb">개발 경험을 설계하면서</span><span class="css-1kxrhf3">, </span><span class="css-q3ktjb">안정적인 결제를 보장하고</span><span class="css-1kxrhf3">, 새로운 기능과 커스터마이징 요구도 부담 없이 수용할 수 있는 </span><span class="css-q3ktjb">확장 가능한 플랫폼</span><span class="css-1kxrhf3">을 만드는 일이었습니다. 여러 원칙을 기반으로 V2 SDK를 다시 쌓아 올리며, 우리는 기술적 완성도 뿐 아니라 </span><span class="css-q3ktjb">가맹점에게 신뢰받는 SDK</span><span class="css-1kxrhf3">가 되기 위한 기준을 세울 수 있었습니다.</span></span></span></p><p id="2a5a360d-33e3-809a-8d13-fcb957157c75" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a5a360d-33e3-80d5-bd38-eb07bfeb605b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="29da360d-33e3-80d9-a42a-f4d6936e8cbc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">✅ </span><span class="css-q3ktjb">이번 아티클은 아래 Toss Makers Conference 25의 세션을 바탕으로 재구성되었습니다.</span></span></span></p><figure id="2aba360d-33e3-80ca-806b-c62d41a507d5" class="css-of5acw"><div class="css-oni540"><iframe src="https://www.youtube.com/embed/IVApSbfFvzs" frameBorder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" class="css-122y91a"></iframe></div></figure></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[토스에서 가장 안 좋은 경험 만들기]]></title>
            <link>https://toss.tech/article/42221</link>
            <guid>https://toss.tech/article/42221</guid>
            <pubDate>Fri, 07 Nov 2025 06:11:00 GMT</pubDate>
            <description><![CDATA[비즈니스와 사용자 경험, 두 가지를 모두 챙기려면 어떻게 해야할까요? 둘 사이 교집합을 찾아낸 과정을 알려드릴게요.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="29ba360d-33e3-80f8-8a55-eca66d0957f6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="29ba360d-33e3-8023-82b9-f3596db02078" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a4a360d-33e3-80d1-b674-f2061dd952f2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스에서 혜택 서비스를 맡고 있는 이현정입니다. 혜택 서비스는 포인트를 주는 서비스나 광고들이 모여 있는 탭이에요. 저는 그곳에 있는 광고와 서비스들을 오랫동안 담당해왔고, 지금은 그로스 도메인에서 토스 유저를 늘리는 일에 집중하고 있어요. 이 글에서는 비즈니스와 사용자 경험, 두 가지를 모두 챙기는 교집합을 찾아가는 과정에 대해 들려드릴게요.</span></span></span></p><p id="2a4a360d-33e3-80d2-aeac-c663c516a470" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a4a360d-33e3-8030-9839-ea2f9ed6712b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">외부 디자이너를 만나면 항상 듣는 말이 있어요.</span></span></span></p><blockquote id="2a4a360d-33e3-80a6-9499-fd4ff5b6d098" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“토스 디자이너들은 광고 싫어하죠?”
“비즈니스냐 사용자냐, 결국 뭘 선택하나요?”
“사용자 경험을 위해 팀이랑 싸우지 않나요?”</span></span></span></blockquote><p id="2a4a360d-33e3-80d7-a55e-da524e4a8b12" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a4a360d-33e3-80fe-8e80-d202d7d7598a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">실제 토스는 그렇게 단순하지 않아요. 광고를 제공하는 것에 열려있고, 비즈니스와 사용자 경험, 둘 다 챙겨야 하죠. 그러기 위해 팀과 싸우는게 아니라 같이 치열하게 고민해요.</span></span></span></p><p id="2a4a360d-33e3-8036-807e-d16414ecf097" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">결국 중요한 건 비즈니스와 사용자 경험, 둘 사이의 교집합을 찾아내는 일이더라고요.</span></span></span></p><p id="2a4a360d-33e3-8093-8c2a-dee265ea919a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저는 토스에서 광고 사업을 본격적으로 추진하던 시기에 광고 도메인에서 제품을 만들었어요. 무슨 제품을 만들든 유저에게 ‘광고’를 보여줘야 했죠. 이전에는 토스에서 상상도 할 수 없었던 경험, 사용자가 싫어할만한 경험을 제가 전부 처음으로 다 만들게 된거죠.</span></span></span></p><p id="2a4a360d-33e3-80ea-80f4-ec8c8d50d708" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">제품을 만들 때마다 사용자의 불만은 쏟아졌고, 그 중 절반은 욕설이었어요. 그럼에도 그런 제품은 계속 만들어야했죠. 내가 뭘 만들든 욕만 먹는 상황에서 중요한 것을 배웠어요. 비즈니스와 사용자 경험의 교집합을 찾아내는 방법을 깨닫게 되었죠.</span></span></span></p><p id="2a4a360d-33e3-80e7-8e7a-d8f72db6c03e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a4a360d-33e3-80c4-9d7f-ea7d9e29ccbe" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><h2 id="2a4a360d-33e3-80dd-ab9d-d509de90e94f" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">1. 없앨 수 없다면, 덜 불쾌하게</span></span></span></h2><p id="2a4a360d-33e3-803b-b56c-edf1dbde151c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">먼저, 제가 바꿀 수 없는 조건을 정의했어요. 광고였죠. 저는 광고 도메인에서 광고 제품을 만드는 역할이기 때문에 ‘광고가 없는 경험’을 만들 순 없었어요. </span><span class="css-q3ktjb">그렇다면 광고가 있더라도 괜찮은 경험을 만들어야 했죠.</span></span></span></p><p id="2a4a360d-33e3-8029-a9fa-ca4bd7977399" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a4a360d-33e3-8056-bcf2-eee920bd76e6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">수 많은 피드백을 분석해 봤을 때 사용자가 </span><span class="css-q3ktjb">특히 싫어했던 지점</span><span class="css-1kxrhf3">은 크게 두 가지 였어요.</span></span></span></p><p id="2a4a360d-33e3-8008-a137-f02384f904ad" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2a4a360d-33e3-8071-a178-e51fe76c9920" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ </span><span class="css-q3ktjb">예상치 못하게 튀어나오는 광고</span></span></span></h3><p id="2a4a360d-33e3-801d-9916-cde3d3abe1d8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="2a4a360d-33e3-805c-9f2a-dde5cf4fdb84" class="css-of5acw"><video muted="" loop="" autoplay="" playsinline="" class="css-8atqhb"><source src="https://static.toss.im/ipd-tcs/toss_core/live/1388cb08-7bc9-4a30-b3f0-3da50d2d8457/inner-techblog-1.mp4"/></video></figure><p id="2a4a360d-33e3-802d-9dce-e4c9cb27e820" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">부끄럽지만 한때 ‘1원 받기‘를 누르면 바로 광고가 나왔던 적이 잠깐 있어요. 사용자는 이렇게 예상치 못하게 광고가 뜨는 경우에 상상 이상의 부정적 감정을 느껴요. 이 이후로는 다른 누를 것도 안누를 만큼요. 공급자는 사용자가 일단 보게 만드려고 단순하게 설계했겠지만, 사용자 입장에선 엄청난 불쾌함으로 다가오죠. </span></span></span></p><p id="2a4a360d-33e3-8001-9058-ddc2b6158442" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="2a4a360d-33e3-803f-b769-fd62daf221fb" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/7854e45e-2b3f-4cff-a0e0-d25a51cc5a17/inner-techblog-2.png" alt="" class="css-1pgssrp"/></figure><p id="2a4a360d-33e3-8004-bb1a-e5a68678de28" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">아주 사소한 지점을 개선했어요. 다음 화면에 광고가 나올 걸 미리 알 수 있도록</span><span class="css-q3ktjb"> ‘광고 보고’ 라는 문구 하나만 넣었죠</span><span class="css-1kxrhf3">. 사용자들이 클릭을 안하면 어쩌지? 하고 걱정을 하는 팀원도 있었지만, 오히려 부정 피드백이 눈에 띄게 줄었고, 매출은 변하지 않았어요.</span></span></span></p><p id="2a4a360d-33e3-8092-b397-d2d49dae0658" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">더 나아가서 “짧은 광고 보기”, “30초 광고 보기” 등 광고 길이를 미리 알려줬을 때 사용자들이 더 눌러봤어요.
어차피 광고를 볼 사람만 보기 때문에, 숨기지 않고 정확하게 알려주면 불안감이 줄어들고, 오히려 임팩트를 높일 수 있다는 것을 깨닫게 되었죠.</span></span></span></p><p id="2a4a360d-33e3-8059-968c-fd56734280ed" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2a4a360d-33e3-805e-a27d-de02fc54ff9a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣ </span><span class="css-q3ktjb">동선을 방해하는 광고</span></span></span></h3><figure id="2a4a360d-33e3-80b8-a198-e5e3015129ae" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/97f6c02e-c21e-4f5a-9abc-23d16d71d58a/inner-techblog-3.png" alt="" class="css-1pgssrp"/></figure><p id="2a4a360d-33e3-804c-b9ab-d0bd48ebc61a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">동선을 방해하는 광고는 더 치명적이었어요. 계좌 내역 중간에 광고 배너가 들어간 적이 있었는데요. 사용자가 자신의 거래내역으로 착각해서 고객센터에 전화를 했던 적도 있었어요. </span></span></span></p><p id="2a4a360d-33e3-8071-b328-c0475d21ccfa" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="2a4a360d-33e3-80df-94d3-e303bfd89821" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/5d7c05e0-c64d-4437-bdf5-5bd2e36b2c1a/inner-techblog-4.png" alt="" class="css-1pgssrp"/></figure><p id="2a4a360d-33e3-8066-9588-f7a81bfd3424" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a4a360d-33e3-8097-8d25-c42e0a9a85a9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이후로 광고는 정보 탐색을 방해하지 않는 곳에만 배치하기로 했어요. 마찬가지로 매출은 줄지 않았고, 유저의 불만은 줄어들었죠. 오히려 일부 지표는 좋아지기도 했어요. </span></span></span></p><p id="2a4a360d-33e3-8037-b191-f978a8fa0f1e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a4a360d-33e3-80ff-b877-d775aa92fd55" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">두 가지 사례를 통해 “유저의 신뢰를 지키는 방식으로 광고를 넣어야 가장 큰 임팩트를 낼 수 있다.” 는 확신이 생겼어요. </span></span></span></p><p id="2a4a360d-33e3-8087-9551-ee0b6da25512" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><h2 id="2a4a360d-33e3-8006-93f7-eeccd3c63c08" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">2. 광고를 좋아하게 만들기</span></span></span></h2><p id="2a4a360d-33e3-802e-b26e-db5ed23a2796" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">수 많은 부정 피드백에 가려져 놓치고 있던 사실이 있었어요. 사용자 중 일부는 광고를 긍정적으로 보고 있었다는 사실이었죠. </span></span></span></p><p id="2a4a360d-33e3-8025-be0e-fcf41798744f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="2a4a360d-33e3-80c3-b46b-d8ac6dd67113" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/bfa2ecb4-e73a-4154-89bc-535b5d7f8607/image.png" alt="" class="css-1pgssrp"/></figure><p id="2a4a360d-33e3-8013-a7f1-e9bf9d5a90cc" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 피드백을 보면서, 광고 자체가 문제는 아니고, 결국 광고의 방식이 문제라는 생각을 했어요. 그래서 불쾌하지 않은 걸 넘어 ‘좋은 광고 경험’을 만들기 위한 세 가지 방향을 정했죠.</span></span></span></p><hr class="css-1ifza5r"/><h3 id="2a4a360d-33e3-80f3-b127-f60ddd2dc76c" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">① 필요한 광고 - “좋은 광고는 혜택처럼 느껴져요”</span></span></span></h3><p id="2a4a360d-33e3-800a-85f4-e44c4718b472" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사용자가 ‘지금 필요한 순간’에 보는 광고라면 어떨까요? 자동차 보험이 곧 만료되는 사람, 새 카드를 찾는 사람, 생활비를 절약하고 싶은 사람. 이 각각의 상황에 맞는 광고를 보여주면 좋은 경험이 될 수 있겠다고 생각했어요. </span></span></span></p><p id="2a4a360d-33e3-8052-837d-d8798b1d43f9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">적재적소에 알맞은 광고를 보여주려면 다양한 광고가 있어야 하고, 그러러면 광고주가 많아야하죠. 하지만 그러기엔 광고주가 부족했어요.</span></span></span></p><p id="2a4a360d-33e3-802c-b191-d5f22a81ab7c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">당시 토스에선 임시로 만든 내부 어드민으로 직접 광고를 영업하고 집행했기 때문에 광고를 크게 늘리기가 어려웠거든요.</span></span></span></p><p id="2a4a360d-33e3-8086-8218-e33d79f6d96f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">때마침 저는 광고주가 직접 집행할 수 있는 B2B 광고 플랫폼을 만들게 되었고. 이때 모든 유저에게 알맞은 광고가 잘 배정되게하는 기능을 많이 만들었어요.</span></span></span></p><p id="2a4a360d-33e3-8043-9f68-dcdb2267fdb2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">덕분에 광고 수가 기하급수적으로 늘어나고 사용자들에게 필요한 광고들이 적절하게 노출됐죠. 광고의 클릭률도 점점 높아졌어요.</span></span></span></p><hr class="css-1ifza5r"/><p id="2a4a360d-33e3-80b5-b5aa-e357d7aed23c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="2a4a360d-33e3-8052-bd1b-faa6554005cb" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">② 재미있는 광고 - “재미있으면 눌러보기도 해요”</span></span></span></h3><figure id="2a4a360d-33e3-8037-8272-e7e76dbecf57" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/06c7281f-d69c-4ca9-b694-2059a2abf7bc/inner-techblog-6.png" alt="" class="css-1pgssrp"/></figure><p id="2a4a360d-33e3-805e-a019-e5f9a7cf57c9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“재미있는 광고는 눌러보기도 해요”라는 사용자의 피드백을 보고 이전에는 없었던, 훨씬 재미있고 신선하고 톡톡 튀는 광고를 만들어야 겠다고 생각했어요. 다만 더 우선순위가 높은 업무들로 당장 만들기는 어려운 상황이었죠.
당장 만들지 못하더라도, 내가 아니어도, 언젠가 누구든 기회가 될 때 재미있는 광고를 만들면 된다고 생각했어요.</span></span></span></p><p id="2a4a360d-33e3-8043-9e40-da8b7e58dbe4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 광고 도메인 디자이너들이 모두 모여 가장 재밌는 광고를 만들어보는 아이데이션 세션을 정기적으로 열었어요. 당장 실현하지 못하더라도, 지금 아이디어가 각자의 기억에 남아 기회가 될 때 발현될 것을 기대한거죠.</span></span></span></p><p id="2a4a360d-33e3-8007-add3-de4216e33c0f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="2a4a360d-33e3-8059-9124-c770f584d11f" class="css-of5acw"><video muted="" loop="" autoplay="" playsinline="" class="css-8atqhb"><source src="https://static.toss.im/ipd-tcs/toss_core/live/9967c2cd-e5ec-46a0-921d-4585e9cb58d9/inner-techblog-7.mp4"/></video></figure><p id="2a4a360d-33e3-8017-812d-d02500fc3780" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a4a360d-33e3-80b3-b3dd-dd712889e477" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">휴대폰을 움직이면 반응하는 광고, 퀴즈를 풀면 포인트를 주는 광고, 간단한 게임 형태의 광고 등 수많은 아이디어가 쏟아졌고, 일부는 실제 서비스로 이어졌죠.</span></span></span></p><p id="2a4a360d-33e3-80bd-8cfa-fb90dcc83418" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">제가 생각했던 대로, 아이데이션 했던 내용이 추후에 나비효과를 발휘하며 제품으로 만들어지게 된거죠.</span></span></span></p><p id="2a4a360d-33e3-80f3-bf97-f1461901c77d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><h3 id="2a4a360d-33e3-80d2-b714-e852e3a17bb5" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">③ 보상을 주는 광고- “보상이 있다면 기꺼이 볼 수 있어요”</span></span></span></h3><p id="2a4a360d-33e3-80a6-87ad-fcdb4cf312b8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">세 번째로 다뤘던 건 ‘보상을 주는 광고’였어요. 이 부분이 가장 어려웠어요. 사용자마다 가치 있게 느끼는 보상의 기준이 모두 달랐거든요. 누군가에겐 1원도 충분하고, 누군가는 작은 돈에는 전혀 반응하지 않아요.</span></span></span></p><p id="2a4a360d-33e3-8067-b9fe-f98962f9e880" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 대부분의 사용자가 ‘광고를 볼 만큼 가치 있다고 느끼는 보상’을 찾기 위해 정말 많은 실험을 했어요. 처음에는 단순히 금액을 바꿔보는 실험부터 시작했어요. 1원, 10원, 200원 같은 현금 보상부터 보석, 기프티콘,캐릭터 같은 비현금성 보상, 그리고 100만 원, 1000만 원 같은 일확천금형 보상까지요.</span></span></span></p><p id="2a4a360d-33e3-80bd-8955-d2cc245dad96" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그러다 보상의 금액만으로는 한계가 있다는 걸 느끼게 됐고, 다음에는 </span><span class="css-q3ktjb">보상을 받는 과정</span><span class="css-1kxrhf3">을 조정해봤어요. 10초 광고부터 30초 광고까지, 광고의 길이나 퀄리티를 바꾸며 ‘노동 강도’를 조금씩 다르게 설정해보기도 했죠.</span></span></span></p><p id="2a4a360d-33e3-8038-82b3-e0f15d33fda2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="2a4a360d-33e3-8065-91b0-c1d0a75be10c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 시행착오를 1년 넘게 반복한 끝에, 많은 사람들이 ‘가치 있다고 느끼는 보상’을 찾아냈고, 이를 활용해 성과를 만들 수 있었어요. </span><span class="css-q3ktjb">바로 만보기의 ‘복권’ 이죠. 만보기에 무조건 광고를 넣어야 하는 상황에서 광고를 보면 100만원 복권을 보상으로 받도록 했죠.</span></span></span></p><p id="2a4a360d-33e3-805e-8477-def06b876327" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 통해 한때 적자만 나던 서비스가 매출을 만들어내는 서비스로 완전히 바뀌었어요. 무엇보다 이 성과가 일시적이지 않고 꾸준히 지속되었다는게 중요했어요. 이탈한 유저는 없었고, 만족도 지표 또한 떨어지지 않았어요. 심지어 유저의 활동성이 오히려 높아지기까지 했죠.
</span><span class="css-q3ktjb">사실 이전과 비교했을 때 없던 광고를 봐야하기에 유저 경험이 좋아지진 않았을 거에요. 하지만 적정한 보상 없이 광고를 봐야하는 최악의 경험은 막아냈고, 비즈니스 목표도 달성했어요.</span></span></span></p><p id="2a4a360d-33e3-809b-afa7-d3f0e3a8f281" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 성과는 추후 구글에서도 주목받아서, 게임이 아닌 서비스 중 광고로 가장 큰 임팩트를 낸 전 세계 첫 사례로 상을 받았어요.</span></span></span></p><hr class="css-1ifza5r"/><h2 id="2a4a360d-33e3-8002-9c7e-f90a2a18ee98" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">비즈니스와 유저 경험의 교집합은 </span></span></span></h2><p id="2a4a360d-33e3-8019-985a-c2e943e5a269" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">큰 성과를 낸 것 보다 중요한 깨달음은 비즈니스와 사용자 경험, 모두 챙길 수 있는 교집합 지점을 찾아낸다면 상상이상의 임팩트를 낼 수 있다는 것이에요. 이 지점을 찾아내려고 고군분투하는 과정이 꽤 재미있기도 하고요.</span></span></span></p><p id="2a4a360d-33e3-80d4-ba3b-cedbe3652b08" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저는 실제로 토스에서 가장</span><span class="css-q3ktjb"> 안 좋은 경험</span><span class="css-1kxrhf3">을 만들던 사람이었어요. 하지만 그 과정에서 비즈니스와 사용자 경험의 교집합을 찾아</span><span class="css-q3ktjb"> 최선의 경험</span><span class="css-1kxrhf3">을 만들고 있고, 앞으로는 </span><span class="css-q3ktjb">최상의 경험</span><span class="css-1kxrhf3">을 만들기 위해 노력하고 있어요.</span></span></span></p><p id="29ba360d-33e3-8033-85d2-c09cee3e0974" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><p id="29ba360d-33e3-803b-8ae2-deec5e0d28e4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="29ba360d-33e3-8068-8696-c8d296b0cd9a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h2 id="29ba360d-33e3-807f-b716-c4fef3c30799" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">적용해보기</span></span></span></h2><aside id="29ba360d-33e3-8015-bd5e-efc413e616bb" class="css-nv7vyi"><div class="css-1vn47db"><h3 id="29ba360d-33e3-807f-b0fc-db67d56887f1" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">1️⃣ </span><span class="css-q3ktjb">바꿀 수 없는 조건을 먼저 정의해보세요.</span></span></span></h3><p id="29ba360d-33e3-809b-a35a-e8385289b3d7" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">제약을 억지로 없애려 하기보다, 그 안에서 무엇을 개선할 수 있을지부터 정리해보세요.</span></span></span></p><p id="29ba360d-33e3-8013-8c68-c949464080f3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29ba360d-33e3-8045-afe4-ef000be568bd" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">2️⃣ </span><span class="css-q3ktjb">부정 피드백에 가려진 긍정적인 경험을 찾아보세요. </span></span></span></h3><p id="29ba360d-33e3-8000-8da5-ccceff9d4f9a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">좋은 경험을 키우는 방향으로도 충분히 개선할 수 있어요.</span></span></span></p><p id="29ba360d-33e3-806a-9e4f-eabeba98cf01" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29ba360d-33e3-803e-b2f1-e96024749107" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">3️⃣ </span><span class="css-q3ktjb">비즈니스와 사용성 사이 교집합을 찾아보세요.</span></span></span></h3><p id="29ba360d-33e3-8088-90c5-cb3d3b4f20b3" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하나를 선택하기보다, 둘이 만나는 지점을 설계해보세요</span></span></span></p></div></aside><p id="29ba360d-33e3-808c-b55b-c09f0b173141" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="29ba360d-33e3-803d-b822-d5c342a92896" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="29ba360d-33e3-80d6-9d6a-e6877763b703" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">✅ 이번 아티클은 아래 Toss Makers Conference 25의 세션을 바탕으로 재구성되었습니다.</span></span></span></p><figure id="29ba360d-33e3-803b-a301-df28eec61615" class="css-of5acw"><div class="css-oni540"><iframe src="https://www.youtube.com/embed/IgFhNdOwjHA" frameBorder="0" allowfullscreen="" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" class="css-122y91a"></iframe></div></figure></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[토스플레이스 사일로 QA로 일한다는 것]]></title>
            <link>https://toss.tech/article/tossplace-qa-manager</link>
            <guid>https://toss.tech/article/tossplace-qa-manager</guid>
            <pubDate>Tue, 04 Nov 2025 06:57:00 GMT</pubDate>
            <description><![CDATA[우리가 풀어내는 문제들에 대하여]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><p id="295a360d-33e3-805f-96ec-c71eb701ec1b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">안녕하세요. 토스플레이스 QA Manager 채소연입니다.</span></span></span></p><p id="295a360d-33e3-80d5-a785-f8af9664ea6e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스플레이스의 QA Manager는 기능조직인 QA 팀으로 함께 일하고 있어요. 동시에 팀이나 </span><span class="css-goq46l">*</span><span class="css-1kxrhf3">사일로로 ‘겸직’의 형태로 배치 되어 제품의 초기 셋업 단계부터 배포까지, 프로젝트와 프로덕트 전반의 품질을 관리합니다.</span></span></span></p><p id="295a360d-33e3-805b-873f-e909f6503d01" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">현재 각 팀원은 겸직으로 1개 이상의 사일로에 소속되며, 기본이 되는 프로세스에 더해서 사일로별 특성과 목표에 맞게 프로세스를 유연하게 운영하고 있습니다. 관심 있고 기여할 수 있는 팀/사일로의 배치를 오픈해서 논의해 결정할 수 있기 때문에, 나의 제품이라는 인식과 동시에 더 큰 동기와 책임감을 가지고 참여할 수 있습니다.</span></span></span></p><p id="295a360d-33e3-80a9-9143-c44fb8b955ef" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">QA는 단순히 기획 리뷰 단계에서만 제품을 리뷰하는 것이 아니라, 제품과 프로젝트의 시작 단계부터 함께합니다.
</span><span class="css-1kxrhf3">이를 통해 요구사항과 히스토리를 명확히 이해하고, 리스크 확인·테스트 범위 산정·테스트 케이스 설계·테스트 실행까지 더 깊이 있게 지원할 수 있습니다. 또한 팀 빌딩 단계인 OKR 설계 과정부터 참여하기 때문에 QA도 함께 세운 목표의 달성에 기여하고 있어요.

</span><span class="css-goq46l">*</span><span class="css-1kxrhf3">사일로(Silo): 토스플레이스는 하나의 제품이나 서비스 단위를 책임지는 작은 팀을 사일로(Silo)라고 부릅니다. 각 사일로는 기획, 디자인, 개발, QA, 데이터 등 필요한 직군이 모여 독립적으로 하나의 목표를 가지고 빠르게 제품을 만들어가는 가장 작은 단위의 제품조직 입니다.</span></span></span></p><p id="295a360d-33e3-80e6-9385-e027959f1d44" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><hr class="css-1ifza5r"/><h2 id="295a360d-33e3-806b-9af6-cb45f09bd2ec" class="css-1c1qox8"><span class="css-1r3ko7u"><span class="css-p4abj2"><span class="css-1kxrhf3">제품팀 소속 QA가 만든 인식의 변화</span></span></span></h2><p id="295a360d-33e3-800d-ace4-c1221ad507fb" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">QA Manager로서 종종 이런 질문을 듣습니다.</span></span></span></p><p id="295a360d-33e3-8062-9e17-deddbca09e77" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1odxvuk">“QA가 다른 팀과 협업할 때, 가치를 주는 팀으로 보이려면 어떻게 해야 하나요?”</span></span></span></p><p id="295a360d-33e3-8012-a1dd-c51d3000326b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사실 QA가 제품 개발의 마지막 단계에만 깊이 개입한다면, 제품의 히스토리를 알지 못한 채 얕은 테스트만 진행하게 될 수 있습니다. 그렇게 되면 기능 상의 리스크를 뒤늦게 발견해 전체 일정이 늦어지거나, 심지어 스펙을 크게 바꿔야 하는 상황도 생길 수 있어요.</span></span></span></p><p id="295a360d-33e3-80d1-b26d-f3fd297140df" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 우리는 QA팀으로서 중앙에서 품질 문화를 이끌어가는 동시에, 각 사일로 안에 들어가 겸직으로 함께하기로 했습니다. QA가 끝단에서 문제를 발견하고 막는 팀이 아니라, 팀의 논의와 의사결정 과정에 직접 참여하면서 리스크를 줄이고 실행 속도를 높이는 동료가 되기 위함이죠. 이를 통해 제품의 제작 의도, 히스토리를 명확하게 알수 있게 되어 리스크 확인, 테스트 범위 산정, 테스트케이스 설계, 테스트 등에서도 많은 도움이 되고 있습니다.</span></span></span></p><p id="295a360d-33e3-8074-abfe-fdc3493369fa" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 겸직 구조를 통해 가장 크게 달라진 것은 </span><span class="css-q3ktjb">QA에 대한 인식</span><span class="css-1kxrhf3">이었어요. 예전에는 QA가 배포를 지연시키기만 한다는 인식이 강했지만, 실제로 함께 일하면서 팀원들은 QA가 있으면 더 빠르고 안정적으로 나아갈 수 있다는 경험을 쌓아가고 있습니다.</span></span></span></p><p id="295a360d-33e3-8088-80bc-c45825197bbe" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">즉 QA는 프로세스를 늦추는 팀이 아니라, </span><span class="css-q3ktjb">빠른 배포와 높은 품질을 동시에 가능하게 하는 존재</span><span class="css-1kxrhf3">로 자리잡으며 지금은 함께 일하고 싶은 팀으로 나아가고 있습니다. </span></span></span></p><p id="295a360d-33e3-8086-8f92-c5252845f0d2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="295a360d-33e3-8014-baa6-f8b14466ae35" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">겸직으로 제품팀 소속으로 업무를 진행하면서 좋은 점은, 다양한 시도를 작은 단위에서 먼저 실험해볼 수 있다는 것입니다. 사일로 안에서 시도해 보고 좋은 결과가 나오면 전체 팀 프로세스에 도입하고, 효과가 없으면 과감히 버릴 수 있어요.</span></span></span></p><p id="295a360d-33e3-80e7-9629-d3798ac05b31" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 글에서는 저희가 실제로 시도했던 것들 중 일부를 공유해 보려고 합니다.</span></span></span></p><p id="295a360d-33e3-80f7-a60f-eb051c7deff0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="295a360d-33e3-8047-a53e-c481d563ea6c" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">우리가 시도했던 변화들 </span></span></span></h3><blockquote id="295a360d-33e3-803f-bdcf-d7f61b6aa9c9" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">✅ </span><span class="css-q3ktjb">디자인 리뷰 강화</span></span></span><div class="css-1k9y0sc"><p id="295a360d-33e3-8008-8236-f9166978e05e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">스펙 리뷰를 진행함에도 불구하고 개발·QA 과정에서 자주 발생하는 문제 중 하나는 </span><span class="css-q3ktjb">스펙을 다르게 이해하거나 변경 사항 공유가 누락되는 것</span><span class="css-1kxrhf3">이었습니다.</span></span></span></p><p id="295a360d-33e3-80fc-876e-f7d000a09194" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 해결하기 위해 사일로 내에서 </span><span class="css-q3ktjb">스펙 리뷰 → QnA 세션 → 변경사항 정리</span><span class="css-1kxrhf3">라는 흐름을 제안했어요.</span></span></span></p><ul class="css-uswsmm"><li id="295a360d-33e3-807c-a449-e1c1630fbd47" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">리뷰 단계에서는 모든 팀원이 제품의 기본 흐름을 공유할 수 있도록 했습니다. </span></span></span></li><li id="295a360d-33e3-8045-9606-cb988c999f31" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">QnA 세션은 사전에 질문을 모아 진행하여, 반복 논의를 줄이고 효율성을 높였습니다.</span></span></span></li><li id="295a360d-33e3-8092-9626-dd289be6909a" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">변경 내용은 하나의 사내 메신저 스레드나 사내 디자인 툴인 데우스에 모아 관리하고, QA 산출물 내에서 정리하며 운영을 보완했습니다.</span></span></span></li></ul><p id="295a360d-33e3-8087-8ca7-e717044f3bed" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 과정을 통해 </span><span class="css-q3ktjb">스펙 이해의 간극을 줄이고, 변경 사항을 더 빠르고 투명하게 공유</span><span class="css-1kxrhf3">할 수 있었습니다.</span></span></span></p></div></blockquote><blockquote id="295a360d-33e3-806b-9e9b-f3ecbc058ef3" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">✅ </span><span class="css-q3ktjb">라이브 모니터링</span></span></span><div class="css-1k9y0sc"><p id="295a360d-33e3-8064-b43b-d852cd290377" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">릴리즈 이후에도 QA의 역할은 끝나지 않습니다.</span></span></span></p><p id="295a360d-33e3-80d9-a39b-efa380d4faf8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사일로에는 보통 QA가 1명만 배치되기 때문에, 혼자서 모든 환경을 커버하거나 여러 관점에서 교차 검증하기에는 한계가 있었습니다. 특히 개발과 직접적인 관련이 없는 직군의 경우, 자신이 만드는 서비스를 실제로 실행해본 경험이 없는 경우도 있었어요.</span></span></span></p><p id="295a360d-33e3-80a8-ada5-c57dfc039e40" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 한계를 극복하기 위해 팀원 모두가 제품의 상태를 함께 확인할 수 있도록, 릴리즈 후 반드시 확인해야 하는 주요 체크리스트를 만들어 공유했습니다. 이를 통해 최종 스펙을 다시 검증하고, 릴리즈 이후 발생할 수 있는 문제를 조기에 발견할 수 있었습니다.</span></span></span></p><p id="295a360d-33e3-80cb-b00d-ddca3443e6f4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">무엇보다 QA 뿐 아니라 모든 팀원이 직접 상태를 점검하면서, 품질은 QA만의 책임이 아니라 팀 전체의 책임이라는 문화를 자연스럽게 강화할 수 있었습니다.</span></span></span></p><figure id="295a360d-33e3-8012-b311-d053d6c61376" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/5374a28d-a179-46f5-ba40-815f47bee055/image_1.png" alt="" class="css-1pgssrp"/></figure></div></blockquote><blockquote id="295a360d-33e3-80f4-b133-c22596796554" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">✅ </span><span class="css-q3ktjb">Sanity 테스트 도입</span></span></span><div class="css-1k9y0sc"><p id="295a360d-33e3-8013-aef8-d50bba5f55d2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">개발을 시작하는 단계에서 QA 시작 기준이 명확하지 않으면, 불필요한 리소스가 소모되거나 QA와 개발자의 이해가 어긋날 수 있었습니다. 이를 해결하기 위해 사일로 시작 시점에 개발자와 QA가 모여 </span><span class="css-q3ktjb">기준을 정리하는 회의</span><span class="css-1kxrhf3">를 진행했어요.</span></span></span></p><p id="295a360d-33e3-80b5-8fff-d99bbc37a52b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그 과정에서 다룬 주요 포인트는 다음과 같았습니다.</span></span></span></p><ul class="css-uswsmm"><li id="295a360d-33e3-8086-a4ed-fb031fe9be6c" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">세부적인 스펙(예: 최소/최대 제한 등)을 개발자가 먼저 정리하고, 이후 PO가 다시 체크해 합의한다.</span></span></span></li><li id="295a360d-33e3-80c5-9575-e6095116d6cc" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">디자인에서 제안된 정상 시나리오(Happy Case)에 대한 검증을 기본으로 삼는다.</span></span></span></li><li id="295a360d-33e3-801b-b86e-de1e080cee62" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">디자인은 초안 단계에서 위클리 공유로 확인하고, 디자인 픽스가 되는 시점에는 별도의 리뷰 미팅을 잡아 개발 착수 전 모든 직군이 동일한 이해도를 갖고 시작한다.</span></span></span></li></ul><p id="295a360d-33e3-80b1-be32-c0d4cfc164fd" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 과정을 통해 개발과 QA가 </span><span class="css-q3ktjb">같은 출발선에서 프로젝트를 시작</span><span class="css-1kxrhf3">할 수 있었고, 불필요하게 소요되던 리소스를 줄이며 더 효율적으로 QA를 진행할 수 있었습니다.</span></span></span></p></div></blockquote><blockquote id="295a360d-33e3-80d0-ab46-fd4dd3cb8571" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">✅ </span><span class="css-q3ktjb">사일로 별 백로그 관리 </span></span></span><div class="css-1k9y0sc"><p id="295a360d-33e3-80fe-adc1-eb5f6baa11a0" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">작은 요청이나 발견된 이슈들이 공식적인 백로그에 등록되지 않고 흩어지는 경우가 많았습니다. 수정 요청이 누락되거나 반영되지 않는 일이 반복되면서, 누가 무엇을 확인해야 하는지 추적하기가 쉽지 않았어요.</span></span></span></p><p id="295a360d-33e3-805b-8407-c54be12cbb64" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이를 개선하기 위해 각 사일로 별로 백로그 관리 방식을 정리했습니다.</span></span></span></p><figure id="295a360d-33e3-80fa-b8a1-f650ae987ca3" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/8190f17d-18b1-46fe-93d4-ccbf3d4a3770/image_2.png" alt="" class="css-1pgssrp"/></figure><ul class="css-uswsmm"><li id="295a360d-33e3-8031-9708-f3b0324468c3" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사내 메신저에서 바로 Send to Notion 기능을 활용해, 요청이나 발견된 이슈를 곧바로 해당 사일로의 백로그 데이터베이스에 추가할 수 있도록하며 대화 속에서 나온 아이디어나 수정 요청도 놓치지 않고 바로 기록으로 남길 수 있었습니다.
(처음에 문서 작성툴로 관리했지만 이것도 사내 메신저 리스트로 이관되었습니다.) </span></span></span><div class="css-1vn47db"><figure id="295a360d-33e3-8078-99c5-deca79037860" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/a9359a91-7b54-4660-b6c2-d483c40a5fa1/image_(3).png" alt="" class="css-1pgssrp"/></figure></div></li></ul><p id="295a360d-33e3-8095-b62a-ea476ec9919f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">우선순위 관리도 병행했어요.</span></span></span></p><ul class="css-uswsmm"><li id="295a360d-33e3-801d-83fa-e8d4ead0a236" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사용자 경험에 큰 영향을 주지 않는 항목은 우선순위를 낮춰두고, 실제 배포나 CS와 관련된 기능은 반드시 챙길 수 있도록 별도로 관리했습니다.</span></span></span><div class="css-1vn47db"><figure id="295a360d-33e3-804b-a35b-cc367499821a" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/094b6f74-e4e9-4cff-b797-6a0925536042/image_4.png" alt="" class="css-1pgssrp"/></figure></div></li></ul><p id="295a360d-33e3-804c-abd7-f196d43ccbba" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이런 방식으로 각 사일로의 백로그를 정리했고 여유가 있을 때 차근차근 처리하거나, 관련 기능을 배포할 시점에 맞춰 함께 해결할 수 있었습니다. 결과적으로 사일로 안에서 발견된 작은 요청들이 흩어지지 않고 모여 관리되면서, QA뿐 아니라 팀 전체가 같은 맥락을 공유할 수 있게 되었습니다.</span></span></span></p></div></blockquote><blockquote id="295a360d-33e3-80f7-bf86-ec809783771c" class="css-2sk6rv"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">✅ </span><span class="css-q3ktjb">JIRA FADE OUT + 리스트 / 캔버스 도입 </span></span></span><div class="css-1k9y0sc"><p id="295a360d-33e3-806b-96ac-d4019e091f9a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">입사 직후 가장 먼저 들었던 의문은 “왜 JIRA가 있는데 사내 메신저로 소통할까?”였습니다.</span></span></span></p><p id="295a360d-33e3-8040-8dce-fae1cb3470b1" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">당시 이슈는 JIRA에 등록하지만, 실제 소통은 제각각이었어요. 어떤 개발자는 JIRA 댓글로, 또 다른 개발자는 사내 메신저 스레드로 대화하다 보니 채널이 분산되었고, 같은 맥락을 두 번 설명해야 하거나 중요한 대화가 흩어지는 일이 잦았습니다.</span></span></span></p><p id="295a360d-33e3-8064-82fe-f6d7e4729ee4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">또한, JIRA에 익숙하지 않거나 자주 확인하지 않는 분들도 있어 빠른 소통이 어렵다는 한계가 있었습니다. 결국 대부분의 논의가 캔버스에서 이뤄졌지만, 이 경우에도 해결된 이슈·수정 중인 이슈·논의 중인 이슈를 구분하기가 쉽지 않았어요.
</span></span></span></p><figure id="295a360d-33e3-80f1-b18d-d34cf2857eb9" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/5f82c39a-c031-401a-ab47-812c6c6b0277/image_5.png" alt="" class="css-1pgssrp"/></figure><p id="295a360d-33e3-80bb-a771-f0141dd54059" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 문제를 해결하기 위해 사내 메신저에서 새롭게 제공한 </span><span class="css-q3ktjb">사내 메신저 리스트</span><span class="css-1kxrhf3"> 기능을 검토했고, 장단점을 팀원들과 공유했습니다. 그중 일부 내용은 다음과 같았어요.</span></span></span></p><ul class="css-uswsmm"><li id="295a360d-33e3-8090-8682-c8a1146f6afe" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">스레드 방식이 그대로 적용된다.</span></span></span></li><li id="295a360d-33e3-8072-9baf-d04da80738f6" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">각 이슈를 하나의 스레드로 관리할 수 있다.</span></span></span></li><li id="295a360d-33e3-80c7-8253-c8c14e2913fd" class="css-1hwiibq"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">담당자 지정이나 템플릿 커스터마이징이 가능하다.</span></span></span></li></ul><p id="295a360d-33e3-80cb-9205-dbf0caf8acb4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">물론 JIRA에 비해 백로그 관리나 장기적 프로젝트 관리 측면에서는 단점이 있을 수 있습니다. 하지만 우리 팀은 이미 사내 메신저를 주요 소통 채널로 활용하고 있었기 때문에, 소통과 관리가 한 곳에 모인다는 점에서 리스트/캔버스가 더 적합한 대안이 될 수 있다고 판단했습니다.</span></span></span></p><p id="295a360d-33e3-806c-9be1-cfef35e9b686" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">사내 메신저 리스트/캔버스를 도입한 뒤, 우리가 기대했던 장점들이 실제로 팀 안에서 드러났어요. QA 이슈 관리에는 훨씬 적합했고, 특히 소통의 분산 문제를 줄이며 작은 단위의 이슈를 빠르게 처리할 수 있었습니다. 반면, 장기적이고 복잡한 프로젝트 단위의 이슈 관리에는 여전히 한계가 있고 스레드가 길어질 경우 중간 공유와 요약이 어렵다는 단점도 있었습니다. </span></span></span></p><p id="295a360d-33e3-806b-b23e-d5108312d110" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">BTS 툴보다 사내 메신저 LIST가 더 좋다!는 말을 하려는 것은 아닙니다. 저희도 언제든 상황이 변한다면 다른 툴로 이동할 가능성을 열어두고 있어요. 다만 이 도입을 통해 얻은 가장 큰 교훈은, </span><span class="css-q3ktjb">도구 그 자체보다 현재 팀의 상황에 맞는 도구를 선택하는 것이 중요하다</span><span class="css-1kxrhf3">는 점이었습니다.</span></span></span></p></div></blockquote><figure id="295a360d-33e3-80b8-a0aa-cbe1a0028cb2" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/cf82e13e-5b4f-4afc-9162-c6d1bfe70f43/image_6.png" alt="" class="css-1pgssrp"/><figcaption class="css-wgpbp3"><span class="css-jfs1hr">실제 사용하고 있는 QA 템플릿 </span></figcaption></figure><p id="295a360d-33e3-8090-b5f7-e5439c891b88" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="295a360d-33e3-80a5-9001-d84f1c43a63b" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/d42b1676-1975-4400-a818-a669f34efab9/image_8.png" alt="" class="css-1pgssrp"/><figcaption class="css-wgpbp3"><span class="css-jfs1hr">요청 워크플로우로 QA 요청이 들어오면 해당 내용을 기반으로 캔버스 / 리스트가 자동 생성됩니다.
캔버스에는 요청 내용 / 릴리즈 예상 일자 / QA 요청 일정에 대한 정보를 담고 있어요.
해당 QA 건에 참고가 필요한 정책 문서나 논의 스레드, 테스트 정보를 첨부하기도 합니다. </span></figcaption></figure><figure id="295a360d-33e3-8073-a71a-c3d3082de2ec" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/c2eaf12a-718c-4166-a123-b021a398d728/image_9.png" alt="" class="css-1pgssrp"/></figure><p id="295a360d-33e3-80a1-bba4-e7d76f6ea6da" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">요청받는 테스트만을 진행할 때보다 사일로 안에서 함께할 때, 의사결정과 앞으로의 계획을 훨씬 잘 이해할 수 있습니다. 또한 사일로 안에 포함된 QA는 단순히 테스트만 하는 역할이 아니라, </span><span class="css-q3ktjb">제품을 함께 만드는 동료</span><span class="css-1kxrhf3">라는 소속감을 가질 수 있어요.</span></span></span></p><p id="295a360d-33e3-80ad-8bfc-c9dff980c1f4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">QA는 각 사일로에서 무엇을, 어떻게 하면 좋을지를 스스로 정하며, 그 자율성이 긍정적인 효과로 이어지고 있습니다. 올해 새로 합류한 혜정님은 DA와 협업하며 “데이터 관점에서 제품을 바라보는 게 신기하다”고 했고, 더 나아가 “QA도 데이터화된 지표로 제품의 자신감을 줄 수 있지 않을까?”라는 의견을 주시기도 하셨어요.</span></span></span></p><p id="295a360d-33e3-80cc-89f9-fed4f1402d8f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">매주 진행하는 QA 팀 weekly에서는 각 사일로에서 진행되는 제품이 사일로 현상에 빠지지 않도록 전사와 제품의 소식을 공유하고, 각자 자신이 겸직 사일로의 디테일한 정보를 공유하며 다른 제품 정보까지 함께 나눕니다. 이를 통해 전사의 흐름을 긴밀하게 팔로업하고 있습니다.</span></span></span></p><figure id="2a1a360d-33e3-8001-8871-f83db37a472a" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/0e2a90cc-968b-484b-a095-566f053488af/image_plus_1.png" alt="" class="css-1pgssrp"/><figcaption class="css-wgpbp3"><span class="css-jfs1hr">1년 동안 겸직을 진행한 후 QA 팀과 협업한 경험에 대한 피드백 서베이에서 다른 직군 팀원분들이 남겨주신 의견들입니다.</span></figcaption></figure><figure id="2a1a360d-33e3-80f1-8453-ea55784f33cf" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/592f1780-643a-4e30-aaf6-30e060e6725a/image_plus_2.png" alt="" class="css-1pgssrp"/></figure><p id="2a1a360d-33e3-8084-8575-c611d4af483d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="295a360d-33e3-8043-83c3-eb0a279c154e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이 글은 정답을 제시하려는 것은 아닙니다.</span></span></span></p><p id="295a360d-33e3-80e9-b726-f3f0c4f19fae" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스플레이스에서 어떤 실험을 해왔는지, 그리고 각 사일로에서 QA 프로세스를 어떻게 설계하고 운영해 가고 있는지를 공유하는 경험담으로 봐주시면 좋을 것 같아요. </span></span></span></p><p id="295a360d-33e3-807c-bce4-e0f3d56f3525" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스플레이스의 QA 팀은 기본이 되는 최소한의 프로세스를 지키면서도 사일로별 상황에 맞게 프로세스를 유연하게 설계하고 회고를 통해 지속적으로 업데이트하고 있습니다. 이 유연성이야말로 겸직 구조에서 QA가 더 큰 가치를 발휘할 수 있게 해주는 힘이라고 생각합니다. </span></span></span></p><p id="295a360d-33e3-8082-8a8d-f47c84cdb03f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">중요한 것은 QA가 뒷단에서 버그만 잡는 역할이 아니라, 제품의 시작부터 함께 고민하며 팀과 나아가는 동료라는 점이며 토스플레이스의 QA 팀은 그렇게 조금씩, 그러나 꾸준히 팀과 함께 성장하고 있습니다.</span></span></span></p><p id="295a360d-33e3-808c-bfaa-cc260ed0069d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">제품의 첫 시작부터 함께하며, 가장 작은 단위의 제품팀과 가까운 위치에서 제품의 Quality Confidence를</span><span class="css-q3ktjb"> </span><span class="css-1kxrhf3">책임지는 저희 QA 팀의 성장을 앞으로도 계속 지켜 봐주세요. </span></span></span></p><p id="295a360d-33e3-803e-8b50-efb7177a21bf" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[토스 피플 : 데이터를 ‘이해하는’ 구조를 설계합니다]]></title>
            <link>https://toss.tech/article/tosspeople-jhko</link>
            <guid>https://toss.tech/article/tosspeople-jhko</guid>
            <pubDate>Fri, 31 Oct 2025 01:35:00 GMT</pubDate>
            <description><![CDATA[데이터의 의미를 구조화하고 연결하는 설계 여정을 걸어온, 토스의 1호 Data Architect 고정현님의 커리어 이야기를 들려드려요.]]></description>
            <content:encoded><![CDATA[<div class="css-1vn47db"><aside id="29ca360d-33e3-80ca-ae08-c1cc444b9579" class="css-nv7vyi"><h4 class="css-123co55"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">오늘은 토스의 1호 Data Architect 고정현님의 이야기를 들려드려요. 정현님은 토스에서 단순히 ‘규칙을 만드는 사람’이 아닙니다. 데이터를 사람과 AI가 정확히 ‘이해할 수 있는 구조’로 설계하는 아키텍트죠. 데이터 컨설팅 회사, 배달 플랫폼 회사, 그리고 지금의 토스까지, 정현님이 걸어온 길은 단순한 규칙 설정이 아닌, 데이터의 ‘의미’를 구조화하고 연결하는 설계 여정이었습니다.</span></span></span></h4></aside><p id="29ca360d-33e3-806f-a5bb-e0d8fa26348c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="29ca360d-33e3-8051-b7c7-f27b5521ea58" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/b514634d-b400-4fc9-913d-adc34b6d56c3/1031-img-inner-techblog1.png" alt="" class="css-1pgssrp"/></figure><h3 id="29ca360d-33e3-8085-a47a-d2ce7bfaf91a" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Q. 데이터 아키텍트라는 일을 처음 알게 된 건 언제였나요?</span></span></span></h3><p id="29ca360d-33e3-8018-a2ee-effeceb13e2d" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">대학생 때 우연히 한 데이터 컨설팅 회사의 세미나를 들은 적이 있어요. 그 자리에서 처음으로 ‘데이터 아키텍트’라는 단어를 접했죠. 당시 국내에서는 아직 생소했던 데이터 아키텍처 개념을 도입하고 데이터 관리 방법론을 정립해 가던 분들이었는데, 정말 멋있다고 느꼈어요.</span></span></span></p><p id="29ca360d-33e3-80df-a58c-f521b68542d9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">‘나도 저런 일을 해보고 싶다’라는 마음이 생겼고, 운 좋게도 그 회사에서 데이터 아키텍트로 커리어를 시작할 기회를 얻었습니다. 그곳에서 데이터베이스 성능, 모델링의 원리 등 데이터 설계의 본질을 깊이 있게 배울 수 있었고, 무엇보다 “데이터의 품질은 결국 설계에서 결정된다”는 사실을 몸으로 체감할 수 있었어요.</span></span></span></p><p id="29ca360d-33e3-807f-a282-eafe210f8ab6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="29ca360d-33e3-80dd-91e7-df752eb0a850" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/8be4ac4b-eb41-4c26-85c2-f2e5ef6d06d6/1031-img-inner-techblog2.png" alt="" class="css-1pgssrp"/></figure><h3 id="29ca360d-33e3-806f-ab19-ce98558c8e01" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Q. 안정적인 컨설팅 회사에서 플랫폼 회사로 옮긴 이유가 궁금해요.</span></span></span></h3><p id="29ca360d-33e3-8052-bd2a-e8cfd392e29a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">데이터 컨설팅 회사에서의 경험은 제게 정말 의미 있는 시작점이었고, 데이터 설계의 원리와 철학을 배울 수 있었던 소중한 기억이에요. 그런데 어느 시점부터 시장 전체가 운영계 시스템 중심에서 분석계 플랫폼 중심으로 빠르게 전환되기 시작했죠. 당시 저는 이 변화 속에서 ‘컨설턴트’가 아닌, 실제 데이터의 생성부터 활용까지를 책임지는 ‘운영자’ 입장에서의 경험이 필요하다고 느꼈어요.</span></span></span></p><p id="29ca360d-33e3-8094-ae68-cbb2372cbd2b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">데이터 아키텍트라는 역할을 좀 더 넓은 관점에서 실현하려면, 실제 프로덕션 환경에서 데이터를 어떻게 만들고, 어떻게 쓰이며, 어떤 품질 이슈들이 발생하는지 현장에서 겪고 구조를 개선해 보는 경험이 반드시 필요하다고 판단했어요. 그래서 컨설팅이라는 틀을 벗어나, 플랫폼 조직의 내부에서 데이터를 주도적으로 설계하고 운영해 보고자 이직을 결심했습니다.</span></span></span></p><p id="29ca360d-33e3-80c3-a07e-de1e759ad9d9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">IT서비스를 제공하는 플랫폼 회사로 옮기면서, 빠른 개발 사이클과 데이터 품질 관리 사이의 간극을 처음으로 실감했습니다. 제품은 빨라야 했고, 데이터는 그 뒤를 수습해야 했죠. </span><span class="css-q3ktjb">‘속도와 품질은 싸우는 게 아니라, 균형을 찾아야 한다.’</span><span class="css-1kxrhf3">라는 것을 그때 깨달았어요.</span></span></span></p><p id="29ca360d-33e3-8063-bf1c-e39ebd4d2b18" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29ca360d-33e3-80d9-8317-fcef05e18e00" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Q. 배달플랫폼 회사에서는 어떤 경험을 하셨나요?</span></span></span></h3><p id="29ca360d-33e3-80b6-a824-dddd8281fe9f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">데이터 소비자들이 일관된 방식으로 데이터를 활용할 수 있도록 표준과 정책을 정비하는 데이터 아키텍트였고 , 동시에 데이터 파이프라인을 설계하고 운영하는 Data Analytics Engineer 역할도 함께 했어요. 전사 KPI와 연결된 마트나 지표, 대시보드를 만들면서 실제 비즈니스와 데이터를 연결하는 경험은 정말 인상 깊었고, 데이터 플랫폼을 중심으로 통합된 구조를 설계하고 운영해 보는 것도 좋은 배움이었죠.</span></span></span></p><p id="29ca360d-33e3-80d3-abcd-c31c7f0cf4c6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그런데 어느 순간부터 제 일이 ‘뒤에서 퍼즐을 맞추는 느낌’처럼 다가오기 시작했어요. 서비스가 빠르게 바뀌다 보면, 데이터는 늘 그 다음에 맞춰야 했고, 어느샌가 제가 하고 있는 일이 문제를 해결하는 것보다는 수습하는 쪽에 가까워지는 거예요. 그래서 더더욱 데이터가 들어오는 흐름부터 구조적으로 정리돼야 한다는 걸 몸으로 느꼈죠. 결국 데이터 품질은 플랫폼에서 뒷단에서만 만들어지는 게 아니라, 처음부터 끝까지 연결된 구조 속에서 관리되어야 한다는 걸 깨달았습니다.</span></span></span></p><p id="29ca360d-33e3-8017-88b6-c9084cf613a9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="29ca360d-33e3-8080-9985-da3ee4ce3259" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/2cee2912-34af-42d5-959b-545477fd8abb/1031-img-inner-techblog3.png" alt="" class="css-1pgssrp"/></figure><h3 id="29ca360d-33e3-80de-8319-d61e5527da88" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Q. 토스로 이직하게 된 계기가 그 지점이었겠네요.</span></span></span></h3><p id="29ca360d-33e3-80e6-9056-efa5654fb993" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">맞아요. 높은 수준의 데이터 품질을 유지하기 위해서는, 조직 전체가 데이터를 하나의 ‘설계 대상’으로 보고 함께 정리해 나가려는 문화가 필요하다고 느꼈어요. 단순히 뒷단에서 정제하는 게 아니라, 데이터가 만들어지는 순간부터 책임져야 한다는 관점이 조직 전반에 깔려 있어야 아키텍트로서도 진짜 의미 있는 역할을 할 수 있으니까요. </span></span></span></p><p id="29ca360d-33e3-8099-9845-d345f2f00e6e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그러던 중 토스의 블로그와 채용공고에서 End-to-End 데이터 거버넌스를 지향한다는 문장을 보게 됐고, 그 부분이 특히 깊이 와 닿았어요.</span></span></span></p><p id="29ca360d-33e3-8066-b581-ce451cec8e6c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-q3ktjb">“아, 이 회사는 데이터의 시작과 끝을 함께 고민하려는 문화를 가지고 있구나.”</span><span class="css-1kxrhf3"> 이 점이 정말 매력적이었죠.</span></span></span></p><p id="29ca360d-33e3-8044-b353-f699ba373627" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">토스는 이미 데이터를 중심으로 의사결정하는 문화가 자리 잡은 곳이었고, 전통적인 대기업처럼 역할이 고정된 아키텍트가 아니라, 빠르게 변화하는 환경 속에서 ‘데이터를 어떻게 잘 설계하고 관리할 것인가’를 주도적으로 고민할 수 있는 조직이었어요. 여기라면 진짜 데이터 아키텍트로 일할 수 있겠다고 판단했습니다.</span></span></span></p><p id="29ca360d-33e3-809a-835c-e3372e5fe610" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><figure id="29ca360d-33e3-8066-857b-e1fc78d384cf" class="css-of5acw"><img src="https://static.toss.im/ipd-tcs/toss_core/live/07cd910a-f51e-4bee-a332-612f2ab139a3/1031-img-inner-techblog4.png" alt="" class="css-1pgssrp"/></figure><h3 id="29ca360d-33e3-809f-a940-f4e1c48047c4" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Q. 막상 들어와 보니 어땠나요?</span></span></span></h3><p id="29ca360d-33e3-80e3-9a2c-f869c435cbba" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">쉽지 않아요. 아니, 솔직히 말하면 정말 어렵죠.</span></span></span></p><p id="29ca360d-33e3-8060-b067-e5522488c65f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">이미 잘 작동하고 있는 데이터 환경에서 ‘이걸 90점에서 95점으로 더 끌어올려야 한다’고 설득하는 일, 그리고 그 변화가 조직 전체 리소스를 들일 만큼 의미 있는 개선이라는 걸 입증하는 일은 생각보다 훨씬 더 복잡하고 어려워요. 더 나은 구조를 제안한다는 건, 기존에 익숙하게 사용 중이던 테이블과 방식들을 바꾸자고 말하는 일이기도 하니까요. 그에 따르는 변경 비용도 결코 작지 않죠.</span></span></span></p><p id="29ca360d-33e3-802e-a1b2-cdf82eff774a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">하지만 다행히도, 토스에는 </span><span class="css-q3ktjb">‘더 나아가야 한다’는 방향성에 공감해 주는 동료들</span><span class="css-1kxrhf3">이 정말 많아요. 그리고 무엇보다, AI 시대에 우리가 다루는 데이터가 ‘사람만이 아니라 기계도 이해할 수 있는 구조여야 한다’는 데에도 깊이 공감해 주죠.</span></span></span></p><p id="29ca360d-33e3-8096-bfc9-cb91f80063f4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">지금 저는 그런 동료들과 함께, 우리 데이터에 담긴 ‘진짜 의미’를 찾아내고 연결하는 일을 하고 있어요. 표준화, 의미기반 표준사전, 온톨로지 등으로 설명할 수 있는 작업들이고, 그걸 통해 사람과 AI가 더 정확하게 이해할 수 있는 데이터 구조를 만들어가고 있습니다. 결국 이 모든 과정이 데이터 품질을 올리고, 토스가 더 빠르고 똑똑하게 일할 수 있는 기반을 만드는 일이라고 생각해요.</span></span></span></p><p id="29ca360d-33e3-8097-a2f2-c0fe170aa197" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29ca360d-33e3-806f-886f-cd722f9911ca" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Q. AI가 이해할 수 있는 데이터를 만든다니, 흥미롭네요.</span></span></span></h3><p id="29ca360d-33e3-80ac-99f9-db62436bb663" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">네, 요즘은 데이터를 사람만 이해하는 구조로 만들면 부족한 시대인 것 같아요. 이제는 AI가 질문하고, 요약하고, 분석하는 시대잖아요. 그럴수록 데이터 간의 의미 관계가 명확히 설계돼 있어야 AI도 맥락을 놓치지 않고 제대로 이해하고 응답할 수 있어요.</span></span></span></p><p id="29ca360d-33e3-8059-a457-e9c91c83a7da" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예전에는 사람이 테이블이나 컬럼의 설명 같은 메타데이터를 보면서 의미를 어느 정도 유추하고 이해할 수 있었죠. 지금도 그런 메타데이터를 잘 설계해서 제공하는 건 여전히 중요하고, 저희도 그렇게 하고 있어요. 하지만 AI는 물론이고, 사람도 추론에만 의존하면 해석의 오류나 오해가 생기기 쉬워요. 그래서 지금 저희가 하고 있는 일은, 그런 추측의 여지를 줄이고 데이터 간의 의미적 연결을 훨씬 더 명확하게 설계하는 것이에요.</span></span></span></p><p id="29ca360d-33e3-80b2-98e0-c1309e410fd4" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">“이 컬럼이 어떤 개념이고, 어떤 관계 안에 놓여 있는지”를 기계가 스스로 추론하지 않아도 바로 이해할 수 있도록 연결해 주는 작업이라고 보시면 됩니다. 이것이 AI가 정확하게 이해하고 응답할 수 있는 기반이 되는 거고요. 결국 이런 구조가 사람과 AI 모두에게 신뢰할 수 있는 데이터 환경을 만들어주는 기반이 된다고 생각해요.</span></span></span></p><p id="29ca360d-33e3-801d-babe-c26bb91c908b" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">물론, 이런 구조를 만들기 위해서는 단순히 ‘좋은 설계’를 넘어서, 조직이 빠르게 움직이는 속도 안에서 현실적으로 실현 가능한 방식으로 접근해야 해요. 그래서 토스에서는 품질과 업무 속도 사이의 균형을 항상 고민하게 됩니다.</span></span></span></p><p id="29ca360d-33e3-8046-86ae-fc6d5e7c3de2" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29ca360d-33e3-805c-86dd-d847b307d898" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Q. ‘품질’과 ‘속도’를 함께 지키는 게 쉽지 않을 것 같아요.</span></span></span></h3><p id="29ca360d-33e3-8054-95a9-dba7189bcd88" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">맞아요, 정말 쉽지 않죠. 토스처럼 빠르게 움직이는 조직에서는 속도 자체가 경쟁력이기 때문에, 데이터 아키텍트가 단순히 “이게 맞는 구조니까 바꿔야 해요”라고 말하는 건 크게 와닿지 않을 수 있어요. 설득력이 떨어지죠.</span></span></span></p><p id="29ca360d-33e3-80a5-9775-dc18d68d2d73" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 저는 항상 </span><span class="css-q3ktjb">‘속도를 해치지 않으면서도 품질을 높일 수 있는 방법’</span><span class="css-1kxrhf3">을 고민해요.</span></span></span></p><p id="29ca360d-33e3-8010-a99b-f22b49a3d1b6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">예를 들어, 처음부터 완벽한 설계를 하겠다는 접근보다는, 지금의 수준과 맥락에 맞는 구조를 만들고, 가까운 미래에 생길 수 있는 변화까지만 적절히 고려한 뒤, 나중에 상황이 바뀌었을 때 최소한의 기준선을 기반으로 유연하게 대응할 수 있도록 여지를 남겨두는 방식으로 접근하죠. “지금은 어디까지 만들고, 무엇을 열어둬야 나중에 무리 없이 정리할 수 있을까?“를 계속 고민하는 거예요.</span></span></span></p><p id="29ca360d-33e3-809d-b9ae-efb15fc2ad0e" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">또, 자율성을 유지하면서도 자연스럽게 표준을 따르게 만드는 구조를 설계하려고 해요. 규칙을 강제하기보다는, “이렇게 만드는 게 오히려 편하다”는 경험을 설계하는 일에 더 가깝죠. 결국 속도와 품질은 충돌하는 가치가 아니라, 서로를 이해하고 조율해야 공존할 수 있는 가치라는 걸 매일 느끼고 있어요. 그리고 그 중간 지점을 찾아가는 과정이 지금 이 역할에서 가장 도전적이고, 또 가장 흥미로운 부분이라고 생각해요.</span></span></span></p><p id="29ca360d-33e3-8037-a288-caac4abe5fb6" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29ca360d-33e3-80c1-9374-e0001a79d79c" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Q. 앞으로 어떤 일을 더 해보고 싶으세요?</span></span></span></h3><p id="29ca360d-33e3-804c-852a-fdeea357e15a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">가장 먼저는 진짜 의미에서의 </span><span class="css-q3ktjb">End-to-End 데이터 거버넌스 체계</span><span class="css-1kxrhf3">를 제대로 구축해보고 싶어요.</span></span></span></p><p id="29ca360d-33e3-801c-80ec-e3fa99ef92a8" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">데이터 구조, 표준, 품질 관점에서 처음 생성되는 순간부터 최종 활용까지 전 과정이 자연스럽게 연결되고 관리되는 구조를 만드는 거죠. 이건 말로는 쉽지만, 실제 조직 내에서 잘 작동하는 경우는 정말 드물어요. 특히 토스처럼 빠르게 변화하는 환경에서는 단순히 기존의 방법론을 가져와선 한계가 있고, 속도와 유연성을 해치지 않으면서도 정합성과 품질을 지킬 수 있는 ‘토스다운 방식’을 새로 만들어야 한다고 생각해요.</span></span></span></p><p id="29ca360d-33e3-8002-b326-c575826092e5" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 지금 하고 있는 작업들을 더 발전시켜서, 토스만의 설계 철학과 운영 방식이 담긴 데이터 거버넌스 모델을 완성해 보고 싶어요. 궁극적으로는 그게 업계에서도 하나의 좋은 레퍼런스로 남을 수 있으면 좋겠고요.</span></span></span></p><p id="29ca360d-33e3-80cb-9e88-c5cf328c037f" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><h3 id="29ca360d-33e3-8014-9d53-eddb944522db" class="css-1feg9au"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Q. 마지막으로, 데이터 아키텍트를 꿈꾸는 사람들에게 해주고 싶은 말이 있다면요?</span></span></span></h3><p id="29ca360d-33e3-80d0-855f-d463e2c6a44c" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">저는 사실 데이터 엔지니어든, 분석가든, 어떤 데이터 직군에 있는 사람이 데이터가 잘 작동하길 바라는 마음만 있다면 누구나 아키텍트의 시작점에 있다고 생각해요. ‘데이터 아키텍트’라는 이름이 주는 무게감이나, 모든 걸 설계할 줄 알아야 한다는 부담 때문에 괜히 유니콘처럼 느껴지는 경우가 많은데, 사실은 작은 구조 하나를 더 낫게 만들고 싶은 마음에서 시작하는 역할이에요.</span></span></span></p><p id="29ca360d-33e3-80e6-8173-e091aab3c7c9" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">그래서 “내가 그런 생각을 하고 있었다면, 이미 그 길 위에 있는 거다”라는 말을 꼭 해주고 싶어요. 그리고 적어도 토스에서는 그 생각을 진짜로 실현해볼 수 있는 환경이 있어요. 규칙을 주입하는 게 아니라, 실제 문제를 구조로 풀어가는 문화가 있고, 그 구조를 함께 설계해 갈 동료들이 옆에 있다는 점도요.</span></span></span></p><p id="29da360d-33e3-80a7-b998-f93e429cf09a" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"></span></span></p><p id="29da360d-33e3-8016-83db-ff027075dc71" class="css-14on8x8"><span class="css-1r3ko7u"><span class="css-1iisb9p"><span class="css-1kxrhf3">Words 고정현
Edit 고정원</span></span></span></p></div><div id="tds-mobile-portal-container"></div>]]></content:encoded>
        </item>
    </channel>
</rss>
