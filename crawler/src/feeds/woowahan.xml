
<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>우아한형제들 기술블로그</title>
	<atom:link href="https://techblog.woowahan.com/feed/" rel="self" type="application/rss+xml" />
	<link>https://techblog.woowahan.com</link>
	<description></description>
	<lastBuildDate>Fri, 26 Dec 2025 05:00:43 +0000</lastBuildDate>
	<language>ko-KR</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>


<image>
	<url>https://techblog.woowahan.com/wp-content/uploads/2020/08/favicon.ico</url>
	<title>우아한형제들 기술블로그</title>
	<link>https://techblog.woowahan.com</link>
	<width>32</width>
	<height>32</height>
</image>
	<item>
		<title>끊김 없는 사용 경험을 위하여 : 카카오톡 선물함 속 교환권을 배달의민족 주문으로 연결한 여정</title>
		<link>https://techblog.woowahan.com/25049/</link>
					<comments>https://techblog.woowahan.com/25049/#respond</comments>

		<dc:creator><![CDATA[김희선]]></dc:creator>
		<pubDate>Fri, 26 Dec 2025 06:00:42 +0000</pubDate>
				<category><![CDATA[Frontend]]></category>
		<category><![CDATA[PM]]></category>
		<guid isPermaLink="false">https://techblog.woowa.in/?p=25049</guid>

					<description><![CDATA[<p>배민선물하기팀은 선물하는 이의 마음과 받는 이의 즐거움을 잇는 &#8216;배민선물하기&#8217; 서비스를 담당하며, 배달의민족(이하 배민) 앱 내 상품권 발행부터 외부 채널과의 유통망 연동을 관리하고 있습니다. 이번에 소개할 프로젝트는 카카오톡에서 선물 받은 브랜드 교환권을 배민 앱에 직접 등록해 결제에 사용할 수 있도록 구현한 ‘외부 교환권 연동 서비스’입니다. 카카오톡에서 선물받은 요거트아이스크림의정석 교환권을 배민 앱에 등록하여 주문하는 고객 플로우 그동안 [&#8230;]</p>
The post <a href="https://techblog.woowahan.com/25049/">끊김 없는 사용 경험을 위하여 : 카카오톡 선물함 속 교환권을 배달의민족 주문으로 연결한 여정</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></description>
										<content:encoded><![CDATA[<div>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">배민선물하기팀은 선물하는 이의 마음과 받는 이의 즐거움을 잇는 &#8216;배민선물하기&#8217; 서비스를 담당하며, 배달의민족(이하 배민) 앱 내 상품권 발행부터 외부 채널과의 유통망 연동을 관리하고 있습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이번에 소개할 프로젝트는 카카오톡에서 선물 받은 브랜드 교환권을 배민 앱에 직접 등록해 결제에 사용할 수 있도록 구현한 ‘외부 교환권 연동 서비스’입니다. </p>
<figure style="text-align: center;margin: 30px 0">
<figure class="wp-block-video"><video width="650" height="420" autoplay controls loop muted src="https://techblog.woowa.in/wp-content/uploads/2025/12/KakaoTalk_Voucher_Baemin.mp4" playsinline></video></figure><figcaption style="font-size: 13px;color: #999;margin-top: 8px">카카오톡에서 선물받은 요거트아이스크림의정석 교환권을 배민 앱에 등록하여 주문하는 고객 플로우</figcaption></figure>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">그동안 많은 고객분들이 “카카오톡으로 받은 선물인데, 왜 배민에서는 못 쓰지?”라는 의문을 가져왔습니다. 고객 입장에서 이 당연해 보이는 연결고리를 완성하기 위해 배민선물하기팀에서 마주했던 플랫폼 간의 기술적 간극과 복잡한 이해관계, 그리고 그 단절된 경험을 매끄럽게 잇기 위해 분투했던 과정들을 솔직하게 기록해 보려 합니다. 저희의 시행착오와 해결 과정이 어쩌면 비슷한 고민을 하고 계실 다른 동료분들께 조금이나마 실질적인 도움이 되기를 바랍니다.</p>
<h2 style="margin-top: 80px;margin-bottom: 40px;font-size: 24px;font-weight: bold">“왜 안돼?”질문에서 시작된 프로젝트</h2>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">모든 프로젝트는 질문에서 시작됩니다. 하지만 그 질문이 언제나 고객의 입에서 나오는 것은 아닙니다. 카카오톡 교환권을 배민에서 사용하게 만드는 프로젝트는 고객의 불편함이라는 표면적인 문제와 비즈니스의 성장을 위한 내부적인 전략적 필요성이 교차하는 지점에서 시작하였습니다.
</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">사용자 불편함: 해결해야 할 문제</h3>
<figure style="text-align: center;margin: 30px 0"><img fetchpriority="high" decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7-2025-12-14-%EC%98%A4%ED%9B%84-5.26.35-750x153.png" alt="" width="750" height="407" class="size-medium wp-image-24831" style="max-width: 100%;height: auto"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: Naver 지식iN</figcaption></figure>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">물론 오래전부터 사용자 VOC(Voice of Customer, 고객의 소리)가 있었습니다. &#8220;카톡 선물로 케이크 받았는데, 배민 앱에서는 왜 사용할 수가 없나요?&#8221;, &#8220;선물 받은 브랜드 교환권을 배민에서 주문할 때 쓰고 싶어요.&#8221; 이러한 고객의 소리는 단순히 기능 추가 요청을 넘어, 단절된 사용자 경험에 대한 아쉬움이 있었습니다. 사용자 입장에서 배민 앱은 이미 익숙한 주문 채널인데, 선물을 쓰기 위해 굳이 브랜드의 자사 앱을 설치하여 주문해야 하거나 직접 매장을 방문해야만 사용할 수 있는 번거로움은 명백한 페인포인트(Pain Point)였습니다. 이러한 불편함을 해소함으로써 고객에게 ‘역시 배민이 편하다’는 인식을 심어주고 싶었습니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">비즈니스 목표: 외부 주문을 배민 플랫폼 안으로 흡수</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">고객의 불편함만 해결한다면 바로 서비스할 수 있을까요? PM으로서 주목해야하는 것은 사용자 불편함 이면의 비즈니스적 가치였습니다. 단순히 고객의 불편함을 해결하는 것을 넘어, 이 프로젝트가 가질 &#8216;비즈니스적 파급력&#8217;에 주목했습니다. 그동안 플랫폼 경계에 머물러 있던 외부 교환권 수요를 배민 앱 안으로 온전히 수용함으로써 새로운 구매 전환의 접점을 확보하고 배민앱의 플랫폼 경험을 한 단계 확장할 수 있는 기회라고 판단했기 때문입니다.카카오톡 교환권 연동은 단순한 기능 추가를 넘어, 잠재된 주문 수요를 배민의 활성 에너지로 전환하는 강력한 성장 동력이 될 것이라는 확신을 얻게 되었습니다.</p>
<ul style="margin-bottom: 24px;line-height: 1.75">
<li><b>신규 고객 유입 및 락인(Lock-in)</b> : 타 플랫폼/브랜드 발행 교환권으로 유입되는 신규 고객이 배민 앱에 자연스럽게 안착하도록 유도</li>
<li><b>주문 경험 통합</b> : 고객이 어떤 교환권을 가지고 있든 배민 앱 하나로 모든 주문을 해결할 수 있는 편리한 경험 제공</li>
</ul>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">결국 이 프로젝트는 ‘고객 경험 개선’ 이라는 강력한 명분과 함께 동시에 외부의 잠재적 트래픽을 배민 플랫폼 안으로 흡수하는 비즈니스 목표가 더해져 시작할 수 있었습니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">스스로 정의한 프로젝트의 본질: 플랫폼 간의 장벽을 넘어선 새로운 연결</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">명확한 문제 정의와 비즈니스 목표가 있다면 프로젝트는 시작될 수 있습니다. 하지만 프로젝트의 규모가 크고 참여하는 조직이 많을수록, 즉 &#8216;사공이 많은 배&#8217;일수록 우리가 하는 &#8216;일의 본질&#8217;을 단단하게 정의하는 과정이 선행되어야 합니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이번 프로젝트는 여러 유관 부서가 참여하다 보니 각자의 우선순위에 따라 현안을 바라보는 시각이 나누어지기도 했습니다. 기술적 제약, 운영의 편의성, 비즈니스 수익성 등 수많은 목소리가 충돌할 때 우리를 다시 하나로 모아준 것은 &#8216;플랫폼 간의 장벽을 넘어 사용자에게 끊김 없는 연결을 제공한다&#8217;는 프로젝트의 본질이었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">스스로 정의하고 팀원들과 합의한 이 본질은 단순히 구호에 그치지 않았습니다. 치열한 논의 끝에 어려운 의사결정을 내려야 하는 순간마다, 우리는 &#8220;이 결정이 우리의 본질인 &#8216;연결&#8217;에 부합하는가?&#8221;를 자문하며 흔들리지 않고 나아갈 수 있었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">우리는 이 프로젝트의 의미가 단순히 매출 증대나 트래픽 확보에 그친다고 생각하지 않았습니다. 고립되어 있던 각자의 생태계(플랫폼)을 연결하여, 사용자에게 ‘경험의 단절이 없는 새로운 가치’를 제공하는 선례를 만드는 것에 진정한 의미가 있었습니다. 여러 회사의 연동 개발 과정은 명백한 기술적 도전이었지만, 본질적으로는 ‘플랫폼 중심 사고’에서 벗어나 사용자 편의성을 극대화하는 ‘사용자 중심 사고’로 전환하는 시도를 통해 비로소 가능했던 일이었다고 생각합니다.</p>
<h2 style="margin-top: 80px;margin-bottom: 40px;font-size: 24px;font-weight: bold">복잡한 다자간 협업에서 살아남는 ‘소통의 기술’</h2>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이 프로젝트의 본질은 플랫폼 간의 경계를 허무는 &#8216;연결&#8217;에 있었고, 카카오톡 교환권을 배민에서 사용하도록 구현하는 일은 기술적 완성도만큼이나 복잡한 대외 협업이 핵심이었습니다. 카카오라는 플랫폼사, 그리고 카카오톡 선물하기에 입점한 수많은 F&amp;B(Food &amp; Beverage) 브랜드사, 그리고 이들 사이를 잇는 연동사(쿠폰사)까지 얽혀 있는 거대한 생태계를 조율해야 했기 때문입니다. 협업의 대상은 외부 파트너사뿐만이 아니었습니다. 기존 주문 로직 전반에 영향을 주는 과제였던 만큼, 배민 내부의 여러 핵심 팀과도 시스템 리스크와 업무 부담을 조율하는 긴밀한 과정이 필요했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">서로 다른 시스템 언어와 이해관계를 가진 파트너들 사이에서 합의점을 찾아가는 과정은 마치 여러 국가가 참여하는 정상회담을 조율하는 일과 같았습니다. 이 프로젝트를 통해 다시 한번 깨달은 것은 기술적인 구현 능력 만큼이나 다양한 조직을 하나의 목표로 움직이게 하는 커뮤니케이션의 힘이었습니다. 다양한 이해관계자(카카오, 쿠폰사, 배민 내부 팀 등)와 협업하며 체득한 실질적인 교훈들을 다음과 같이 정리하였습니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">명확한 &#8216;왜?&#8217;를 상기하기</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">각 조직은 저마다의 KPI와 우선순위가 있습니다. 카카오는 플랫폼 안정성을, 쿠폰사는 정산의 명확성을, 배민 내부에서는 고객에게 약속한 시점에 안정적인 서비스를 제공하여 끊김 없는 경험을 완성하는 것을 가장 중요한 목표로 삼았습니다. 이처럼 이해관계가 충돌할 때, &#8220;고객 경험 개선과 새로운 가치 창출&#8221;이라는 프로젝트의 대의명분을 지속적으로 상기시키는 작업이 필요했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">또한, 계속해서 추가되는 비즈니스 요구사항들을 마주했을 때, 고객 경험 개선에 도움이 되더라도 핵심 기능이 아닌 부수적인 개선은 아닌지 끊임없이 점검했습니다. 중요도가 낮은 요구사항들에 대해서는 시의적절한 의사결정(우선순위 조정 또는 제외)이 중요했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">특히 일정이 충분하지 않은 상황에서 의사결정이 길어지거나 방향성을 잃을 때는 기술 스펙 대신 “이 결정이 사용자에게 어떤 가치를 주는가?&#8221;라는 본질적인 질문으로 돌아가서 판단하였습니다. 프로젝트 시작단계에서 스스로 정의한 프로젝트의 본질이 중요해지는 때인 것 같습니다. 명확한 비전은 복잡한 논의를 단순화하고 모두를 한 방향으로 이끄는 힘이 있다는 것을 상기할 수 있었습니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">상대방의 언어로 소통하기</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">너무도 당연한 이야기겠지만, 서로 다른 배경을 가진 팀과의 소통에서는 방식이 중요했습니다. 배민 내부의 백엔드 개발자에게는 API 응답 속도와 에러 핸들링을 중심으로 이야기해야 했고, 브랜드사와 연동사의 비즈니스 담당자에게는 제휴 조건과 정산 프로세스를 중심으로 소통해야 했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이 과정에서 상호 존중의 태도 역시 필수적이었습니다. 단순히 &#8220;우리 시스템이 맞다&#8221;는 식의 접근보다는, &#8220;상대방의 시스템은 왜 그렇게 설계되었을까?&#8221;를 이해하려는 태도가 중요했습니다. 배민에서는 카카오톡 교환권이 ‘등록’되고 ‘사용’되지만, 연동사의 입장에서는 ‘조회’되고 ‘승인’되는 기본적인 용어부터 비즈니스 로직까지 모든 것이 달랐습니다. 서로의 시스템이 다르다는 인지에서 대화를 시작하여 상이한 용어와 구현 및 처리 방식에 대해서도 꼼꼼히 확인하고 맞춰가는 과정은 복잡하고 이해할 수 없었던 각각의 시스템이 하나로 연결되는 열쇠가 되었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">배민에서는 최대한 다양한 연동사 연결을 받아들일 수 있되 새로운 교환권 사용 경험을 표준화하기 위한 노력을 하였으며, 이를 위해 단순히 공통 스펙을 요구사항으로 전달하기 보다는 상대의 도메인 지식 수준과 관심사를 파악하고, 이해하기 쉬운 언어와 관점에서 이야기하는 &#8216;맞춤형 커뮤니케이션&#8217;이 필요하였습니다. 이 과정에서 PM은 기술팀과 비즈니스팀 사이의 &#8216;전문 통역사&#8217; 역할을 자처해야 함을 알게되었습니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">‘가교’를 넘어 ‘선장’으로 주도적인 문제 해결자 되기</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">서로 다른 시스템과 정책을 가진 두 회사가 하나의 목표를 향해 나아가는 과정은 결코 순탄치 않았습니다. 기술적인 요구사항(API 스펙 정의, 에러 대응 정책 등)을 주고받는 과정에서 발생할 수 있는 오해와 지연을 최소화하기 위해 다음과 같은 전략을 사용했습니다.</p>
<ul style="margin-bottom: 24px;line-height: 1.75">
<li><b>기술적 요구사항 조율</b> : 양사의 기술팀이 합리적인 선에서 타협점을 찾을 수 있도록 기술적 배경지식을 바탕으로 조율했습니다.
  </li>
<li><b>일정 관리 </b>: 복잡한 의존 관계를 가진 작업들의 우선순위를 설정하고 전체 일정을 관리하며 프로젝트의 지연을 막았습니다.</li>
<li><b>니즈 충족을 위한 주도적인 역할</b> : 각 사의 비즈니스 니즈(예: 정산 방식, 장애 처리 정책)를 모두 충족시키기 위해 주도적으로 대안을 제시하고 합의를 이끌어냈습니다.</li>
</ul>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">문서화의 마법: 오해를 줄이는 투명한 기록 남기기</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">말로 한 합의는 시간이 지나면 해석이 달라지기 마련입니다. 특히 여러 회사가 얽힌 프로젝트에서는 &#8220;그때 그렇게 말씀하시지 않았나요?&#8221;라는 난감한 상황이 발생하기도 합니다. 난감한 상황을 예상해서는 아니었지만 다양한 이슈에 대해 모두 기억할 자신이 없었던 저는 API 명세서부터 정책 결정 회의록까지, 모든 합의 사항을 문서로 남겼습니다. 이러한 문서는 단순히 리스크 관리를 넘어, 정보의 비대칭성을 해소하고 모두가 같은 지도를 보고 움직이게 하는 내비게이션 역할을 톡톡히 해냈습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">또한, 수개월에 걸친 긴 호흡의 프로젝트에서는 문서를 통해 과거의 히스토리를 명확히 파악할 수 있었습니다. 프로젝트 중간에 발생하는 스펙 변경이나 새로운 요구사항은 별도 이슈트래커 문서에 기록해두었습니다. 서비스를 오픈하고 남은 개선사항이 무엇인지 이들의 우선순위가 어떤지 빠르게 점검할 수 있었습니다. 이를 통해 예전의 의사결정 내용과 그 배경을 쉽게 파악하고 프로젝트를 이해할 수 있어 불필요한 재확인 과정을 줄이고 효율적으로 협업할 수 있었습니다. </p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이 프로젝트를 통해 PM에게 가장 중요한 역량 중 하나는 기술적인 구현 능력만큼이나, 다양한 사람과 조직을 하나의 목표로 움직이게 하는 커뮤니케이션 능력이었음을 다시 한번 깨달았습니다.</p>
<h2 style="margin-top: 80px;margin-bottom: 40px;font-size: 24px;font-weight: bold">이탈 없는 교환권 사용 경험을 위해: 바코드 이미지 인식을 통한 UX 최적화</h2>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">
이번 프로젝트는 외부에서 발행된 카카오톡 교환권을 배민 앱에 등록하여 사용할 수 있도록 하는 기능으로, 외부 고객 유입을 기대할 수 있는 프로젝트였습니다. 때문에 사용편의성이 중요한 화두였는데요. 단순히 교환권의 바코드 번호를 수동으로 입력하는 방식은 사용자에게 그다지 매력적이지 않을 가능성이 높았습니다. 그래서 사용편의성을 극대화하기 위해 교환권의 이미지를 업로드하면 바코드 번호를 자동으로 인식하는 기능을 필수 요구사항으로 구현하게 되었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">우선, 기능 구현을 위해서는 웹 환경에서 바코드 이미지를 인식할 수 있어야 하는데, 짧은 검토를 거친 결과 JavaScript 기반의 바코드 인식 라이브러리인 zxing.js를 사용하는 것이 좋겠다고 판단했습니다. ZXing(Zebra Crossing)은 2007년에 Google 소속 엔지니어인 Sean Owen이 시작한 오픈소스 바코드 디코딩 라이브러리입니다. Google의 인쇄 광고 팀 내부 프로젝트로 시작되어 안드로이드 진영에서 꾸준히 사랑받아 온 만큼, 라이브러리의 신뢰도 측면에서는 더할 나위 없이 좋은 선택이었습니다. 참고로, zxing.js는 ZXing을 JavaScript 환경에서 사용할 수 있도록 포팅한 구현체입니다. 이 라이브러리를 활용하면 다양한 바코드를 디코딩할 수 있는데, 이 글에서는 카카오톡 교환권에 포함된 1차원 바코드로 내용을 한정하도록 하겠습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/1-750x419.png" alt="" width="750" height="407" class="size-medium wp-image-24831" style="max-width: 100%;height: auto"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: https://developers.googleblog.com/en/zxing-1d2d-barcode-decoding-source-code-released/</figcaption></figure>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">문제 케이스 인식 과정</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">요구사항 자체는 간단, 명확했습니다. 이미지에서 바코드를 인식하여 번호를 뽑아내는 것이었습니다. 라이브러리 자체가 워낙 사용하기 쉽게 구성되어 있어 구현 과정에 큰 어려움이 없었고, 초기 테스트 시 모든 환경에서 바코드를 안정적으로 인식하는 듯 보였습니다. 실제로 카카오톡 바코드 캡처 이미지뿐만 아니라 다른 연동사의 바코드 이미지에서도 번호 추출이 정상적으로 이루어졌기 때문입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">하지만 한 가지 예상하지 못한 변수가 있었는데, 바로 카카오톡 선물하기의 ‘내 앨범에 저장’ 버튼을 통해 다운로드한 이미지를 인식하는 케이스였습니다. 팀원들과 함께 기능을 테스트하던 중, 해당 경로로 다운로드한 이미지는 바코드를 제대로 인식하지 못하는 현상을 발견했습니다. 기존 테스트를 모두 일반적인 휴대폰 화면 캡처 이미지로만 진행했기에, 해당 버튼이 존재한다는 사실을 미처 고려하지 못했던 것입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">문제 원인을 논의한 결과, ‘내 앨범에 저장’ 버튼을 사용했을 때는 이미지 가장자리에 노란색 테두리가 생성된다는 차이점을 찾아낼 수 있었습니다. 이후 테스트 삼아 해당 테두리 영역을 잘라내고 바코드 인식을 시도해 본 결과, 숫자가 정상적으로 추출되는 것을 확인할 수 있었습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/2-377x750.png"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">교환권 가장자리에 노란색 테두리가 생성된 모습</figcaption></figure>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">코드 분석을 통한 문제 원인 추정</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">사실 가장자리에 있는 노란색 테두리만 잘라내면 문제는 즉시 해결할 수 있었습니다. 가장자리로부터 일정 픽셀만큼 이미지를 잘라내거나, 노란색 컬러 값을 인식하여 해당 범위를 잘라내는 식으로 구현하면 됩니다. 하지만 이는 문제의 근본적인 원인을 해결하는 방식이 아닐뿐더러, 예상치 못한 부작용이 발생할 우려가 있었습니다. 가령, 가장자리에서 일정 픽셀을 일괄적으로 잘라내는 방식은 ‘내 앨범에 저장하기’ 버튼으로 다운로드한 이미지가 아닌 경우 형태를 예측할 수 없기에 바코드 영역 자체가 손실될 위험이 있었습니다. 노란색 영역을 인식하여 잘라내는 방식 역시, 향후 카카오톡 선물하기의 디자인이 변경되어 이미지 내 다른 영역에 노란색이 사용될 경우 문제가 발생할 여지가 있었습니다. 결국 보다 근본적인 원인 파악이 필요하다는 결론에 도달했고, 이를 위해 zxing.js의 코드를 살펴보기로 했습니다. 라이브러리가 이미지를 어떻게 처리하여 바코드 번호를 추출하는지에 대한 파악이 필요했기 때문입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">zxing.js가 바코드 이미지를 처리하는 과정을 요약하면 다음과 같습니다.</p>
<ol style="margin-bottom: 24px;line-height: 1.75">
<li>이미지를 Canvas에 올려서 각 픽셀의 RGBA 데이터를 담은 1차원 배열인 ImageData를 추출한다.</li>
<li>RGBLuminanceSource에서 RGBA 데이터에 가중치를 적용하여 하나의 ‘밝기값’을 계산한다. (그레이스케일 적용)</li>
<li>변환된 밝기값을 HybridBinarizer에서 0(검은색)이나 1(흰색)로 이진화한다.</li>
<li>이진화된 결과를 BinaryBitmap으로 감싸서 디코더가 사용하기 적합한 방식으로 변환하여 전달한다.</li>
<li>OneDReader(1차원 바코드 해석기)가 BinaryBitmap을 받아 이미지의 중앙 행을 뜯어내어 BitArray(0과 1의 배열)를 추출한 후 디코딩을 시도한다.</li>
<li>실패하면 중앙에서 위아래로 퍼져나가며 다음 행을 스캔한다. 성공하면 결과를 텍스트와 같은 Result로 반환한다.</li>
</ol>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">여기서 추정할 수 있는, 문제가 될 만한 과정은 바로 3번 과정입니다. HybridBinarizer는 이진화를 담당하는 클래스인데, 8&#215;8의 블록 단위로 이미지를 나누어 각 블록의 임곗값을 계산합니다. 이 임곗값을 구하는 과정에서 밝은 노란색이 영향을 끼쳤을 가능성이 있습니다. 그러면 이진화를 할 때 이 임곗값으로 인해 바코드가 유실되어 인식에 실패했을 것이라는 추정이 가능하게 됩니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">우선, RGBLuminanceSource에서 밝기값을 계산하는 공식은 (R + 2G + B) / 4 입니다. ColorZilla로 추출한 카카오톡 교환권의 노란색 테두리 색상값은 RGB로 (255, 222, 33)인데, 여기에 공식을 대입하면 밝기값은 거의 200에 가까운 값으로 나옵니다. 이 밝기값을 블록별로 평균내어 임곗값을 산출하는데, 만약 주변 픽셀들과의 대비가 부족하다면 단순히 (블록 내 최소 밝기값 / 2)를 임곗값으로 정합니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/3-1-750x192.png" alt="" width="750" height="407" class="size-medium wp-image-24831" style="max-width: 100%;height: auto"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">RGBLuminanceSource의 밝기값 계산과 HybridBinarizer의 블록별 임곗값 산출<br />
(Nano Banana AI이미지 생성)</figcaption></figure>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이렇게 산출된 블록별 임곗값은 이후 주변 5&#215;5 블록들의 임곗값과 다시 한번 평균을 내는 일종의 평탄화 과정을 거칩니다. 아마 여기에서 문제가 생겼을 거라고 추정합니다. 기존에 모바일 화면을 캡처한 이미지처럼 단순 흰 배경만 존재하는 경우에는 블록 내 픽셀들의 대비가 부족하므로(255 / 2)가 임곗값이 될 텐데, 적당하게 대비되는 노란색 테두리가 더해지면서 평균값을 임곗값으로 사용하게 되었을 가능성이 있습니다. 이미지에 더해진 노란색 테두리 영역이 꽤나 넓기 때문에 전체적인 임곗값을 끌어올리기에는 충분했을 것이고, 그러면 이진화에 사용되는 최종 임곗값 역시 위로 끌려올라가게 됩니다. 테스트에 사용된 JPEG 이미지의 바코드를 확대하면 바코드 막대의 가장자리 픽셀들이 회색으로 연하게 번져있는 모습을 볼 수 있습니다. 높아진 임곗값으로 인해 이 부분이 이진화 과정에서 흰색으로 변환되어 바코드 막대가 얇아지는 등의 문제가 발생했다는 것이 제 추정의 결론입니다. 실제로, HybridBinarizer로 이진화된 이미지를 직접 그려보면 아래와 같이 몇몇 바코드 막대의 두께가 원본보다 얇아진 모습을 볼 수 있습니다. 즉, 이는 바코드의 일부분이 유실된 것으로, 결국 기존 바코드와 흑백 비율이 달라져 에러가 발생한 것으로 추정해볼 수 있겠습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img loading="lazy" decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/3-750x303.png" alt="" width="750" height="407" class="size-medium wp-image-24831" style="max-width: 100%;height: auto"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">원본 바코드</figcaption><img loading="lazy" decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/4-750x300.png" alt="" width="750" height="407" class="size-medium wp-image-24831" style="max-width: 100%;height: auto"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">HybridBinarizer로 이진화한 모습</figcaption></figure>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">이진화 로직 변경을 통한 개선</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">제 추정을 요약해보면 ‘이진화에 사용되는 임곗값이 너무 높아져서 바코드 패턴의 일부가 유실되었다’라는 것입니다. 그렇다면 정확히 중간값을 임곗값으로 잡아 이진화를 적용하면 문제가 해결될거라는 단순한 결론에 도달했고, 임곗값을 128로 잡아 직접 이진화를 적용했습니다. 구현은 간단했습니다. zxing.js와 동일하게 canvas 위로 이미지를 올려서 ImageData를 추출한 다음, 그레이스케일 공식을 적용하여 밝기값을 뽑아내고 임곗값을 128로 하여 이진화를 적용하면 됩니다. 아래 이미지를 보면, 이전에 HybridBinarizer에서와는 다르게 바코드가 유실 없이 흑백 비율을 유지하는 모습을 볼 수 있습니다. 이렇게 간단한 개선을 마친 후 테스트를 진행한 결과, 문제가 되었던 노란색 테두리 이미지에 더해 기존의 모바일 캡처 이미지들 또한 바코드가 잘 인식되는 것을 확인할 수 있었습니다. 구현도 크게 어렵지 않아 팀원들에게 리뷰까지 수월하게 마칠 수 있었습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img loading="lazy" decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/5-750x303.png" alt="" width="750" height="407" class="size-medium wp-image-24831" style="max-width: 100%;height: auto"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">중앙값 이진화를 적용한 모습</figcaption></figure>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이후 배포까지 성공적으로 마치고 안도감을 느끼던 와중, 한 팀원이 우는 얼굴로 제게 카카오톡 교환권 이미지를 하나 보내주었습니다. 사실, ZXing이 기존에 블록 단위로 임곗값을 산출하고, 여러 블록의 임곗값을 평균내고 하는 것은 결국 다양한 환경에서의 바코드 인식률을 높이기 위함입니다. 하지만 저는 단순 중간값 이진화로 로직을 변경했기 때문에 바코드 인식률이 낮아질 수 있었고, 거기서 이슈가 발생한 것으로 보였습니다. 다행히도 운영 환경에서 장애가 발생한 것은 아니었고, 테스트용 이미지를 이것저것 집어넣다가 문제가 발견된 것이었습니다. 그래서 배포 전에 빠르게 문제를 해결하고자 바로 원인 분석에 들어갔습니다. </p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/6-370x750.png"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">문제를 일으킨 테스트용 이미지</figcaption></figure>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">바코드 형태에 따라 다른 최적의 이진화 방식</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">그렇다면 이번에 문제가 된 이미지에는 어떤 특징이 있었을까요? 한참을 고민하다가 생각난 특징 한 가지는 바로 바코드에 유독 얇은 막대가 많고 흰 영역의 비율이 높다는 점이었습니다. 생각해보면, 실제로 매장에 가서 직접 바코드를 찍을 때도 인식이 안되는 경우가 종종 있습니다. 이는 곧 바코드의 모양 자체가 문제가 될 수도 있겠다는 가설로 이어졌고, 검증을 위해 바로 테스트를 진행해보았습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img loading="lazy" decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/7-750x303.png" alt="" width="750" height="407" class="size-medium wp-image-24831" style="max-width: 100%;height: auto"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">HybridBinarizer로 이진화한 모습</figcaption><img loading="lazy" decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/8-750x315.png" alt="" width="750" height="407" class="size-medium wp-image-24831" style="max-width: 100%;height: auto"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">중앙값 이진화를 적용한 모습</figcaption></figure>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">첫 번째 이미지가 HybridBinarizer로 이진화한 모습이고, 두 번째 이미지가 중앙값으로 이진화한 모습입니다. ZXing이 바코드를 텍스트로 디코딩할 때는 [검은 막대, 흰 공백, 검은 막대, 흰 공백] 의 묶음이 하나의 숫자를 이룹니다. 이때, 각 영역의 비율을 계산하여 숫자로 변환하기 때문에 바코드의 각 영역이 비율을 잘 유지해야 문제없이 디코딩할 수 있습니다. 하지만 위 바코드의 얇은 막대들을 자세히 보면, 이전과는 다르게 오히려 중앙값 이진화에서 제 모습을 유지하지 못하고 더 얇아져 흑백 비율이 왜곡된 모습을 볼 수 있는데요. 특히 우측에 흰 공백이 많은 부분에서 그 정도가 더욱 심해지는 모습을 볼 수 있습니다. 결국, 중앙값 이진화를 거치면서 얇은 막대들 중 일부 영역이 유실되었고, 이러한 비율 왜곡이 누적되어 디코딩 실패로 이어졌다고 추정할 수 있겠습니다. </p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">그러면 내용을 종합해보았을 때, 어떤 이미지는 HybridBinarizer가 유리하고 어떤 이미지는 중앙값 이진화가 유리하다는 것인데, 둘 사이에서 어떻게 조율을 해주면 좋을까요? 한참을 고민하다가 내린 결론은, 그냥 둘 다 시도하는 것이었습니다. ‘내 앨범에 저장하기’ 버튼으로 바코드 이미지를 다운로드하는 사용자 비율이 높다는 가정 하에, 먼저 중앙값 이진화를 통해 디코딩을 시도한 뒤 에러가 발생하면 그 즉시 HybridBinarizer로 이진화하여 다시 디코딩을 시도하게끔 구현해주면 됩니다. 전체 디코딩 과정 자체가 소요 시간이 짧기 때문에, 두 번 시도한다고 해서 시간이 오래 걸린다거나 하지는 않았습니다. 구현을 마친 뒤 테스트를 해보니, 이제껏 문제가 발생했던 케이스들을 전부 성공적으로 디코딩하여 바코드 번호를 추출해낼 수 있었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">일련의 디버깅 과정을 통해 느낀 점은, 첫 번째 에러를 디버깅한 경험이 두 번째 에러를 대응하는 데에 많은 도움이 되었다는 점입니다. 처음 에러가 발생했을 때, 명확하진 않지만 그래도 어느 정도 근본적인 원인을 찾으려고 노력했는데요. 만약 이때 임시방편으로 문제만 해결하고 넘어갔다면, 그다음 에러를 디버깅하는 데에 꽤나 오랜 시간을 소모했을 것입니다. 하지만 부족하게나마 동작 과정을 이해하려 노력했고, 그러다 보니 다른 에러가 발생했을 때 ‘혹시 설마 이게 원인인가..?’ 하고 접근 방법을 빠르게 떠올릴 수 있었습니다. 개똥도 약에 쓴다(?)더니, ‘이걸 어디다 써먹나’ 투덜대면서 디버깅한 경험이 얼마 지나지 않아 바로 다시 쓸모가 생겨서 머쓱하면서도 나름의 배움이 있는 즐거운 경험이었습니다.</p>
<h2 style="margin-top: 80px;margin-bottom: 40px;font-size: 24px;font-weight: bold">낯선 기능을 익숙한 편리함으로: 서비스 수용도를 높이기 위한 고객향 메시지의 고민</h2>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">카카오톡 선물하기에서 구매한 모바일 교환권을 배달의민족에서 사용할 수 있도록 한 것은 고객분들께는 지금까지는 없었던 옵션을 제공하는 것이었습니다. 때문에 이같이 새롭고 편리한 기능을 어떻게 하면 고객분들께서 자연스럽게 이해하고 체득하실지 고민하며 인앱 프로모션의 키메시지와 그 내용을 구상했습니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">새로운 기능, 단 세 장면으로 이해시킬 수 있을까?</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이번 인앱 프로모션의 목적, 해결해야 할 문제에 대한 질문은 단순했습니다. “고객이 이미 가지고 있는 모바일 교환권을 배민에서 쓸 수 있다는 사실을 어떻게 해야 쉽게 이해하실까?”</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">카카오톡 선물하기로 받은 모바일 교환권은 많은 고객에게 이미 익숙한 형태입니다. 새로운 기능을 설명하기보다는, 이미 알고 있는 것을 익숙한 배민 앱에서 그대로 사용할 수 있다는 혜택을 빠르게 인지시키는 데 초점을 맞췄습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img loading="lazy" decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%EA%B8%B0%EC%88%A0%EB%B8%94%EB%A1%9C%EA%B7%B8_%EC%B5%9C%EC%9C%A0%EB%B9%88_1-750x221.png" alt="" width="750" height="407" class="size-medium wp-image-24831" style="max-width: 100%;height: auto"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">신규 기능의 주요 플로우 UI</figcaption></figure>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">위 이미지를 보시면 이 기능을 사용하기 위해 배민앱에서 고객이 실제로 거쳐야 하는 단계는 생각보다 많습니다. 카카오톡 선물함에서 교환권을 확인하고, 배민 앱에 교환권을 등록한 뒤, 주문할 때 사용하는 흐름입니다. 기획자나 내부 구성원에게는 자연스러운 과정이지만, 고객 입장에서는 한 번쯤 멈칫할 수 있는 지점이기도 했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">그래서 모든 과정을 상세히 설명하기보다는, 고객이 가장 익숙하게 느낄 수 있는 경험을 화면 중심으로 단순화하는 데 집중했습니다. 때문에 이 설명은 단 세 개의 지면이면 충분했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">먼저 카카오톡 선물하기 선물함에 있는, 모두가 한 번쯤 봤을 법한 바코드 형태의 모바일 교환권 화면을 떠올리도록 유도했습니다. 그 다음은 배민 앱에서 교환권을 등록하는 화면, 그리고 마지막으로 주문할 때 적용해 자연스럽게 사용하는 익숙한 사용 경험까지 세 가지 화면만을 가져와 표현했습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img loading="lazy" decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%EA%B8%B0%EC%88%A0%EB%B8%94%EB%A1%9C%EA%B7%B8_%EC%B5%9C%EC%9C%A0%EB%B9%88_2-750x552.png" alt="" width="750" height="407" class="size-medium wp-image-24831" style="max-width: 100%;height: auto"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">주요 플로우 중 대표적인 세 지면</figcaption></figure>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이 세 장면만 머릿속에 그려지면, “아, 그 교환권을 여기다 등록해서 주문할 때 쓰는 거구나”라고 한 번에 이해할 수 있으시리라 판단했습니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">공급자 아닌 고객 입장에서 명확한 키메시지를 설계하기</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">인앱 프로모션에서 소구할 키메시지 설계에서도 같은 원칙을 적용했습니다. 사용 가능한 브랜드나 상품을 나열하는 방식보다, 무엇이 달라졌는지를 가장 직관적으로 전달하는 문장이 필요했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">강조할 수 있는 키워드는 다양했습니다. 먼저 새로운 기능 제공에 초점을 맞춘 내용으로, 배민앱에서 5개 브랜드의 카카오톡 교환권을 사용할 수 있게 되었다는 점. 기존에 제공하고 있던 선물함에서 카카오톡 교환권 이미지로도 등록할 수 있다는 점입니다. 그리고 제휴한 브랜드와 배민앱에서 사용할 수 있는 카카오톡 교환권 옵션에 대해 혜택감 있게 풀어낼 수도 있습니다. 올해 9월 15일 배민앱에서 처음 기능을 런칭했을 때에는 5개 브랜드의 메뉴 교환권 일부만을 사용할 수 있었습니다. 때문에 배민앱에서 사용 가능한 카카오톡 교환권 브랜드의 수 혹은 이 브랜드의 카카오톡 교환권 중 가장 인기 있는 교환권만을 엄선해 들여온 점을 강조할 수도 있습니다. 이같이 여러 소구점을 고심한 끝에 가장 명확하다고 느낀 키메시지는 다음과 같습니다.</p>
<p>“ 카톡에서 받은 선물, 배민앱에서 주문 가능 ”</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">기능을 제공하는 입장에서는 ‘무엇을 할 수 있는지’ 혹은 ‘무엇을 제공하는지’에 초점을 맞췄겠지만, 고객 입장으로 다시 한번 생각했을 때 ‘이미 가지고 있는 그것을 사용하면 된다’는 점을 전면에 세우는 것이 옳겠다고 판단했습니다. 선물하기 고객뿐만 아니라 배민앱 고객은 이미 배민앱에서 카카오톡 교환권을 사용할 수 없다는 것을 인지하고 있습니다. 하지만 이제는 가능하다는 점을 알려주기만 해도 새로운 기능을 알리는 데 가장 큰 효과를 줄 수 있겠다고 생각했습니다. 등록과 사용 방법은 앞서 말씀드린 세 가지 지면을 활용해 프로모션 페이지 안에서 충분히 안내할 수 있다고 판단해, 키메시지를 최대한 단순하게 가져갔습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">더불어 기능 인지 이후의 행동까지 이어지게 하기 위해, 오픈 초반에는 사업팀에서 보유한 카카오페이 쿠폰을 활용한 프로모션을 함께 운영했습니다. 카카오톡 교환권을 배민앱에 등록하고 주문시 사용한 고객분들 1만명 대상으로 카카오페이 5천원 쿠폰을 지급하는 이벤트로 교환권 등록과 실제 사용까지 자연스럽게 이어질 수 있도록 설계했습니다.<br />
단순한 혜택 제공이라기보다는, “한번 등록해 볼 이유”를 만들어주는 장치에 가까웠습니다. 그 결과 오픈 초반 등록과 사용을 빠르게 부스팅하는 역할을 할 수 있었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">쿠폰 지급 이벤트는 14일 동안 진행할 예정이었으나, 준비한 1만개의 5천원 쿠폰이 단 9일만에 선착순 소진되었습니다. 보유한 교환권을 앱에 등록하는 것이 아닌, 주문까지 해야만 얻을 수 있는 혜택인데도 불구하고 9일 동안 수십 만 명의 고객이 프로모션페이지에 방문하였고, 예상했던 소진 기간보다 앞당겨졌었습니다. 또한 프로모션페이지 내에 카카오톡 선물함으로 랜딩하는 버튼을 삽입해 내가 보유한 선물 중 배민앱에서 사용할 수 있는 카카오톡 교환권이 있을지 살펴보도록 액션을 유도하는 모험을 해보았습니다. 그리고 이 버튼을 클릭한 고객님의 약 90% 이상이이 다시 돌아와 프로모션페이지를 열람하는 모습을 확인할 수 있었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이번 프로모션에서 가장 많이 고민했고, 결과적으로 만족스러운 것은 새로운 기능을 설명하려 하기보다 등록과 사용 과정을 핵심 지면 세 장으로 고객분들께 명확하게 인식시켰다는 점입니다. 고객이 스스로 상상하거나 추측하지 않아도, 직접 주문할 때 사용하는 흐름을 저절로 알 수 있도록 구성하는 데 집중했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">물론 아쉬운 점도 있었습니다. 아직 첫 발자국을 내딛게 된 기능인 만큼, 아래 이미지처럼 사용시 유의사항 안내 문구가 다소 깁니다. 정보를 빠짐없이 전달하려다 보니 생긴 트레이드오프였습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%EA%B8%B0%EC%88%A0%EB%B8%94%EB%A1%9C%EA%B7%B8_%EC%B5%9C%EC%9C%A0%EB%B9%88_3-267x750.png"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">카카오톡 교환권 유의사항 안내 문구</figcaption></figure>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">마지막으로, 최근 카카오톡 선물하기에서 모바일 교환권을 판매하는 6개 브랜드의 잔액권까지도 사용 가능한 기능이 추가로 오픈되었습니다. 앞으로 더 많은 브랜드가 입점하고 사용 가능한 교환권 범위가 넓어진다면, 이번 경험을 바탕으로 보다 규모감 있는 대고객 마케팅을 집행해 배달의민족의 많은 고객분들이 사랑하는 브랜드 모바일 교환권을 사용해 댁에서 편리하게 따뜻한 음식을 받아보실 수 있다는 것을 널리 알리고, 등록과 주문 사용률을 한 단계 더 끌어올리고자 합니다. </p>
<h2 style="margin-top: 80px;margin-bottom: 40px;font-size: 24px;font-weight: bold">지속적인 개선으로 완성해가는 고객 경험<br />
</h2>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">2025년 9월 16일 서비스 오픈 이후, 고객분들이 기다렸던 만큼 많은 카카오톡 교환권이 배민을 통해 사용되며 비즈니스 성장을 견인하고 있습니다. 프로젝트 팀은 단순 오픈에 그치지 않고 초기 2개월간의 VOC를 면밀히 분석했습니다. 사용법 문의를 제외하고 가장 비중이 높았던 &#8216;브랜드 확대&#8217; 니즈를 충족하기 위해, 11월과 12월에 걸쳐 상품군 및 교환권 유형 확대를 신속하게 진행했습니다.
</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">일부 브랜드로 시작했으나, 향후 파트너십 확대를 통해 교환권 사용률은 더욱 가파르게 성장할 것으로 기대합니다. 지속적인 브랜드 확장과 사용성 개선을 통해 고객분들의 이용 편의를 극대화할 예정입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">지금 카카오톡 선물함에 잠들어 있는 교환권이 있다면, 배민에서 더 편리하게 사용해 보시기 바랍니다.</p>
</div>The post <a href="https://techblog.woowahan.com/25049/">끊김 없는 사용 경험을 위하여 : 카카오톡 선물함 속 교환권을 배달의민족 주문으로 연결한 여정</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></content:encoded>

					<wfw:commentRss>https://techblog.woowahan.com/25049/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>


			</item>
		<item>
		<title>WOOWACON 2025 미니게임 WOOWA POP!</title>
		<link>https://techblog.woowahan.com/24999/</link>
					<comments>https://techblog.woowahan.com/24999/#respond</comments>

		<dc:creator><![CDATA[황창재]]></dc:creator>
		<pubDate>Tue, 23 Dec 2025 04:20:40 +0000</pubDate>
				<category><![CDATA[Backend]]></category>
		<category><![CDATA[Frontend]]></category>
		<category><![CDATA[우아콘]]></category>
		<category><![CDATA[WOOWACON]]></category>
		<guid isPermaLink="false">https://techblog.woowa.in/?p=24999</guid>

					<description><![CDATA[<p>지난 WOOWACON 2025 기술 콘퍼런스에서 미니게임을 운영했습니다. 우아팝(WOOWA POP!)이라는 이름의 수박 라이크(Suika-like) 게임이었습니다. 우아콘 세션 간에 플레이할 수 있고 미션이나 상위 랭킹을 달성하면 상품을 받을 수 있었습니다. 이렇게 쓰고 보니 별로 특별할 것 없는 프로젝트처럼 보입니다. 그런데 서문을 준비하며 개연성에 대해 찬찬히 고민해보니 아주 할 말이 없는 것도 아니더군요. 작은 우려에서 시작된 우아팝 개발에 관한 [&#8230;]</p>
The post <a href="https://techblog.woowahan.com/24999/">WOOWACON 2025 미니게임 WOOWA POP!</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></description>
										<content:encoded><![CDATA[<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/WOOWAPOP-2.png" alt="WOOWAPOP" width="300" class="size-medium wp-image-25012"></figure>
<p>지난 WOOWACON 2025 기술 콘퍼런스에서 미니게임을 운영했습니다. 우아팝(WOOWA POP!)이라는 이름의 수박 라이크(<a href="https://en.wikipedia.org/wiki/Suika_Game" title="Suika-like">Suika-like</a>) 게임이었습니다. 우아콘 세션 간에 플레이할 수 있고 미션이나 상위 랭킹을 달성하면 상품을 받을 수 있었습니다. 이렇게 쓰고 보니 별로 특별할 것 없는 프로젝트처럼 보입니다. 그런데 서문을 준비하며 개연성에 대해 찬찬히 고민해보니 아주 할 말이 없는 것도 아니더군요. 작은 우려에서 시작된 우아팝 개발에 관한 이야기를 차분히 풀어보겠습니다.</p>
<h3>폰 노이만, 그리고 게임을 푸는 사람들</h3>
<p>1928년 존 폰 노이만(John von Neumann)은 포커를 연구하고 있었습니다. 블러핑(Bluffing, 나쁜 패를 들고도 좋은 패인 것처럼 행동하여 상대를 속이는 전략)이 왜 작동하는지 그리고 언제 블러핑을 해야 하는지에 대한 수학적 답을 찾고 있었고, 그 과정에서 발견한 것은 단순히 포커 전략이 아니라 모든 전략적 상황을 수학적으로 분석할 수 있는 프레임워크였습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%ED%8F%B0%EB%85%B8%EC%9D%B4%EB%A7%8C-1-750x401.png" alt="폰노이만" width="600" class="size-medium wp-image-25012"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<p>그가 증명한 미니맥스 정리(<a href="https://en.wikipedia.org/wiki/Minimax" title="Minimax Theorem">Minimax Theorem</a>)는 2인 제로섬 게임에서 게임의 균형값이 존재한다는 것을 보이며 게임을 완전히 추상화했습니다. N명의 플레이어, 전략 공간, 보수 함수만 있으면 게임을 정의할 수 있습니다.</p>
<p>폰 노이만의 프레임워크에서 게임을 푼다는 것은 게임의 균형값을 찾고 그 값을 달성하는 최적 전략을 계산하는 것입니다. 일례로 체스는 이론적으로 풀린 게임입니다. 완벽한 플레이를 한다면 흰색이 이기는지 검은색이 이기는지 무승부인지가 이미 결정되어 있으며, 다만 우리가 그 답을 아직 계산하지 못했을 뿐입니다. 체스는 약 10<sup>120</sup>개의 가능한 게임이 있는데 우주의 원자 개수가 10<sup>80</sup>개인 것을 생각하면 체스를 완전히 푸는 것은 물리적으로 불가능에 가깝지만 게임 이론적 관점에서는 가능한 것입니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%EC%B2%B4%EC%8A%A4-750x409.png" alt="체스와 우주의 경우의 수" width="600" class="size-medium wp-image-25012"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<p>해커(Hacker, 컴퓨터 내의 시스템이나 프로그래밍에 전문적인 지식을 가진 사람)는 폰 노이만의 후예입니다. 게임을 수학적 구조로 환원하고, 보수 함수를 역공학하며 최적해를 계산하는 해커에게, 클라이언트 코드를 뜯어보는 것은 게임의 전략 공간과 보수 함수를 직접 읽는 것과 다르지 않습니다. 개발자 도구를 열어 DOM을 탐색하는 것이나 와이어샤크(Wireshark)로 패킷을 분석하는 일, 혹은  메모리를 덤프하여 변수를 찾아내는 모든 행위는 게임을 투명한 수학 문제로 만드는 과정입니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%ED%95%B4%EC%BB%A4.png" alt="폰 노이만의 후예" width="600" class="size-medium wp-image-25012"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<p>2025년 우아한형제들 기술 콘퍼런스를 준비하며 우리에게 주어진 문제는 명확했습니다. 참여자 2,000명이 모인 행사장에서 랭킹 게임을 운영해야 했습니다. 누군가 개발자 도구를 열어볼 수도 있고 호기심에 API 요청을 조작해 볼 수도 있을 것입니다. 물론 행사 당일에 해킹이나 매크로를 통해 문제가 발생할 확률은 매우 희박합니다. 하지만 만약에 기술 콘퍼런스에서 랭킹이 조작된다면, 과연 당당하게 “기술’’ 콘퍼런스에서 선보인 게임이라고 할 수 있을까요?</p>
<h3>게임에서 배운 것</h3>
<p>처음 게임에 대해 고민을 해본 경험은 <a href="https://lvup.app" title="레벨업 게임">레벨업 게임</a>을 만났을 때입니다. 레벨업 게임은 1 Level부터 시작해서 버튼을 누르면 일정 확률로 +1 또는 -1이 되는 단순한 랭킹 게임입니다. 300까지 쌓아올린 Level을 극악의 확률로 1 Level로 만들기도 했습니다. 매크로를 만들기 매우 쉬운 구조였고 실제로 누군가 매크로를 돌리기 시작했습니다.</p>
<p>게임 개발자는 처음에 변수 이름을 의미 없는 문자열로 바꾸고 로직을 뒤섞는 등 코드 난독화를 시도했지만 그저 시간을 지연시킬 뿐이었습니다. 그래서인지 금방 매크로 방지 기능이 추가되었습니다. 빠르게 움직이는 프로그래스바 위에 커서가 정확히 중앙에 왔을 때 클릭 해야지만 Level을 올릴 수 있게 바뀌었지만 이 또한 무용지물이었습니다. 마지막으로, CAPTCHA 형태의 방어 로직이 추가되었습니다. 서버에서 변형된 동물 이미지를 내려주면 사용자는 변형되지 않은 이미지를 골라야지만 Level을 올릴 수 있었습니다.</p>
<figure style="text-align: center;margin: 30px 0"><video src="https://techblog.woowa.in/wp-content/uploads/2025/12/%EB%A0%88%EB%B2%A8%EC%97%85-1.mov" controls width="600" class="size-medium wp-image-25012" style="max-width: 600px;width: 100%"></video></figure>
<p>결과적으로 매크로 개발자는 사라졌습니다. 코드 분석만으로는 더이상 매크로를 만들 수 없어서 그런 걸 수도 있고 더이상 흥미를 잃어서일 수도 있습니다. 매크로는 막았지만, 게임의 재미는 크게 반감됐습니다. 레벨업 게임 본질의 단순함은 사라지고 동물 이미지를 맞추는 일만 남았습니다.</p>
<p>이 게임에서 배운 것은 명확했습니다. 게임 동작에 보안 장치를 덧붙이면 게임이 아니게 됩니다. 게임 위에 보안 시스템을 올리는 것이 아니라 게임 자체가 보안이 되어야 했습니다.</p>
<h3>CAPTCHA</h3>
<p>CAPTCHA는 역 튜링 테스트(Reverse Turing Test)입니다. 앨런 튜링(Alan Turing)의 튜링 테스트(Turing Test)가 “기계가 인간처럼 생각하는가”를 묻는다면 CAPTCHA는 “당신이 기계가 아니라는 것을 증명하라”고 요구하는 Completely Automated Public Turing test to tell Computers and Humans Apart의 약자입니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/CAPTCHA.png" alt="CAPTCHA" width="600" class="size-medium wp-image-25012"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<p>1세대 CAPTCHA는 왜곡된 텍스트를 보여주었습니다. 글자를 비틀고 노이즈를 추가하고 배경을 복잡하게 만들어서 인간은 읽을 수 있지만 OCR(Optical Character Recognition)은 읽기 어렵게 만들었습니다. 하지만 OCR 기술이 발전하며 점점 더 왜곡된 텍스트가 필요했고 결국 인간도 읽기 어려워지는 지경에 이르렀으며 무력화되었습니다.</p>
<p>2세대는 reCAPTCHA를 통해 이미지 선택 방식으로 발전했습니다. “신호등이 있는 이미지를 모두 선택하세요”, “자전거가 있는 이미지를 모두 선택하세요” 같은 방식이었고 의미론적 이해를 요구했기에 단순 OCR보다는 어려웠습니다. 하지만 CNN(Convolutional Neural Network)과 컴퓨터 비전 기술이 발전하며 2012년 AlexNet이 ImageNet에서 인간 수준 정확도를 달성했고 이미지 인식도 무력화되었습니다.</p>
<p>3세대 reCAPTCHA v2는 더 영리해졌습니다. “나는 로봇이 아닙니다” 체크박스를 도입했고 클릭 패턴과 마우스 움직임과 브라우저 데이터를 분석했습니다. 체크박스를 클릭하기까지 마우스가 어떻게 움직였는지 클릭 타이밍이 자연스러운지 브라우저 핑거프린트가 정상적인지를 종합적으로 판단했습니다. 인간의 행동 패턴을 학습하는 것이었지만 이 또한 모방 가능했고 일부 우회가 가능해졌습니다.</p>
<p>4세대 reCAPTCHA v3는 완전히 투명해졌습니다. 사용자에게 아무것도 요구하지 않고 백그라운드에서 위험 점수를 계산하며 페이지 전체의 사용자 행동을 분석하여 0.0에서 1.0 사이의 점수를 부여합니다. 하지만 ChatGPT Agent와 같은 고도화된 AI 에이전트가 브라우저를 제어하며 자연스러운 행동 패턴을 재현하기 시작했고 결국 무력화가 가능했습니다.</p>
<p>5세대 IllusionCAPTCHA는 시각적 착시를 사용합니다. 인간의 인지 시스템은 쉽게 처리하지만 픽셀 레벨로 분석하는 AI는 혼란스러워하는 이미지를 만들어냅니다. 하지만 이것도 언젠가는 무력화될 것입니다.</p>
<p>AI의 정복 역사를 보면 패턴이 보입니다. 1997년 Deep Blue가 체스 챔피언을 이겼고 2016년 AlphaGo가 이세돌을 4대 1로 이겼으며 2017년 Libratus가 텍사스 홀덤 포커에서 프로 4명을 상대로 이겼고 2019년 Pluribus가 6인 포커를 정복했으며 2019년 OpenAI Five가 Dota 2 프로 팀을 이겼습니다. “인간에게만 쉬운 것”은 점점 사라지고 있습니다.</p>
<p>하지만 비용은 여전히 중요합니다. AI가 CAPTCHA를 통과할 수 있다는 것과 모든 봇이 실제로 통과한다는 것은 다른 문제이며 계산 비용, 개발 비용, 탐지 위험을 고려하면 여전히 CAPTCHA는 대부분의 자동화를 막아냅니다.</p>
<p>그렇다면 &quot;비용이 높다&quot;는 것은 어떻게 정의할 수 있을까요?</p>
<h3>어려움의 수학적 정의</h3>
<p>계산 복잡도 이론(Computational complexity theory)은 어떤 문제가 얼마나 어려운가를 수학적으로 정의합니다. 계산 복잡도 이론에서 P는 Polynomial Time의 약자로 입력 크기 n에 대해 다항 시간 O(n^k)에 해결할 수 있는 문제들입니다. 정렬, 최단 경로 찾기, 이진 탐색이 여기 속하며 “효율적으로 풀 수 있다”의 수학적 정의입니다.</p>
<p>NP는 Non-deterministic Polynomial Time의 약자로 주어진 해답을 다항 시간 내에 검증할 수 있는 문제들입니다. 해답을 찾는 것은 어렵지만 검증은 쉬운 문제들이며 스도쿠가 대표적입니다. 9&#215;9 스도쿠를 푸는 것은 어렵지만 완성된 스도쿠가 규칙을 만족하는지 확인하는 것은 각 행, 열과 3&#215;3 박스를 확인하면 되므로 쉽습니다.</p>
<p>NP-Complete는 NP 문제 중에서 가장 어려운 문제들입니다. 모든 NP 문제를 이것으로 변환할 수 있으며 하나의 NP-Complete 문제를 P 시간에 풀 수 있다면 P = NP가 증명됩니다. SAT 문제(Boolean satisfiability problem)와 외판원 순회 문제(Traveling Salesman Problem)가 여기 속하고 테트리스, 지뢰찾기, 스도쿠와 같은 많은 게임들이 NP-Complete로 증명되었습니다.</p>
<p>NP-Hard는 적어도 NP-Complete만큼 어려운 문제들이며 NP에 속하지 않을 수도 있습니다. 검증조차 어려울 수 있다는 뜻입니다. 물리 시뮬레이션과 앵그리 버드가 2017년에 NP-Hard로 증명되었습니다.</p>
<p>조금 더 나아가서, PSPACE(Polynomial Space)는 다항 공간이 필요한 문제들이며 NxN 일반화된 체스와 바둑이 여기 속합니다. EXPTIME(Exponential Time)은 지수 시간이 필요한 문제들이며 특정 변형된 바둑이 여기 속합니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/PNP.jpg" alt="P=NP 다이어그램" width="600" class="size-medium wp-image-25012"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<p>P = NP 문제는 클레이 수학연구소의 밀레니엄 문제 중 하나로 100만 달러의 상금이 걸려 있습니다. 대부분의 컴퓨터 과학자들은 P ≠ NP라고 믿으며 이것은 “해답 검증이 쉬운 모든 문제는 해답 찾기도 쉽다”가 거짓이라는 의미이며 본질적으로 어려운 문제가 존재한다는 뜻입니다. 만약 P = NP라면 암호화가 무너지고 최적화 문제들이 모두 효율적으로 풀리며 모든 게임이 효율적으로 풀립니다. 하지만 우리는 P ≠ NP라고 믿으며 아직까지 게임과 암호가 가능한 세상에 살아가고 있습니다.</p>
<p>레벨업 게임은 O(1) 복잡도였습니다. 점수는 클릭에 비례해서 증가하는 단순한 구조였고 정답이 코드에 그대로 있었으며 코드를 읽으면 즉시 해킹(매크로)이 가능했습니다. P 복잡도 게임도 여전히 취약합니다. 몇 번의 시도로 패턴을 파악할 수 있고 리버스 엔지니어링이 가능합니다. NP-Hard 복잡도 게임은 다릅니다. 최적 전략을 계산하는 것 자체가 NP-Hard이므로 해킹 비용이 플레이 비용보다 높아지기에 게임을 플레이하는 수밖에 없습니다.</p>
<h3>증명과 일방향성</h3>
<p>알리바바의 동굴 이야기가 있습니다. 동굴에 A와 B 두 갈림길이 있고 안쪽에서 만나며 두 길 사이에 마법의 문이 있어서 비밀 주문을 알아야 열 수 있습니다. 증명자는 주문을 안다고 주장하고 검증자는 이를 확인하고 싶지만 주문 자체는 알고 싶지 않습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%EC%95%8C%EB%A6%AC%EB%B0%94%EB%B0%94.jpg" alt="알리바바의 동굴" width="600" class="size-medium wp-image-25012"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<p>방법은 간단합니다. 증명자가 동굴 입구에 들어가서 A 또는 B 중 무작위로 선택해 들어가면 검증자는 증명자가 어느 쪽으로 갔는지 보지 못합니다. 검증자가 동굴 입구로 와서 “A 쪽으로 나와!” 또는 “B 쪽으로 나와!”를 무작위로 외칩니다. 증명자가 주문을 안다면 문을 열어서 요청받은 쪽으로 나올 수 있지만 모른다면 50% 확률로만 맞출 수 있습니다. 20번 반복하면 진짜 아는 사람은 100% 성공하지만 모르는 사람이 모두 성공할 확률은 (<sup>1</sup>&frasl;<sub>2</sub>)<sup>20</sup>으로 100만 분의 1이 됩니다.</p>
<p>검증자는 증명자가 주문을 안다는 것을 확신하지만 주문이 무엇인지는 전혀 모릅니다. 이것이 영지식 증명입니다. 1985년 Shafi Goldwasser, Silvio Micali와 Charles Rackoff가 제안했으며 완전성·건전성·영지식성이라는 세 가지 속성을 만족합니다.</p>
<ul>
<li>완전성: 증명자가 진짜 안다면 검증자를 항상 설득할 수 있어야 함</li>
<li>건전성: 증명자가 모른다면 검증자를 속일 확률이 극도로 낮아야 함</li>
<li>영지식성: 검증자가 “증명자가 안다”는 사실 외에는 아무것도 배우지 못해야 함</li>
</ul>
<p>Goldwasser와 Micali는 이 업적으로 튜링상을 받았습니다.</p>
<p>1992년 Adi Shamir는 놀라운 정리를 증명했습니다. IP = PSPACE입니다. 알리바바 동굴과 같은 대화형 증명(Interactive Proof)으로 검증할 수 있는 모든 문제는 다항 공간으로 풀 수 있는 문제와 같다는 의미이며 체스나 바둑 같은 PSPACE-Complete 게임도 이론적으로는 대화형 증명으로 “내가 이길 수 있다”를 검증할 수 있다는 뜻입니다. 하지만 대화형 증명은 여러 질문과 응답을 반복해야 하며 반복할수록 검증의 신뢰도가 올라가는 문제가 있습니다.</p>
<p>ZK-SNARK(Zero-Knowledge Succinct Non-Interactive Argument of Knowledge)는 이 한계를 개선합니다. 여러 상호작용 없이 한 번의 증명으로 검증할 수 있으며 검증 시간도 짧습니다. 이더리움의 Layer 2 솔루션들이 이 기술을 사용하며 Dark Forest 같은 블록체인 게임도 ZK-SNARK로 사용자 행동을 검증합니다. 하지만 ZK-SNARK를 우아팝에 적용하는 것은 효과적이지 않으며, 그 이유는 여백이 부족해서 여기 적지 않습니다.</p>
<p>일방향 함수는 계산은 쉽지만 역계산은 어려운 함수입니다. f(x)를 계산하는 것은 쉽지만 f(y) = z일 때 y를 찾는 것은 어렵습니다. 암호학의 기본 원리이며 RSA 암호화와 해시 함수가 여기에 기반합니다. 게임도 해킹을 방어하기 위해 같은 구조로 만들 수 있습니다. 입력에서 점수를 계산하는 것은 쉽지만 원하는 점수에서 입력을 찾는 것은 어렵게 만들면 됩니다.</p>
<p>우아팝의 검증 구조는 일방향 함수로 만들어져 있습니다. 사용자 입력 시퀀스를 받아 게임을 시뮬레이션하여 점수를 계산하는 것은 다항 시간에 가능하지만 원하는 점수를 만들어내는 입력을 찾는 것은 물리 엔진 전체를 역산해야 하므로 NP-Hard입니다. 해킹은 곧 함수 역산이 되며 역산이 NP-Hard면 해킹 비용이 플레이 비용보다 높아집니다.</p>
<h3>물리 엔진</h3>
<p>물리 시뮬레이션은 사람에게는 단순하지만 수학적으로는 복잡합니다. 여러 변수가 상호작용하며 공의 위치·속도·각속도가 매 틱(Tick, 물리 엔진의 상태를 계산하는 주기)마다 업데이트되고 충돌 감지와 충돌 응답이 계산되며 마찰·반발·중력이 적용됩니다. 따라서 최적 전략을 계산하는 것은 NP-Hard이지만 플레이어에게는 직관적입니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%EA%B5%90%EC%B0%A8-%EA%B2%80%EC%A6%9D.jpg" alt="교차 검증 구조" width="600" class="size-medium wp-image-25012"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<p>클라이언트는 사용자 입력만 전송합니다. 아무리 NP-Hard 수준으로 최적 전략을 계산하기 어려운 게임도 점수를 API로 직접 보내게 되면 해커에게는 O(1)과 동일한 게임이 되어버립니다. 영지식은 해커의 손길이 닿지 않는 서버까지 이어져야 하기에 서버로 전송하는 정보는 터치 좌표와 타이밍뿐이며 매 프레임의 게임 상태나 점수를 전송하지 않습니다. 서버는 오직 사용자 입력 시퀀스만으로 게임을 처음부터 끝까지 완전히 동일하게 시뮬레이션합니다. 같은 물리 엔진을 사용하고 같은 초기 상태에서 시작하며 같은 사용자 입력을 순서대로 적용했을 때 클라이언트 점수와 서버 점수가 같으면 검증 성공이며 다르면 검증 실패입니다.</p>
<h3>결정론</h3>
<p>클라이언트·서버 교차 검증 구조를 가지기 위해서는 반드시 전제되어야 할 게 있습니다. 같은 입력이 주어지면 항상 같은 결과가 나와야 하는 결정성(determinacy)입니다. 클라이언트와 서버가 완전히 동일한 게임을 재현해야 하며 공의 궤적, 충돌 지점, 점수 계산이 소수점 이하 하나도 틀리지 않고 똑같아야 합니다.</p>
<p>JavaScript의 Math 함수는 구현 의존적입니다. ECMAScript 명세는 Number 타입이 IEEE 754 double-precision을 따르고 기본 산술 연산이 IEEE 754를 준수한다고 명시하지만 Math.sin이나 Math.cos 같은 초월함수는 &quot;implementation-approximated&quot;라고만 표현하며 정확한 알고리즘을 강제하지 않습니다. IEEE 754 표준 자체도 사인이나 코사인 같은 초월함수의 계산 방법을 정의하지 않습니다.</p>
<p>현대 JavaScript 엔진들은 Math 함수를 매우 일관되게 구현하지만 완벽히 동일하지는 않습니다. Node.js 10에서 Math.pow(<sup>1</sup>&frasl;<sub>3</sub>, 3)은 0.037037037037037035를 반환하지만 Node.js 12에서는 0.03703703703703703를 반환합니다. 아주 미세한 차이지만 물리 시뮬레이션에서 1000번 반복되면 완전히 다른 결과가 될 수 있습니다.</p>
<p>JavaScript 런타임 엔진도 살펴보겠습니다. 클라이언트는 브라우저에서 실행되며 Chrome 브라우저의 경우 V8, Safari 브라우저의 경우 JavaScriptCore를 런타임 엔진으로 사용합니다. 서버는 Node.js의 경우 V8, Bun의 경우 JavaScriptCore에서 실행되기에 모든 환경에서 동일한 런타임 엔진을 사용할 수 없습니다. 각 런타임 엔진의 과거 버전에 대한 호환성도 문제이기에 초월 함수 구현 알고리즘에 대해서 일관성을 보장하기 어렵습니다.</p>
<p>이 문제를 해결하기 위해 WASM 기반의 물리 엔진을 사용했습니다. JavaScript의 Math를 호출하지 않고 Rust 표준 라이브러리가 수학 함수를 구현하여 크로스플랫폼에서 모두 동일한 Rust 구현의 수학 함수가 실행될 수 있도록 했습니다. 그 결과 크로스플랫폼에서 동일한 코드가 실행되고 완전히 동일한 결과가 나올 수 있었습니다.</p>
<h3>마지막 1틱</h3>
<p>개발은 순조로웠습니다. WASM 기반의 물리 엔진으로 게임 엔진을 만들었으며 클라이언트와 서버는 사용자 이벤트만 주고받으며 교차 검증 구조를 이루었습니다. 하지만 QA(Quality Assurance)중, 간헐적으로 점수 검증이 실패했다는 에러가 수집되었습니다. 클라이언트와 서버의 점수 계산에 불일치가 발생해서 결정성이 깨졌다는 의미입니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%EA%B2%80%EC%A6%9D%EC%8B%A4%ED%8C%A8.png" alt="교차 검증 구조" width="600" class="size-medium wp-image-25012"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">우아팝 플레이 스크린샷 (좌: 검증 실패, 우: 검증 성공)</figcaption></figure>
<p>코드를 한 줄씩 추적하고 로그를 찍고 각 틱마다 게임 상태를 비교했습니다. 물리 엔진은 결정론적이며 입력은 정확히 전송되고 있었고 seed 기반의 랜덤 함수도 잘 동작하고 있었습니다.</p>
<p>문제는 마지막 1틱이었습니다. 게임 종료 조건을 만족할 경우 클라이언트는 그 즉시 최종 점수를 계산했고 서버는 마지막 1틱까지 포함해서 최종 점수를 계산하고 있었습니다. 게임 종료 직전 마지막 한 틱에 의해서 점수가 증가할 경우, 서버와 클라이언트의 점수가 달라지고 있었던 것입니다.</p>
<p>한 틱은 우아팝 게임 엔진에서 고작 0.016초에 불과한 아주 작은 찰나입니다. 하지만 이 작은 차이로 인해서 클라이언트·서버 간의 교차 검증이 실패했고 이것은 곧 결정성의 중요성을 말해준 것입니다.</p>
<h3>2,000명</h3>
<p>점수의 무결성은 해결했지만 2,000명이 동시에 접속하는 상황은 또 다른 문제였습니다. 플레이어들은 끊임없이 최고 점수를 갱신하며 쓰기 부하를 만들어냈고, 동시에 리더보드를 확인하려는 요청이 폭발적으로 증가하면서 읽기 부하 또한 급격히 상승했습니다. 읽기와 쓰기 요청이 짧은 시간 안에 한꺼번에 쏟아지자 데이터베이스는 빠르게 병목 구간에 도달했습니다.</p>
<p>이 문제를 해결하기 위해 우리는 완벽한 실시간 반영을 고집하는 대신, 잠시 시간을 ‘정지’시키는 방식으로 시스템을 보호하는 전략을 선택했습니다. 그 핵심은 바로 ‘로컬 메모리 캐싱’이었습니다.</p>
<p>상위 랭킹 달성자에게 주어지는 보상은 게임 종료 후 확정되기 때문에, 게임이 운영되는 동안 모든 사용자에게 완전히 동일한 랭킹을 제공할 필요는 없었습니다. 이 특성을 활용해 각 애플리케이션 인스턴스는 랭킹 목록을 자체 로컬 메모리에 저장하고, 데이터베이스 접근은 최소화하도록 설계했습니다. 이를 통해 동시 접속자가 2,000명까지 몰려도 리더보드는 일관되게 빠른 응답을 제공할 수 있었습니다.</p>
<p>캐시는 3초 간격으로 스케줄링하여 갱신되었습니다. 짧지만 규칙적인 이 주기는 시스템이 과도한 트래픽 사이에서도 호흡을 조절하며 안정적으로 버틸 수 있는 여유를 만들어주었습니다. 또한 캐시 갱신 중에도 API 응답의 일관성을 보장하기 위해 CoW(Copy-on-Write) 패턴을 적용했습니다. 새로운 데이터가 준비되는 동안에는 기존 캐시의 복사본을 제공함으로써, 갱신 시점에 발생할 수 있는 데이터 불일치를 원천적으로 차단했습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/CoW.png" alt="Copy on Write" width="600" class="size-medium wp-image-25012"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<p>애플리케이션 구동 시에는 초기 캐시를 먼저 로드해 안정적으로 시작할 수 있도록 했으며, 클라이언트는 주기적으로 랭킹 API를 호출하며 최신 데이터를 자연스럽게 소비하도록 설계되었습니다.</p>
<p>스트레스 테스트에서 3초 캐시와 CoW는 기대했던 대로 작동했습니다. 모의 부하 2,000명 상황에서 데이터베이스는 병목에 빠지지 않았고 리더보드 API는 안정적으로 응답했습니다. 완벽한 실시간은 아니었지만 3초 지연은 쉽게 눈치채기 어려웠습니다. 검증 서버는 결정론으로 무결성을 보장했고, 랭킹 서버는 트래픽을 감당할 수 있었습니다.</p>
<h3>14,570점의 등장</h3>
<p>우여곡절 끝에 QA를 무사히 마쳤고 검증 서버와 랭킹 서버에 대한 스트레스 테스트도 완료했습니다. 예상 트래픽을 고려해서 10대의 서버를 준비하고 트래픽이 적절히 분산될 수 있도록 했으며 모니터링 대시보드에 CPU·Memory·Latency·RPM 등 지표를 확인할 수 있도록 구성했습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%ED%98%84%EC%9E%A5-%EB%AA%A8%EC%9E%90%EC%9D%B4%ED%81%AC.jpg" alt="행사 당일 현장 모습" width="600" class="size-medium wp-image-25012"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">행사 당일 현장 모습</figcaption></figure>
<p>행사 당일 게임이 오픈되고 대형 스크린의 리더보드 앞으로 사람들이 몰렸습니다. 다들 게임을 플레이하기 시작했고 모니터링 대시보드에 수집되는 에러는 없었습니다.<br />
그런데 누군가 14,570점수를 기록하면서 1등에 올랐습니다. 대부분의 사용자는 5천 점 수준이었지만 1등은 7천 점대에 머물러 있는 2등과도 거의 두 배 가까이 차이 나는 점수를 기록했습니다. 검증은 통과했지만 점수가 비정상적으로 높으면 다른 방식의 치팅일 수도 있었습니다. 복잡한 마음으로 리플레이를 보기로 했습니다.</p>
<h3>게임을 다시 본다는 것</h3>
<p>유명한 고전 게임인 Doom은 1993년 입력 시퀀스만 저장하여 리플레이를 구현했습니다. 비디오를 저장하는 대신 플레이어의 키 입력과 마우스 움직임을 기록했고 리플레이할 때는 이 입력을 순서대로 재생하며 게임을 다시 실행했습니다. 실시간 전략 게임 StarCraft는 1998년 .rep 파일로 경기를 재현했으며 몇 KB 크기의 파일로 60분짜리 경기를 완벽하게 재현할 수 있었습니다. 격투 게임들은 프레임 단위로 입력을 기록했고 프로 게이머들은 리플레이를 분석하여 전략을 연구했습니다.</p>
<p>비디오 영상 전체가 아니라 사용자 입력을 저장하는 이유는 명확합니다. 60분 게임의 비디오는 GB 단위이지만 사용자 입력은 KB 단위의 용량을 차지합니다. 비디오는 조작 가능하지만, NP-Hard 수준의 결정성이 보장된 게임이라면 사용자 입력은 게임 전체를 재현할 수 있고 카메라를 자유롭게 조작할 수도 있으며 다양한 시점에서 게임을 관찰할 수 있습니다.</p>
<figure style="text-align: center;margin: 30px 0"><video src="https://techblog.woowa.in/wp-content/uploads/2025/12/1%EB%93%B1-%EC%9B%90%EB%B3%B8.mp4" controls width="300" class="size-medium wp-image-25012"></video><figcaption style="font-size: 13px;color: #999;margin-top: 8px">1등 리플레이 영상</figcaption></figure>
<h3>폰 노이만이 놓친 것</h3>
<p>폰 노이만의 게임 이론은 완벽한 합리성을 가정합니다. 모든 플레이어가 게임의 구조를 완벽히 이해하고 상대방의 전략을 예측하며 자신의 기댓값을 최대화하는 최적 전략을 계산하고 선택한다고 가정합니다. 이 가정 위에서 모든 게임은 추상화된 수학적 방정식으로 풀려버렸습니다.</p>
<p>그런데 완벽하게 풀린 게임에 재미가 남아있을까요. 모든 플레이어가 최적 전략을 알고 그대로 실행한다면 게임의 결과는 이미 결정되어 있고, 우리는 그저 정해진 확률을 따라 움직일 뿐입니다.</p>
<p>하지만 사람은 그렇게 하지 않습니다. 최적 확률을 알아도 직감을 따르고, 패턴을 읽으려 하고, 상대방의 심리를 추측합니다. 이런 사람의 비합리성 때문에 게임은 예측할 수 없게 되고, 예측할 수 없기 때문에 결과가 매번 달라지고, 결과가 달라지기 때문에 재미가 생깁니다. 폰 노이만의 수학은 게임을 풀었지만 사람의 비합리성이 게임을 다시 열어놓습니다.</p>
<p>우아팝도 이런 비합리적인 지점을 좋아합니다. 게임 화면은 기기별로 다른 화면 비율을 가질 수 있는데, 화면 비율이 세로로 길수록 플레이할 수 있는 공간이 늘어나 이론적으로 더 유리한 조건에서 점수를 낼 수 있습니다. 혹자는 이런 비합리적인 설계는 불공평하지 않냐고 할 수 있습니다.</p>
<p>우아팝에서 1등을 한 사용자의 화면 비율은 어땠을까요? 실제로는 1등을 한 사용자보다 더 유리한 화면 비율을 가진 사용자는 307명이나 있었습니다. 인생은 원래 불공평합니다. 하지만 그래서 더 재미있는 것 아닐까요?</p>The post <a href="https://techblog.woowahan.com/24999/">WOOWACON 2025 미니게임 WOOWA POP!</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></content:encoded>

					<wfw:commentRss>https://techblog.woowahan.com/24999/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>


			</item>
		<item>
		<title>Delivering the Future: 글로벌 해커톤 2025, 준비부터 운영까지</title>
		<link>https://techblog.woowahan.com/24940/</link>
					<comments>https://techblog.woowahan.com/24940/#respond</comments>

		<dc:creator><![CDATA[우아한형제들 DevRel]]></dc:creator>
		<pubDate>Fri, 19 Dec 2025 02:23:51 +0000</pubDate>
				<category><![CDATA[Culture]]></category>
		<guid isPermaLink="false">https://techblog.woowa.in/?p=24940</guid>

					<description><![CDATA[<p>들어가며 딜리버리히어로는 우아한형제들을 포함해 전 세계 70여 개국에서 다양한 브랜드를 운영하고 있습니다. 국가와 시장은 서로 다르지만 ‘더 나은 고객 경험’이라는 공통된 미션을 위해 모두 각자의 자리에서 기술로 다양한 도전을 해오고 있습니다. 이런 도전들을 더 단단하게 연결하기 위한 자리로, 올해 8월 글로벌 해커톤 2025가 진행되었습니다. 딜리버리히어로 본사가 위치한 독일 베를린을 베이스캠프로, 7개 엔티티, 60개 팀, 약 [&#8230;]</p>
The post <a href="https://techblog.woowahan.com/24940/">Delivering the Future: 글로벌 해커톤 2025, 준비부터 운영까지</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></description>
										<content:encoded><![CDATA[<h2>들어가며</h2>
<p>딜리버리히어로는 우아한형제들을 포함해 전 세계 70여 개국에서 다양한 브랜드를 운영하고 있습니다. 국가와 시장은 서로 다르지만 ‘더 나은 고객 경험’이라는 공통된 미션을 위해 모두 각자의 자리에서 기술로 다양한 도전을 해오고 있습니다. </p>
<p>이런 도전들을 더 단단하게 연결하기 위한 자리로, 올해 8월 <strong>글로벌 해커톤 2025</strong>가 진행되었습니다. 딜리버리히어로 본사가 위치한 독일 베를린을 베이스캠프로, 7개 엔티티, 60개 팀, 약 270명의 기술직군 구성원들이 2박 3일간 ‘<strong>Delivering the Future</strong>’라는 목표를 향해 달렸는데요. </p>
<p>이번 글로벌 해커톤에서는 총 4팀의 우승팀이 선정되었습니다. 예선 심사에는 각 엔티티의 CTO, CPO가 참여하였으며 최종 심사는 딜리버리히어로 글로벌 CTO 벤자민 만과 CPO 요하네스 브루더, 그리고 구글 클라우드의 토마스 클리트 디렉터가 함께했습니다. 수상 팀에게는 상금과 부상이 주어졌으며, 특히 챔피언 팀과 구글 스페셜 프라이즈 수상팀에게는 미국 라스베이거스에서 열리는 Google Cloud Next 2026에 참가할 수 있는 기회가 제공되었습니다.</p>
<p>특히 이번 해커톤은 우아한형제들 DR팀이 오거나이저로 참여해, 글로벌 기술 직군 구성원들을 연결하는 역할을 맡았다는 점에서 의미가 있었습니다. 한국에서 그동안 쌓아온 기술 커뮤니티 운영 경험을 바탕으로, 여러 지역의 팀을 연결하고 서로 다른 환경을 조율하며 이번 해커톤을 함께 만들어갔습니다.</p>
<p>서로 다른 배경과 경험을 가진 팀들이 함께한 이번 글로벌 해커톤은 어떻게 준비되었을까요? 한국의 우아한형제들을 비롯해 유럽, 중동, 남미 등 다양한 지역의 구성원이 참여한 이 행사의 준비 과정을 기술블로그를 통해 소개합니다.</p>
</p>
<p><!-- TODO: 앱 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_01-750x332.png" width="650" alt="추천"><em style="color: #666;font-size: 13px;font-style: normal"><br />
이번 글로벌 해커톤에 참가한 딜리버리히어로(독일), 우아한형제들(한국), 탈라밧(UAE),<br />
글로보(스페인), 판도라(싱가포르), 탭스퀘어(싱가포르), 페디도샤(아르헨티나)<br />
</em>
</div>
</p>
<h2>글로벌 해커톤을 준비하며</h2>
<p>글로벌 해커톤 준비는 크게 행사 기획, 기술 환경 구축, 현지 운영 방안 수립이라는 세 단계로 진행됐습니다. </p>
<h3>전체 행사 기획</h3>
<p></p>
<p><!-- TODO: 앱 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_02.png" width="650" alt="추천"><em style="color: #666;font-size: 13px;font-style: normal"><br />
글로벌 해커톤 2025 전체 일정<br />
</em>
</div>
</p>
<p>준비의 첫 단계는 전반적인 행사를 기획하고, 글로벌 환경에 맞는 소통 구조를 설계하는 일이었습니다. 말 그대로 큰 그림을 그리고 뼈대를 세우는 과정이었죠. 여러 국가가 동시에 참여하는 행사인 만큼, 일정과 운영 방식에 대한 초기 결정이 이후 모든 준비의 기준이 되었습니다. 각국의 공휴일(의외의 복병!)과 휴가 시즌을 함께 고려한 끝에, 가장 많은 구성원이 무리 없이 참여할 수 있는 시점으로 9월 4주 차를 행사 기간으로 정했습니다.</p>
<p>행사 운영 방식에 대해서는 ‘어떻게 글로벌 참여자들에게 몰입도 높은 경험을 제공할 수 있을까’를 기준으로 논의가 이어졌습니다. 해커톤의 특성상 오프라인에서 함께 몰입하는 경험이 중요하다는 점에는 모두가 공감했지만, 물리적으로 한 공간에 모이는 데에는 한계가 있었습니다. 그 결과, 각 엔티티의 오피스를 베이스로 같은 날 같은 시각에 해커톤을 진행하되, 라이브 중계와 온라인 채널을 통해 전 세계를 연결하는 온·오프라인 연계 방식을 결정했습니다.</p>
<p>이러한 구조를 실제로 구현하기 위해서는 현지 운영을 담당할 서포터들의 역할이 무엇보다 중요했습니다. 시간대가 너무 달랐기에 정기적인 회의를 진행하기보단 엔티티별 미팅을 선택하는 방식으로, 개별적으로 소통하기보단 서포터들을 위한 가이드 문서와 체크리스트 시트를 운영하는 방식처럼 더 효율적인 커뮤니케이션 원칙을 마련했습니다.</p>
<p></p>
<p><!-- TODO: 앱 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_03.png" width="650" alt="추천"><em style="color: #666;font-size: 13px;font-style: normal"><br />
행사 글로벌 타임존 안내. 각 베이스캠프에 맞게 꾸려진 행사 진행 시간과 장소를 안내했다.<br />
</em>
</div>
</p>
<p><!-- TODO: 앱 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_04.png" width="450" alt="추천"><em style="color: #666;font-size: 13px;font-style: normal"><br />
슬랙 채널 공지를 보낼 때마다 느껴진 긴장감<br />
</em>
</div>
</p>
<h3>기술 환경 구축</h3>
<p>해커톤에서 가장 중요하다고 할 수 있는 과정은 바로 기술 환경 구축이었습니다. 참가자들이 해커톤 동안 마음껏 비즈니스적 아이디어를 구상하고 펼칠 수 있도록, 공간과 도구를 마련해주는 일이기 때문입니다. 해커톤 상황에서 자유롭게 실험을 가능하게 하려면, 적절한 수준의 리소스 제공과 조율이 필요했습니다. </p>
<p>문제는 모든 참가자들이 원하는 기술 스택도 다르고, 아이디어를 구현하는 데 필요한 재료와 도구도 제각각이라는 점이었습니다. 어떤 팀은 GCP 기반을 선호하고, 어떤 팀은 AWS에 익숙했고, 또 어떤 팀은 ML 모델을 실험하고 싶어 했습니다. 이렇게 다양한 요구를 미리 고려해 모두에게 열려 있는 공통 환경을 준비하는 일은 생각보다 훨씬 까다로운 일이었는데요. 계정을 넓게 열어 자유롭게 실험하도록 하는 것이 해커톤의 이상적인 모습이었지만, 현실에서는 보안, 컴플라이언스, GDPR(EU 일반 개인정보 보호 규정) 등 까다로운 규제를 정면으로 마주해야 했습니다.</p>
<p>이번 해커톤에서는 중앙 조직인 딜리버리히어로의 오거나이저들이 직접 조율하고 공통의 가이드를 마련하는 핵심 역할을 수행하였습니다. 어떤 리소스를 기본 제공할지, 데이터 접근 절차는 어떻게 가져갈지, 엄격한 보안 규정 하에서의 진행이나, 각 엔티티의 제약을 어떻게 흡수할지 등을 함께 논의하며 공통된 인프라의 형태가 조금씩 만들어졌습니다.</p>
<p>이러한 배경 속에서 이번 해커톤의 기술 환경은 중앙 조직인 딜리버리히어로 오거나이저들이 중심이 되어 조율되었습니다. 기술 선택의 기준은 명확했습니다. 실제 현업 환경과의 연계 가능성, 글로벌 보안 및 컴플라이언스 요구사항 충족, 그리고 참가자들도 익숙하고 빠르게 실험할 수 있는 성숙한 제품이었습니다.</p>
<p>이러한 기준에 부합하는 선택지 중 하나가 Google AI 기반 환경이었고, 이번 해커톤에서는 구글 클라우드와의 파트너십을 통해 참가자들이 해당 환경을 보다 폭넓게 활용할 수 있었습니다.</p>
<p><!-- TODO: 앱 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_05.jpg" width="450" alt="추천"><em style="color: #666;font-size: 13px;font-style: normal"><br />
글로벌 스폰서십을 함께해준 구글 클라우드<br />
</em>
</div>
<p></p>
<h3>현지 운영 방안 수립</h3>
<p>이제 남은 과제는 글로벌 해커톤을 모두가 동시에 경험할 수 있도록 운영 방안을 만드는 일이었습니다. 해커톤의 가장 큰 매력은 한 공간에서 짧은 시간 안에 치열하게 하나의 목표를 향해 함께 달려 나가고, 그것을 완주하는 것에 있다고 생각했는데요. 서로가 다른 환경의 글로벌 행사지만, 물리적 참여 공간을 만들어주고 싶었습니다. 이러한 생각으로 저희는 각 엔티티의 오피스를 지역별 베이스캠프로 삼아 누구든 오프라인에서도 참여할 수 있도록 공간을 마련하게 되었습니다.</p>
<p>근무 형태와 조직 구성이 다양한 만큼, 자연스럽게 인접한 지역의 엔티티 간 오피스를 공유하는 모습도 나타났습니다. 같은 도시에 위치한 경우에는 소속과 관계없이 오피스를 개방해 함께 해커톤에 참여하기도 했고, 일부 구성원은 회사의 지원을 받아 다른 지역의 베이스캠프로 이동해 합류하기도 했습니다. 이러한 움직임 자체가 이번 해커톤이 가진 글로벌 협업의 분위기를 잘 보여주는 장면이었습니다.</p>
<p></p>
<p><!-- TODO: 앱 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_06.png" width="350" alt="추천"><em style="color: #666;font-size: 13px;font-style: normal"><br />
참가자 핸드북에 포함된 목차. 원활한 해커톤 참여를 위한 A-Z가 계속해서 업데이트되었다.<br />
</em>
</div>
</p>
<p>현장의 통일감도 중요했는데요. 어디에서 참여하든지 같은 행사에 참여하고 있다는 인상을 받을 수 있도록 행사 디자인 에셋을 공통으로 제작해 배포했습니다. 공간을 꾸미는 데에 참고가 되는 샘플 이미지들을 포함해 컬러코드와 규격, 소재 등을 구체적으로 기재해 공유했습니다. 각 서포터에게는 행사 공간을 원활히 운영할 수 있도록 별도의 예산을 배정했고, 기본 연출은 통일하되 각 엔티티의 오피스 분위기에 맞는 현장이 자연스럽게 만들어졌습니다.</p>
<p>해커톤의 꽃이라고 할 수 있는 굿즈도, 배포된 공통 디자인을 이용해 각 서포터들이 현지 업체에서 제작하게 되었는데요. 디자이너분이 꼼꼼히 챙겨주신 덕분에 모두가 같은 티셔츠를 입고 행사를 참여할 수 있게 되어 기뻤습니다. 참가자가 소수여서 제작 물량을 맞추기 어려웠던 페디도샤(PedidosYa) 참가자들을 위한 굿즈는 한국에서 직접 발송을 하게 되었었는데요. 티셔츠와 스티커가 남미 아르헨티나로 아주 먼 여정을 떠난 에피소드도 있었네요.</p>
<p></p>
<p><!-- TODO: 앱 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_07.jpg" width="450" alt="추천"></div>
<p><!-- TODO: 앱 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_08.jpg" width="450" alt="추천"><em style="color: #666;font-size: 13px;font-style: normal"><br />
굿즈. 티셔츠, 스티커, 큐브 등 해커톤을 위해 마련된 굿즈 패키지<br />
</em>
</div>
</p>
<p>그럼에도 불구하고 발생하는 한계점도 있었습니다. 특히 독일은 노동법에 따라 정해진 근무 시간 외 진행되는 행사를 할 수 없었는데요. 밤샘 없는 해커톤이라니! 하지만 이러한 한계점을 최소화하기 위해선, 온라인 운영의 밀도를 높이는 일이 더욱 중요했습니다.</p>
<p>먼저 전체 참가자 채널을 개설하여 모든 공지 사항과 질의응답을 통일하는 것부터 시작했는데요. 반드시 알아야 할 정보와 유의 사항들을 지속적으로 업데이트하면서 참가자들이 흐름을 놓치지 않도록 안내했습니다. 채널에서 흘러가는 정보를 놓치게 되는 부분은 참가자 핸드북 문서를 통해 관리하거나, 구글의 NotebookLM을 활용해 언제든 다시 찾을 수 있도록 했습니다. 행사 기간 동안 반드시 필요한 기술적인 문의는 엔지니어링 팀이 실시간으로 대응할 수 있도록 독일의 코어 근무시간과 아시아권을 대응할 싱가포르 근무시간으로 글로벌 타임존을 분산시키기도 했습니다.</p>
<p></p>
<h2>글로벌 해커톤, 3-2-1 Start!</h2>
<h3>Hello, from everywhere</h3>
<p>드디어 글로벌 해커톤의 막이 올랐습니다. 본 행사를 위해 그동안 온라인으로만 모여왔던 오거나이저들도 베를린에 있는 딜리버리히어로 오피스에 집결하였어요! 킥오프 세션은 딜리버리히어로 글로벌 CTO인 벤자민의 인사로 시작되었는데요. 모두가 한날한시에 행사를 시작한다는 점을 잘 보여주기 위하여 ‘Hello from everywhere’ 시간을 가졌습니다. </p>
<p>“안녕하세요~ 두바이의 탈라밧입니다! 여기는 현지 시각 오후 3시예요”<br />
“저희는 서울의 우아한형제들입니다! 여기는 현지 시각 오후 8시입니다”</p>
<p>각 엔티티 참가자들과 서포터들이 마치 현지 특파원처럼 라이브로 연결되어 인사말을 나눴는데요. 서로의 모습을 실시간으로 지켜보며 모두가 흥미롭고 신나하는 감정을 더 키울 수 있었습니다.</p>
<p>참가자들의 기대감과 재미는 팀 이름에서도 느껴졌습니다. 해커톤의 행운을 기원하는 ‘해커톤마타타(Hackathonamatata)’, 우승 혜택이었던 미국 라스베이거스 출장을 희망하는 ‘고라스(GOLAS)’ ‘베가스얼레디(VegasAlready)와 같은 이름도 있었는데요. 그 밖에도 결전의 의지가 느껴지는 ‘탭스퀘어 아미(TS-Army)’, ‘우아헌트릭스(Woowa Huntrix)’ 등의 이름도 재미있었습니다.</p>
<p></p>
<p><!-- TODO: 앱 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_09.jpg" width="450" alt="추천"><br /><!-- TODO: &#50545; &#51060;&#48120;&#51648; &#52628;&#44032; --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_10.jpg" width="450" alt="추천"><br /><!-- TODO: &#50545; &#51060;&#48120;&#51648; &#52628;&#44032; --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_11.jpg" width="450" alt="추천"><em style="color: #666;font-size: 13px;font-style: normal"><br />
킥오프 세레모니에서 ‘Hello from everywhere’를 하는 진행하는 모습. <br />서로 떨어져있지만 더 반가운 마음으로 모두가 함께했다.<br />
</em>
</div>
</div>
</div>
<p></p>
<h3>Top10을 향한 여정</h3>
<p>48시간 동안 이어진 본 행사(hack days) 내내 열정은 뜨거웠습니다. “Delivering the Future”라는 공통 주제 아래, 우리 조직이 앞으로 더 나아갈 수 있는 방향을 팀들이 치열하게 탐색해 나갔습니다.</p>
<p></p>
<p><!-- TODO: 앱 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_12_%EC%88%98%EC%A0%95.png" width="450" alt="추천"><br /><!-- TODO: &#50545; &#51060;&#48120;&#51648; &#52628;&#44032; --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_13.jpg" width="450" alt="추천"><em style="color: #666;font-size: 13px;font-style: normal"><br />
열정 넘치는 해커톤 본 행사(hack days) 현장<br />
</em>
</div>
</div>
<p></p>
<p>평가는 예선과 본선으로 나누어 진행되었는데요. 지역과 조직이 달라도 같은 기준으로 공정하게 평가하는 구조를 갖추는 것이 핵심이었습니다. 우선 각 엔티티에서 자체적으로 예선 데모데이를 열고, 엔티티별 CTO/CPO로 구성된 심사위원단이 팀별 점수를 부여했습니다.</p>
<p>이렇게 수집된 점수는 중앙에서 다시 한번 정제하였습니다. 엔티티마다 채점 방식과 점수 편차가 다르다는 점을 고려해, Z-score 표준화 방식을 도입했는데요. 각 팀의 점수를 해당 조직의 평균과 표준편차 기준으로 공정하게 보정하는 방식으로, “조직 평균 대비 얼마나 우수한가”를 기준으로 글로벌 파이널 데모데이에 오를 상위 10팀을 자동 계산하도록 시스템을 설계했습니다.</p>
<p>상위 10팀 발표 순간 역시 인상적이었습니다. 긴박한 분위기를 살리기 위해, Top10이 확정되자마자 Google 제미나이를 활용한 AI 영상으로 소개 콘텐츠를 제작해 발표했습니다. 팀 이름이 한 팀씩 공개될 때마다 각 지역에서 환호가 쏟아졌고, 온라인 화면 너머로도 그 열기가 그대로 전해졌습니다.</p>
<p></p>
<p><!-- TODO: 앱 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_14.jpg" width="450" alt="추천"><br /><!-- TODO: &#50545; &#51060;&#48120;&#51648; &#52628;&#44032; --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_15.jpg" width="450" alt="추천"><em style="color: #666;font-size: 13px;font-style: normal"><br />
글로벌해커톤2025 챔피언의 주인공, Tako 팀(위)과 2위를 수상한 GOLAS 팀(아래)의 피칭 모습<br />
</em>
</div>
</div>
<p></p>
<p>이번 글로벌 해커톤에서는 총 4팀이 수상의 영예를 안았습니다. 각 팀은 ‘Delivering the Future’라는 주제를 각자의 방식으로 해석하며, 기술과 비즈니스 관점 모두에서 인상적인 결과물을 선보였습니다.</p>
<ul>
<li>
<p>1등 – <strong>TAKO (Delivery Hero)</strong><br />
빠르게 변화하는 퀵커머스 환경에서, 레시피와 아이디어가 곧바로 주문과 배송으로 이어지는 AI 쇼핑 어시스턴트를 제안했습니다. 필요한 재료를 자동으로 구성해 장바구니를 완성하고, 고객의 쇼핑 여정을 하나의 흐름으로 자연스럽게 연결한 점이 높은 평가를 받았습니다.</p>
</li>
<li>
<p>2등 – <strong>GOLAS (Woowa Brothers)</strong><br />
AI 에이전트 기반으로 고객지원 흐름을 재설계한 맞춤형 CS 서비스를 선보였습니다. 주문 상황을 선제적으로 분석해 이슈를 해결하고, 상담사에게는 코파일럿 기능을 제공함으로써 고객 만족도와 운영 효율을 동시에 높일 수 있는 방향을 제시했습니다.</p>
</li>
<li>
<p>3등 – <strong>Pocket PauPau (Pandora)</strong><br />
캐릭터 커스터마이징과 미니게임 등 게이미피케이션 요소를 주문 여정에 자연스럽게 녹여낸 아이디어로 주목받았습니다. 고객이 앱에 머무를 이유를 만들어 주며, 팬덤과 바이럴을 유도할 수 있는 새로운 참여 경험을 제안했습니다.</p>
</li>
<li>
<p>Google Special Prize – <strong>Hungry Funnel (Delivery Hero)</strong><br />
AI 기반 챗 인터페이스를 활용한 벤더 온보딩 솔루션으로 특별상을 수상했습니다. 레스토랑 정보를 자동으로 수집하고 필요한 정보만 자연스럽게 질문하는 구조를 통해, 온보딩 과정을 더 빠르고 매끄럽게 만드는 접근이 인상적이었습니다.</p>
</li>
</ul>
<p>수상작들을 포함하여, 이번 해커톤의 모든 아이디어와 결과물은 글로벌 단위로 공유되어 각 엔티티에서 자유롭게 열람하고 검토할 수 있도록 했습니다. 일부 아이디어는 해커톤 이후에도 실제 적용 가능성을 두고 추가 논의로 이어지며, 다음 실험의 출발점이 되기도 했습니다.</p>
<h2>나가며</h2>
<p>이번 글로벌 해커톤은 단순한 48시간 개발 경쟁이라기보다, 우리가 얼마나 연결된 기술 조직인지 다시 확인하는 시간이었습니다. 문화도, 시장도, 기술 환경도 모두 다르지만 그 차이 덕분에 더 다양한 아이디어가 나오고, 새로운 해답이 만들어졌다고 생각합니다.</p>
<p>모든 행사가 종료된 뒤, 오거나이저들이 가장 먼저 나눈 말은 &quot;<em>&#8216;이게 될까?&#8217; 했는데 &#8216;이게 됐네요!’</em>&quot;였는데요. 널리 퍼져있는 참가자들의 시간대, 서로 다른 문화와 기술 환경, 그리고 수없이 전달해야 했던 정보들. 6개국 참가자들이 동시에 행사에 몰입할 수 있도록 신청 단계부터 본행사, 최종 발표까지 한 순간도 긴장의 끈을 놓기 어려웠습니다.</p>
<p>준비 과정을 모두 지금 돌이켜봤을 때, 가장 큰 도전 중 하나는 커뮤니케이션이었습니다. 하나의 메시지에 가능한 명확한 정보를 구체적으로 담아 전달하더라도, 이해 방식과 상황, 전달 범위는 제각각이었는데요. 조직 문화와 업무 맥락, 실제로 집행 가능한 예산까지 모두 다르다 보니 발생하는 변수를 실시간으로 조율해야 했습니다.</p>
<p>이번 경험을 통해 ‘글로벌&#8217;이라는 단어에는 예상보다 훨씬 더 큰 커뮤니케이션 비용과 운영 난이도가 숨어 있다는 점을 깨닫게 되었네요. 그럼에도 불구하고 이번 해커톤이 완성될 수 있었던 이유는 단 하나였습니다. 오거나이저, 서포터, 그리고 모든 참가자들이 ‘글로벌 해커톤을 잘 해보고 싶다’는 마음을 정말로 가지고 있었기 때문입니다.</p>
<p>해커톤이 끝난 지금도 뿌듯함과 아쉬움이 함께 남아 있습니다. 하지만 이번에 배운 것들을 잘 챙겨두면, 다음 해커톤에서는 더 깊고 재밌게 연결되는 글로벌 행사가 진행될 수 있을 거라 생각합니다. 앞으로도 우아한형제들과 여러 엔티티들이 함께 많은 실험과 협업, 더 큰 연결이 이루어지길 기대합니다.</p>
<p></p>
<p><!-- TODO: 앱 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_16.png" width="650" alt="추천"><br /><!-- TODO: &#50545; &#51060;&#48120;&#51648; &#52628;&#44032; --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/DH%EA%B8%80%EB%A1%9C%EB%B2%8C%ED%95%B4%EC%BB%A4%ED%86%A4-%ED%9A%8C%EA%B3%A0_17.jpg" width="650" alt="추천"><em style="color: #666;font-size: 13px;font-style: normal"><br />
글로벌해커톤2025 베를린 오거나이저, 서포터들과의 사진<br />
</em>
</div>
<p></div>The post <a href="https://techblog.woowahan.com/24940/">Delivering the Future: 글로벌 해커톤 2025, 준비부터 운영까지</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></content:encoded>

					<wfw:commentRss>https://techblog.woowahan.com/24940/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>


			</item>
		<item>
		<title>배달의민족 주문접수 채널에 Flutter를 도입하며 고민한 것</title>
		<link>https://techblog.woowahan.com/24337/</link>
					<comments>https://techblog.woowahan.com/24337/#respond</comments>

		<dc:creator><![CDATA[정다운]]></dc:creator>
		<pubDate>Tue, 16 Dec 2025 02:22:34 +0000</pubDate>
				<category><![CDATA[Programming General]]></category>
		<guid isPermaLink="false">https://techblog.woowa.in/?p=24337</guid>

					<description><![CDATA[<p>들어가며 배달의민족 주문접수 채널은 파트너의 주문 관리를 돕기 위해 매일 수백만 건의 주문을 실시간으로 처리하며, 다양한 디바이스를 지원하고 있습니다. 점차 다양해지는 디바이스 생태계에 대응하고자, 신규 제품에 Flutter + Clean Architecture를 선택했고, 나아가 비즈니스 요구사항에 더 빠르게 대응하기 위해 웹뷰 기반 컨테이너 앱(App Shell)으로 전환까지 진행 중입니다. 이 글에서는 Flutter 도입 과정과 아키텍처 설계 경험을 공유합니다. [&#8230;]</p>
The post <a href="https://techblog.woowahan.com/24337/">배달의민족 주문접수 채널에 Flutter를 도입하며 고민한 것</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></description>
										<content:encoded><![CDATA[<h2>들어가며</h2>
<p><strong>배달의민족 주문접수 채널</strong>은 파트너의 주문 관리를 돕기 위해 매일 수백만 건의 주문을 실시간으로 처리하며, 다양한 디바이스를 지원하고 있습니다.<br />
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/배달의민족_주문접수.png" alt="" /></p>
<p>점차 다양해지는 디바이스 생태계에 대응하고자, 신규 제품에 <strong>Flutter + Clean Architecture</strong>를 선택했고, 나아가 비즈니스 요구사항에 더 빠르게 대응하기 위해 <strong>웹뷰 기반 컨테이너 앱(App Shell)</strong>으로 전환까지 진행 중입니다.</p>
<p>이 글에서는 Flutter 도입 과정과 아키텍처 설계 경험을 공유합니다.</p>
<hr />
<h2>1. 왜 Flutter였나?</h2>
<h3>비즈니스 관점의 멀티 플랫폼</h3>
<p><strong>늘어나는 플랫폼 요구사항</strong></p>
<p>최근까지 Windows, Android 모바일, iOS 세 가지 플랫폼을 지원하고 있었지만, 다양한 디바이스에서 주문을 관리하고 싶다는 파트너 요구가 커져 플랫폼 확장이 필요했습니다.</p>
<ul>
<li><strong>macOS 데스크톱</strong>: Mac 디바이스로 주문을 관리하고 싶은 요청 증가</li>
<li><strong>Android 태블릿/POS</strong>: Windows POS에서 Android 기반 디바이스로 전환 추세</li>
<li><strong>향후 확장성</strong>: 신규 디바이스 지원 및 접수 채널 통합 대비</li>
</ul>
<p><strong>개발 생산성과 비용</strong></p>
<p>기존에는 Windows, Android 모바일, iOS 각 플랫폼별로 주문접수 채널을 개발해야 했고, 하나의 기능을 추가하려면 각 플랫폼에 맞춰 반복 구현해야 했습니다.</p>
<p>현재는 Android 태블릿/POS와 macOS 버전을 Flutter로 운영 중이며, Windows와 모바일 플랫폼(Android 모바일, iOS)은 점진적으로 전환하고 있습니다.</p>
<p>Flutter 도입으로 현재까지 확인된 효과는 다음과 같습니다.</p>
<ul>
<li><strong>인력 절감</strong>: Android와 macOS 각각 별도의 개발자가 필요했지만, Flutter 개발자가 두 플랫폼을 담당합니다.</li>
<li><strong>개발 속도 향상</strong>: 한 번의 구현으로 멀티 플랫폼에 동시 배포할 수 있게 되었습니다.</li>
</ul>
<p><strong>유지보수 효율성</strong></p>
<p>버그 수정이나 기능 변경 시에도 한 번의 수정으로 모든 플랫폼에 반영됩니다. 플랫폼 간 동기화 이슈가 줄어들고, 동일한 기능과 UX를 제공할 수 있습니다.</p>
<p><strong>일관된 사용자 경험</strong></p>
<p>파트너님들에게 동일한 UX를 제공할 수 있습니다. 이는 학습 비용을 줄이고, OS별 다른 UI로 인한 혼란을 줄일 수 있습니다.</p>
<p><strong>저희의 선택</strong></p>
<p>장기적으로 Windows, Android, iOS, macOS 4개 플랫폼을 모두 지원해야 하는 상황에서 생산성을 확보하려면 단일 코드베이스가 필수적이었습니다. 이 조건을 만족하면서 성숙한 생태계를 갖춘 프레임워크는 Flutter가 유일했고, 저희에게 적합한 선택이었습니다.</p>
<h3>Flutter의 한계와 해결: &quot;Write Once, Adapt Everywhere&quot;</h3>
<p><strong>플랫폼 차이의 현실</strong></p>
<p>처음에는 코드 하나로 모든 플랫폼을 동일하게 지원할 수 있을 것이라, 즉, &quot;Write Once, Run Everywhere&quot;를 기대했지만, 실제로는 플랫폼마다 주변기기 제어, 권한 시스템, 알림 방식, 업데이트 등 메커니즘이 다른 부분들이 존재합니다. 저희 경험상 &quot;Write Once, Adapt Everywhere&quot;에 가깝다고 느꼈습니다.</p>
<p>예를 들어 앱 업데이트 하나를 구현하더라도 각 플랫폼마다 다른 방식이 필요했습니다.</p>
<ul>
<li><strong>Android</strong>: Google Play In-App Update API</li>
<li><strong>macOS</strong>: Sparkle 프레임워크 + 자체 Feed URL 서버</li>
</ul>
<p>각 플랫폼의 업데이트 방식이 완전히 다르지만, 비즈니스 로직에서는 &quot;업데이트 확인 및 실행&quot;이라는 하나의 인터페이스로 통일할 수 있었습니다.</p>
<p><strong>해결 방법</strong></p>
<p>공통 인터페이스를 정의하고 플랫폼별 구현을 분리했습니다. Clean Architecture의 계층 분리 덕분에 플랫폼 의존성을 격리하고 비즈니스 로직을 독립적으로 유지할 수 있었습니다.</p>
<pre><code class="language-dart">// 1. 공통 인터페이스 정의
abstract class AppUpdateManager {
  Future&lt;UpdateResult&gt; checkForUpdates({bool inBackground = false});
}

// 2. Android 구현 - Google Play In-App Update
class AndroidAppUpdateManager implements AppUpdateManager {
  @override
  Future&lt;UpdateResult&gt; checkForUpdates({bool inBackground = false}) async {
    final updateInfo = await InAppUpdate.checkForUpdate();
    if (updateInfo.updateAvailability == UpdateAvailability.updateAvailable) {
      if (updateInfo.immediateUpdateAllowed &amp;&amp; !inBackground) {
        await InAppUpdate.performImmediateUpdate();
      }
      return UpdateResult.updateRequired();
    }
    return UpdateResult.noUpdateRequired();
  }
}

// 3. macOS 구현 - Sparkle Framework
class MacOsAppUpdateManager implements AppUpdateManager {
  @override
  Future&lt;UpdateResult&gt; checkForUpdates({bool inBackground = false}) async {
    autoUpdater.checkForUpdates(inBackground: inBackground);
    return UpdateResult.noUpdateRequired();
  }
}

// 4. 런타임 주입
if (Platform.isAndroid) {
  diContainer.registerSingleton&lt;AppUpdateManager&gt;(
    AndroidAppUpdateManager()
  );
} else if (Platform.isMacOS) {
  diContainer.registerSingleton&lt;AppUpdateManager&gt;(
    MacOsAppUpdateManager()
  );
}</code></pre>
<p><strong>비즈니스 로직은 플랫폼 독립적</strong></p>
<pre><code class="language-dart">final updateManager = diContainer&lt;AppUpdateManager&gt;();

final result = await updateManager.checkForUpdates();
if (result.result == UpdateResultType.updateRequired) {
  showUpdateDialog();
}</code></pre>
<h3>실용주의적 추상화: 변경 지점에만</h3>
<p><strong>추상화의 비용</strong></p>
<p>모든 것을 추상화하면 인터페이스 파일과 구현체 파일들로 코드량이 증가하고 간단한 로직도 여러 파일을 오가며 추적해야 합니다. 저희는 <strong>&quot;변경 지점에만 추상화한다.&quot;</strong>는 원칙을 따랐습니다.</p>
<p><strong>추상화 기준</strong><br />
다음 조건 중 하나라도 해당하면 추상화했습니다.</p>
<ol>
<li>플랫폼별로 구현이 다른 경우</li>
<li>외부 라이브러리에 의존하며 교체 가능성이 있는 경우</li>
<li>테스트를 위해 Mock이 필요한 경우</li>
</ol>
<p><strong>추상화한 것(예시)</strong></p>
<ul>
<li>AppPermissionManager: 플랫폼별 권한 차이</li>
<li>AppTerminator: 플랫폼별 종료 차이</li>
<li>AppUpdateManager: 플랫폼별 업데이트 차이</li>
<li>LocalNotification: 플랫폼별 알림 차이</li>
<li>ApiClient: 테스트 Mock 필요, 외부 의존성 격리</li>
<li>LocalStorageManager: 라이브러리 교체 가능성</li>
</ul>
<p><strong>추상화하지 않은 것</strong></p>
<ul>
<li>Flutter Widget: 이미 플랫폼 독립적</li>
<li>Mapper: 변환 함수</li>
<li>대부분의 유틸리티 함수</li>
</ul>
<p><strong>사례: 실시간 통신 라이브러리 전환</strong></p>
<p>최근 실시간 메시지 수신 방식을 MQTT에서 SSE(Server-Sent Events)로 변경했습니다. <code>ServerEventReceiver</code> 인터페이스로 추상화해두었기 때문에 아래와 같이 효율적으로 전환할 수 있었습니다.</p>
<ul>
<li>구현체만 교체(MqttEventReceiver → SseEventReceiver)</li>
<li>비즈니스 로직은 변경 없음</li>
<li>전환 작업 시간 최소화</li>
</ul>
<p>추상화가 없었다면 MQTT 코드가 전체 코드베이스에 퍼져있어 대규모 수정이 필요했을 것입니다.</p>
<hr />
<h2>2. 아키텍처 선택: Clean Architecture + BLoC</h2>
<blockquote>
<p><strong>Clean Architecture란?</strong><br />
Robert C. Martin이 제안한 소프트웨어 설계 원칙으로, 관심사를 계층별로 분리하여 비즈니스 로직을 UI, 프레임워크, 외부 의존성으로부터 독립시키는 아키텍처입니다.<br />
<a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture 자세히 보기</a></p>
</blockquote>
<h3>왜 Clean Architecture인가?</h3>
<p>Flutter 프로젝트에서는 주로 BLoC 패턴이나 MVVM + Provider를 사용합니다. 하지만 저희는 플랫폼 확장과 큰 변경을 대비해 계층 분리가 명확한 Clean Architecture + BLoC을 선택했습니다.</p>
<p><strong>Clean Architecture를 선택한 이유</strong></p>
<ul>
<li>계층 분리로 충분한 관심사 분리</li>
<li>UI 프레임워크 교체 가능성 확보</li>
<li>인터페이스 기반 계층 분리로 테스트 가능성과 플랫폼 독립성 확보</li>
<li>팀의 학습 곡선이 완만함</li>
</ul>
<p><strong>프로젝트 구조</strong><br />
Feature 단위로 모듈을 분리하고, 각 Feature 내부는 Data, Domain, Presentation 계층으로 구성했습니다. 추가로 Infrastructure 계층에서 순수 기술 구현(프린터, 오디오, 실시간 통신 등)을 제공합니다.</p>
<pre><code>lib/
  ├── core/                         # 공통 기능
  │   ├── infrastructure/           # 공통 기술적 구현
  │   └── domain/                   # 공통 도메인
  ├── features/                     # Feature 기반 모듈
  │   └── [feature]/
  │       ├── data/                 # Repository Impl, DataSource, DTO
  │       ├── domain/               # Entity, UseCase, Repository Interface
  │       ├── infrastructure/       # 기술적 구현
  │       └── presentation/         # BLoC, UI
  └── di_container.dart             # 의존성 주입</code></pre>
<h3>BLoC 선택: 명시적 상태 관리의 중요성</h3>
<blockquote>
<p><strong>BLoC(Business Logic Component)란?</strong><br />
Flutter에서 UI와 비즈니스 로직을 분리하기 위한 상태 관리 패턴입니다. Event를 입력받아 State를 출력하는 스트림 기반 아키텍처로, 명시적인 상태 변화 추적이 가능합니다.<br />
<a href="https://bloclibrary.dev/">BLoC 공식 문서</a></p>
</blockquote>
<p><strong>&quot;보일러플레이트가 많아도 유지보수성이 더 중요하다.&quot;</strong></p>
<p>Flutter에는 Provider, Riverpod, GetX, BLoC 등 다양한 상태 관리 라이브러리가 있습니다. 저희는 명시적인 이벤트 로깅과 상태 추적이 가능한 BLoC을 선택했습니다.</p>
<p><strong>1. 명확한 상태 추적</strong></p>
<pre><code class="language-dart">// BLoC: 모든 상태 변경이 Event로 기록됨
class OrderListBloc extends Bloc&lt;OrderListEvent, OrderListState&gt; {
  OrderListBloc() : super(InitializedOrderListState()) {
    on&lt;InitializeListEvent&gt;(_onInitialize);
    on&lt;LoadOrdersEvent&gt;(_onLoadOrders);
    on&lt;SelectOrderEvent&gt;(_onSelectOrder);
  }

  Future&lt;void&gt; _onLoadOrders(...) async {
    emit(LoadingOrderListState());
    // UseCase 호출
    emit(LoadedOrderListState(orders: orders));
  }
}

// 사용 - 의도가 명확
orderListBloc.add(LoadOrdersEvent());</code></pre>
<p>디버깅 시 로그만 봐도 전체 흐름을 파악할 수 있습니다.</p>
<pre><code>[LOG] InitializeListEvent
[LOG] LoadingOrderListState
[LOG] LoadOrdersEvent
[LOG] LoadedOrderListState(10 orders)</code></pre>
<p><strong>2. 버그 디버깅 시간 단축</strong></p>
<p><strong>예시</strong>: &quot;주문 목록이 업데이트되지 않는 버그&quot;</p>
<p>BLoC을 사용하면 이벤트 로그만 확인하면 됩니다.</p>
<pre><code>[LOG] 22:10:04 - OrderSyncReceivedEvent(서버 → 새 주문 알림)
// LoadOrdersEvent 로그가 없음!

→ 문제 발견: OrderSyncReceivedEvent 핸들러에서 LoadOrdersEvent 호출이 누락됨</code></pre>
<p>BLoC의 명시적인 이벤트 로깅이 없었다면 디버깅에 더 많은 시간이 소요되었을 것입니다.</p>
<p><strong>3. 화면 단위 BLoC: 단일 책임 원칙</strong></p>
<p>주문 화면에는 7개의 BLoC이 사용됩니다.<br />
주문 화면은 실시간 주문 관리, 액션 처리, 매출 분석 등 복잡한 기능이 집중된 핵심화면입니다. 7개의 BLoC을 사용하여 각 기능을 명확히 분리했고 각 BLoC이 300줄을 넘지 않도록 관리하고 있습니다.</p>
<pre><code class="language-dart">OrderScreen
  ├─ OrderScreenBloc          # 화면 네비게이션
  ├─ OrderListBloc            # 주문 목록
  ├─ OrderDetailBloc          # 주문 상세
  ├─ OrderActionBloc          # 주문 액션(접수, 취소, 완료 등)
  ├─ SalesOrderReportBloc     # 매출 조회
  ├─ BannerBloc               # 배너
  └─ SelfServiceBloc          # 셀프 서비스</code></pre>
<p><strong>코드량보다 유지보수성을 선택한 이유</strong></p>
<p>솔직히 말하면, BLoC은 코드가 많습니다.(Event 파일 + State 파일 + BLoC 파일) 하지만 이러한 구조 덕분에 상태 변화 흐름이 명확해지고, 대규모 프로젝트에서도 유지보수성을 유지할 수 있었습니다.</p>
<ul>
<li><strong>버그 디버깅</strong>: 이벤트 로그 추적으로 빠른 원인 파악</li>
<li><strong>신규 기능</strong>: Event/State/Handler 패턴 반복</li>
<li><strong>팀 온보딩</strong>: 일관된 구조로 학습 곡선 완만</li>
<li><strong>코드 리뷰</strong>: 명확한 기준(역할 분리)</li>
</ul>
<h3>BLoC의 올바른 역할: Presenter</h3>
<p><strong>&quot;BLoC = Business Logic Component&quot;의 함정</strong></p>
<p>BLoC은 &quot;Business Logic Component&quot;의 약자입니다. 이름 때문에 모든 비즈니스 로직을 BLoC에 넣어야 한다고 생각하기 쉽습니다. 하지만 저희는 BLoC을 <strong>Presenter</strong>로 정의했습니다. Presentation Logic만 처리하고, 핵심 비즈니스 로직은 Domain 계층의 UseCase에 분리했습니다.</p>
<p><strong>왜 분리했나요?</strong></p>
<ul>
<li><strong>테스트 용이성</strong>: UseCase는 Flutter 의존성 없이 순수 Dart로 테스트 가능</li>
<li><strong>재사용성</strong>: 같은 UseCase를 다른 화면, 다른 BLoC에서 재사용</li>
<li><strong>책임 명확화</strong>: BLoC은 &quot;어떻게 보여줄까&quot;, UseCase는 &quot;무엇을 할까&quot;</li>
</ul>
<p><strong>역할 정의</strong></p>
<pre><code>Presentation 계층(BLoC) ← Presenter 역할
  - UI State 관리
  - Event → State 변환
  - UseCase 호출
  - Presentation Logic
        ↓
Domain 계층(UseCase) ← 비즈니스 로직은 여기!
  - 비즈니스 로직 실행(주문 조회/접수/취소/완료 등)</code></pre>
<p><strong>예시</strong></p>
<pre><code class="language-dart">class OrderActionBloc extends Bloc&lt;OrderActionEvent, OrderActionState&gt; {
  final AcceptOrderUseCase acceptOrderUseCase;

  Future&lt;void&gt; _onAcceptOrder(...) async {
    // 1. Presentation Logic: UI 상태 변경
    emit(ProcessingOrderActionState(orderId: event.orderId));

    // 2. Presentation Logic: 사용자 액션 로깅
    logClick(group: &#039;ActiveOrd&#039;, event: &#039;Accept&#039;);

    // 3. UseCase 호출 (비즈니스 로직은 UseCase가 실행)
    final result = await acceptOrderUseCase.call(params);

    // 4. Presentation Logic: 결과를 State로 변환
    result.fold(
      (failure) =&gt; emit(FailureOrderActionState(...)),
      (success) =&gt; emit(SuccessOrderActionState(...)),
    );
  }
}</code></pre>
<h3>계층별 데이터 모델: DTO → Entity → UI State</h3>
<p>저희는 프론트엔드에도 Domain 계층을 뒀습니다. <strong>타입 안정성, 플랫폼 독립성, 변경의 격리, 클라이언트 비즈니스 로직 관리</strong> 측면에서 이점이 있다고 판단했습니다.</p>
<p>데이터는 세 단계를 거쳐 변환됩니다.</p>
<ul>
<li><strong>DTO (Data Transfer Object)</strong>: 서버 응답 그대로 매핑. nullable하고 원시 타입(String, int, bool 등) 기반입니다.</li>
<li><strong>Entity</strong>: 비즈니스 도메인 개념으로 변환. 타입 안전성과 불변성을 보장하고 Flutter에 의존하지 않는 순수 Dart 객체입니다.</li>
<li><strong>UI State</strong>: UI 표현에 필요한 정보로 변환. 화면에 표시할 텍스트, 색상, 버튼 상태 등 화면 렌더링에 특화된 데이터입니다.</li>
</ul>
<p>각 계층은 명확히 분리된 책임을 가지며, 서버 변경은 Data 계층에서, UI 변경은 Presentation 계층에서만 처리됩니다.</p>
<p><strong>데이터 변환 흐름</strong><br />
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/데이터변환흐름-1.png" alt="" /></p>
<p><strong>예시</strong></p>
<pre><code class="language-dart">// 1. DTO: 서버 응답
class OrderResponseData {
  String? orderId;
  String? orderStatus;
  String? time;
}

// 2. Entity: 도메인 개념
class OrderDetails {
  final OrderId id;
  final OrderStatus status;
  final DateTime orderTime;
}

// 3. UI State: UI 표현에 특화된 정보
class OrderDetailUiState {
  final String title;               // &quot;배민배달 J2Y2&quot;
  final Color statusColor;          // Colors.orange
  final ButtonUiState acceptButton;
  final TimerInfoUiState timer;
}</code></pre>
<p><strong>장점</strong></p>
<ol>
<li><strong>타입 안정성</strong>: nullable 지옥 탈출, Enum으로 타입 안전</li>
<li><strong>플랫폼 독립성</strong>: Entity는 Flutter에 의존하지 않는 순수 Dart(테스트 시 유리)</li>
<li><strong>변경의 격리</strong>: 서버 API 변경 시 Mapper만 수정, 나머지 계층 불변</li>
<li><strong>비즈니스 로직 캡슐화</strong>: 클라이언트에서 처리해야만 하는 비즈니스 로직을 Domain에서 관리</li>
<li><strong>UI 로직 분리</strong>: isVisible, ButtonStatus 같은 UI 로직이 Entity에 없음</li>
</ol>
<hr />
<h2>3. 아키텍처의 진가: 웹뷰 컨테이너 앱으로의 전환</h2>
<h3>웹뷰 기반 앱으로 전환 배경</h3>
<p>현재는 macOS와 Android 태블릿/POS 버전만 Flutter로 운영하고 있습니다. Windows, iOS까지 전면 전환을 계획하면서 배포 속도 문제를 고민하게 되었습니다.</p>
<p>주문접수 채널은 실시간성이 중요한 서비스입니다. 긴급 버그 수정이 필요할 때 네이티브 앱은 특정 플랫폼에서 빌드, 심사, 배포까지 며칠이 소요될 수 있어, 플랫폼이 늘어나면 이 시간 동안의 비즈니스 영향도 커집니다.</p>
<p><strong>웹뷰 기반 아키텍처의 장점</strong></p>
<ul>
<li>앱 심사 없이 즉시 배포 가능</li>
<li>모든 플랫폼에 동시 반영</li>
<li>긴급 버그 수정 시간 단축</li>
</ul>
<h3>결정: 비즈니스 로직을 웹으로</h3>
<p>고민 끝에 웹뷰 기반 컨테이너 앱으로 전환하기로 결정했습니다. 이를 통해 얻을 수 있는 주요 이점은 다음과 같습니다.</p>
<ul>
<li>긴급 버그 → 즉시 수정 → 즉시 배포</li>
<li>주문 손실 최소화</li>
<li>플랫폼 수와 무관하게 동일한 배포 속도</li>
</ul>
<p>비즈니스 로직을 웹으로 이관하는 대규모 전환 프로젝트를 진행 중입니다.</p>
<h3>전환 내용</h3>
<p>비즈니스 로직(Domain, Data)은 웹으로 이동하고, Presentation 계층은 WebView + Bridge로 새롭게 구현했습니다. Infrastructure 계층(프린터, 권한, 알림 등)은 그대로 재사용합니다.</p>
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/구조전환.png" alt="" /></p>
<h3>Infrastructure 계층 100% 재사용</h3>
<p>모든 비즈니스 로직이 웹으로 이동했지만, <strong>웹뷰가 처리하기 어려운 네이티브 기능</strong>들은 그대로 활용할 수 있었습니다.</p>
<ul>
<li><strong>AppPermissionManager</strong>: 권한 제어</li>
<li><strong>PrinterOutputService</strong>: 영수증 출력 제어</li>
<li><strong>LocalNotificationService</strong>: 로컬 푸시 알림</li>
<li><strong>LocalStorageManager</strong>: 데이터 저장</li>
<li>기타</li>
</ul>
<p><strong>웹뷰 브리지 구현 예시</strong></p>
<pre><code class="language-dart">class WebViewBridge {
  final AppPermissionManager permissionManager;     // 기존 인프라 재사용
  final PrinterOutputService printerOutputService;  // 기존 인프라 재사용

  // 웹에서 네이티브 기능 호출
  Future&lt;void&gt; handleWebRequest(String method, String params) async {
    switch (method) {
      case &#039;requestPermission&#039;:
        return await permissionManager.requestPermissionsFor(params);
      case &#039;printReceipt&#039;:
        return await printerOutputService.print(params);
      // ...
    }
  }
}</code></pre>
<h3>전환 과정에서 확인한 것</h3>
<p><strong>아키텍처의 장점</strong></p>
<p>개발 과정에서 확인한 주요 효과는 다음과 같습니다.</p>
<ul>
<li>Infrastructure 계층을 그대로 재사용(주변기기 제어, 권한, 알림 등)</li>
<li>WebView 브리지 구현만으로 네이티브 기능 연동 완료</li>
<li>신규 플랫폼 추가 시 네이티브 컨테이너만 개발하면 됨</li>
</ul>
<p><strong>변경 범위</strong></p>
<ul>
<li>Presentation 계층: 100% 교체(Native UI → WebView)</li>
<li>Domain/Data 계층: 100% 제거(웹으로 이동)</li>
<li>Infrastructure 계층: <strong>0% 변경</strong>(그대로 재사용)</li>
</ul>
<p>계층 분리 덕분에 Infrastructure는 그대로 재사용하고 WebView 브리지만 구현했습니다. 변경 범위를 최소화할 수 있었고, 이것이 Clean Architecture를 선택한 이유 중 하나입니다.</p>
<hr />
<h2>4. 유지보수하기 쉬운 코드 만들기</h2>
<h3>계층별 네이밍 전략: &quot;이름을 보면 계층이 보인다.&quot;</h3>
<p><strong>&quot;이름으로 계층과 역할을 구분할 수 있어야 합니다.&quot;</strong><br />
각 계층은 자신만의 책임을 수행합니다. 저희는 클래스명과 메서드명에 일관된 규칙을 적용하여, 코드를 읽는 사람이 즉시 &quot;어느 계층의 어떤 역할&quot;인지 파악할 수 있도록 했습니다.</p>
<p>예를 들어</p>
<ul>
<li><code>GetOrderListUseCase</code> → Domain 계층</li>
<li><code>fetchOrderList()</code>, <code>OrderListResponseDto</code> → Data 계층</li>
<li><code>OrderListBloc</code>, <code>LoadOrdersEvent</code> → Presentation 계층</li>
</ul>
<p>특히 같은 이름이 여러 계층에 반복되면 각 메서드의 역할이 불명확해집니다. 저희는 계층 간 이름 중복을 지양하며, 불가피하게 같은 이름을 쓸 때는 <strong>반환 타입</strong>으로 구분하거나 <strong>검색 시 의미 파악</strong>이 가능하도록 네이밍했습니다.</p>
<p><strong>계층별 네이밍 규칙</strong></p>
<table>
<thead>
<tr>
<th>계층</th>
<th>타입</th>
<th>클래스명 규칙</th>
<th>메서드명 규칙</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr>
<td>Domain</td>
<td>Entity</td>
<td>{Domain}</td>
<td>&#8211;</td>
<td>OrderDetails, OrderList</td>
</tr>
<tr>
<td>Domain</td>
<td>UseCase</td>
<td>{Action}UseCase</td>
<td>call</td>
<td>GetOrderListUseCase.call</td>
</tr>
<tr>
<td>Data</td>
<td>Repository</td>
<td>{Domain}Repository</td>
<td>Query: fetch{Data}<br />Command: {동사}{대상}</td>
<td>fetchOrderList<br />acceptOrder</td>
</tr>
<tr>
<td>Data</td>
<td>DTO</td>
<td>{Data}ResponseDto</td>
<td>&#8211;</td>
<td>OrderListResponseDto</td>
</tr>
<tr>
<td>Presentation</td>
<td>BLoC</td>
<td>{Feature}Bloc</td>
<td>&#8211;</td>
<td>OrderListBloc</td>
</tr>
<tr>
<td>Presentation</td>
<td>Event</td>
<td>{Action}Event</td>
<td>&#8211;</td>
<td>LoadOrdersEvent</td>
</tr>
<tr>
<td>Presentation</td>
<td>State</td>
<td>{Status}{Feature}State</td>
<td>&#8211;</td>
<td>LoadingOrderListState</td>
</tr>
<tr>
<td>Presentation</td>
<td>UI State</td>
<td>{Feature}UiState</td>
<td>&#8211;</td>
<td>OrderDetailUiState</td>
</tr>
</tbody>
</table>
<p><strong>예시: 주문 상세 조회</strong></p>
<pre><code class="language-dart">// 1. UI에서 Event 발행(사용자 액션)
orderDetailBloc.add(LoadOrderDetailsEvent(orderId));

// 2. BLoC: Event 처리
Future&lt;void&gt; _onLoadOrderDetails(LoadOrderDetailsEvent event, ...) async {
  // 3. UseCase 호출
  final result = await getOrderDetailsUseCase.call(
    GetOrderDetailsParams(orderId: event.orderId)
  );
  // → UseCase 내부에서는 orderQueryRepository.fetchOrderDetailsById 호출
  // → DTO(OrderDetailsResponseDto) 파싱 후 Entity(OrderDetails)로 변환

  // 4. BLoC: 결과를 UI State로 변환 후 emit
  result.fold(
    (failure) =&gt; emit(OrderDetailsLoadFailedState(failure.message)),
    (orderDetails) {
      final uiState = OrderDetailsUiState.fromDomain(orderDetails);
      emit(OrderDetailsLoadedState(uiState));
    },
  );
}</code></pre>
<p><strong>이 네이밍 규칙의 장점</strong></p>
<ul>
<li><strong>코드만 봐도 위치와 컨텍스트 파악</strong>
<ul>
<li><code>fetchOrderList()</code> → Data 계층의 Repository 메서드</li>
<li><code>GetOrderListUseCase</code> → Domain 계층의 UseCase</li>
<li><code>OrderListBloc</code> → Presentation 계층의 BLoC</li>
<li>클래스명과 메서드명만으로 어디에 있는지 즉시 알 수 있습니다.</li>
</ul>
</li>
<li><strong>검색과 리팩토링 효율</strong>
<ul>
<li>IDE에서 &quot;fetchOrderList&quot; 검색 → Repository만 검색됨</li>
<li>&quot;LoadOrdersEvent&quot; 검색 → Event 클래스 1개만 나옴</li>
<li>이름이 겹치지 않아 안전하게 rename 가능</li>
</ul>
</li>
<li><strong>온보딩 시간 단축</strong>
<ul>
<li>새로운 개발자가 일관된 패턴을 빠르게 학습</li>
<li>&quot;Bloc&quot;, &quot;Event&quot;, &quot;UseCase&quot;, &quot;fetch&quot; 등 접미사, 접두사만 보고도 역할 파악</li>
<li>코드 컨벤션 문서 없이도 코드만 보고 이해 가능</li>
</ul>
</li>
<li><strong>도메인 표현력</strong>
<ul>
<li><code>acceptOrder</code>, <code>completeOrder</code> 같은 도메인 액션을 직접 사용</li>
<li>비즈니스 의도가 코드에 명확히 드러납니다.</li>
</ul>
</li>
</ul>
<h3>타입 안전한 에러 핸들링: Either</h3>
<p>전통적인 예외 처리는 컴파일 타임에 강제되지 않아, try-catch를 빠뜨리면 런타임 에러가 발생할 수 있습니다.</p>
<p>저희는 에러를 타입 시스템 안에서 명시적으로 표현하는 <code>Either</code> 타입을 사용했습니다. 이는 함수형 프로그래밍에서 나온 개념이지만, 실용적인 장점 때문에 도입했습니다.</p>
<p><strong>예시</strong></p>
<pre><code class="language-dart">// 반환 타입만 봐도 실패 가능성을 알 수 있음
Future&lt;Either&lt;Failure, OrderList&gt;&gt; fetchOrderList() async {
  try {
    final response = await apiClient.get(&#039;/api/orders&#039;);
    final dto = OrderListResponseDto.fromJson(response.data);
    final orderList = OrderListMapper.toDomain(dto.data);

    if (orderList.isEmpty) return Left(NoDataFailure());

    return Right(orderList);
  } catch (e) {
    return Left(ServerFailure());
  }
}

final result = await repository.fetchOrderList();
result.fold(
  (failure) {
    switch (failure) {
      case NetworkFailure():
      case ConnectionFailure():
        showNetworkError(&#039;네트워크를 확인해주세요&#039;);
      case ServerFailureExpiredToken():
        redirectToLogin();
      case NoDataFailure():
        showNoDataMessage(&#039;주문 데이터가 없습니다&#039;);
      default:
        showError(failure.message);
    }
  },
  (orders) =&gt; displayOrders(orders),
);</code></pre>
<p><strong>장점</strong></p>
<ol>
<li><strong>실패 가능성이 타입에 드러남</strong>: <code>Either</code>를 보면 이 함수가 실패할 수 있다는 것이 명확<br />
(vs try-catch는 함수 시그니처만 봐선 예외 발생 여부를 알 수 없음)</li>
<li><strong>에러 처리 강제</strong>: 기본적으로 사용되는 fold()는 성공/실패 양쪽을 모두 처리해야 값을 얻을 수 있음<br />
(vs try-catch는 감싸는 걸 깜빡하면 런타임 에러 발생 가능성)</li>
<li><strong>명시적 에러 전파</strong>: 어느 계층에서 어떤 에러가 발생했는지 추적하고 어떻게 처리할지가 명확해짐</li>
</ol>
<p><strong>Failure 타입 계층:</strong></p>
<pre><code class="language-dart">abstract class Failure {
  final String message;
  const Failure({this.message = &#039;&#039;});
}

class TimeOutFailure extends Failure {
  const TimeOutFailure({super.message = &#039;요청 시간이 만료되었습니다.&#039;});
}

// 서버 실패는 에러 코드 포함
class ServerFailure extends Failure {
  final String code;
  const ServerFailure({required this.code, required super.message});
}

// 추가 컨텍스트가 필요한 경우
class LoginFailure extends ServerFailure {
  final bool blocked;

  const LoginFailure({
    required super.code,
    super.message = &#039;로그인에 실패했습니다.&#039;,
    this.blocked = false,
  });
}</code></pre>
<p><strong>계층 구조의 이점</strong></p>
<ul>
<li>공통 속성은 상위 클래스에서 관리(message, code)</li>
<li>각 실패 타입은 필요한 추가 정보만 포함(blocked 등)</li>
<li>switch 문으로 타입별 분기 처리 가능</li>
</ul>
<p>네트워크 오류, 토큰 만료, 데이터 부재 등 다양한 실패 케이스를 명시적으로 처리하여, 상황에 맞는 안내 메시지를 제공할 수 있었습니다.</p>
<hr />
<h2>5. 성과와 교훈</h2>
<p>프로젝트로 얻은 주요 성과와 교훈을 정리하면 다음과 같습니다. </p>
<p><strong>1. 플랫폼 차이 대응</strong></p>
<blockquote>
<p>Flutter는 크로스플랫폼이지만, 플랫폼 차이는 존재합니다. 저희는 공통 인터페이스를 정의하고 플랫폼별 구현을 분리하여 해결했습니다.</p>
</blockquote>
<p><strong>2. 보일러플레이트 코드의 장단점</strong></p>
<blockquote>
<p>BLoC은 코드량이 증가하지만, 저희 경험상 유지보수 시간이 크게 단축되었습니다. 명시적 상태 관리가 장기적으로 유리하다고 느꼈습니다.</p>
</blockquote>
<p><strong>3. 필요한 곳에만 추상화</strong></p>
<blockquote>
<p>모든 것을 추상화하면 복잡도만 증가할 수 있습니다. 저희는 플랫폼별 구현이 다른 곳, 외부 의존성 격리, 테스트 Mock이 필요한 곳만 추상화했습니다.</p>
</blockquote>
<p><strong>4. 일관된 네이밍 컨벤션</strong></p>
<blockquote>
<p>메서드 이름만 봐도 어느 계층인지 알 수 있도록 일관된 네이밍 컨벤션을 유지했습니다.</p>
</blockquote>
<p><strong>5. BLoC의 역할</strong></p>
<blockquote>
<p>비즈니스 로직은 UseCase에, BLoC은 UI State 관리에 집중했습니다.</p>
</blockquote>
<h3>프로젝트를 돌아보며</h3>
<p>완벽한 아키텍처는 없다고 생각합니다. 프로젝트 특성에 맞게 적용하고, 팀이 행복하게 일할 수 있는 구조가 좋은 아키텍처라고 생각합니다.</p>
<p>Flutter와 Clean Architecture는 저희 팀에 잘 맞았지만, 여러분의 프로젝트에는 다른 해답이 있을 수 있습니다.</p>
<p>저희가 선택한 패턴들을 돌아보면, 이 글에서 다룬 패턴들(계층 분리, 네이밍 규칙, UI State, Either 등)은 모두 <strong>코드로 하는 소통</strong>입니다.</p>
<p>좋은 제품과 코드는 소통에서 나온다고 생각합니다. 코드뿐 아니라 팀원들과의 대화, AI 활용, 미래의 유지보수까지 고려하며 명확히 의도를 전달하는 것이 중요하다고 느꼈습니다.</p>
<hr />
<h2>마치며</h2>
<p>배달의민족 주문접수 채널에 Flutter를 도입했던 과정을 정리했습니다. 더 많은 고민과 시행착오가 있었지만, 핵심만 담아 공유했습니다.</p>
<p>이 글이 멀티 플랫폼 전략과 Flutter 아키텍처를 고민하는 분들께 조금이나마 도움이 되었으면 좋겠습니다.</p>The post <a href="https://techblog.woowahan.com/24337/">배달의민족 주문접수 채널에 Flutter를 도입하며 고민한 것</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></content:encoded>

					<wfw:commentRss>https://techblog.woowahan.com/24337/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>


			</item>
		<item>
		<title>&#8220;함께 구매하면 좋은 상품&#8221; 추천 모델 고도화</title>
		<link>https://techblog.woowahan.com/24434/</link>
					<comments>https://techblog.woowahan.com/24434/#respond</comments>

		<dc:creator><![CDATA[정은주]]></dc:creator>
		<pubDate>Thu, 11 Dec 2025 06:59:43 +0000</pubDate>
				<category><![CDATA[AI]]></category>
		<category><![CDATA[Deep Learning]]></category>
		<category><![CDATA[Machine Learning]]></category>
		<guid isPermaLink="false">https://techblog.woowa.in/?p=24434</guid>

					<description><![CDATA[<p>배달의민족에서는 음식 배달뿐만 아니라 장보기도 당일 배송이 가능하다는 사실, 알고 계셨나요? 배민의 장보기·쇼핑 서비스는 배민B마트를 비롯해 마트, 편의점, 꽃, 전자제품 등 다양한 셀러가 입점해 있어 다양한 물건을 빠르게 받아보실 수 있는데요. 고객이 서비스에 진입한 순간부터 구매를 완료하는 여정까지 최적의 상품을 발견할 수 있도록 개인화 추천, 함께 본 상품 추천, 실시간 트렌드 랭킹, 장바구니 추천, 결제 [&#8230;]</p>
The post <a href="https://techblog.woowahan.com/24434/">“함께 구매하면 좋은 상품” 추천 모델 고도화</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></description>
										<content:encoded><![CDATA[<p><strong>배달의민족</strong>에서는 음식 배달뿐만 아니라 <strong>장보기도 당일 배송이 가능하다는 사실, 알고 계셨나요?</strong> </p>
<p>배민의 <strong>장보기·쇼핑</strong> 서비스는 <strong>배민B마트</strong>를 비롯해 <strong>마트, 편의점, 꽃, 전자제품 등 다양한 셀러</strong>가 입점해 있어 다양한 물건을 빠르게 받아보실 수 있는데요. 고객이 서비스에 진입한 순간부터 구매를 완료하는 여정까지 최적의 상품을 발견할 수 있도록 <strong>개인화 추천, 함께 본 상품 추천, 실시간 트렌드 랭킹, 장바구니 추천, 결제 전 추가 상품 추천</strong> 등 다양한 추천을 제공하고 있습니다.<br />
</p>
<p><!-- TODO: 앱 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/11/%EB%8B%A4%EC%96%91%ED%95%9C-%EC%B6%94%EC%B2%9C-750x361.png" width="550" alt="추천"><br /><em style="color: #666;font-size: 13px;font-style: normal">그림 1. &#8220;장보기·쇼핑&#8221; 서비스의 다양한 추천</em>
</div>
</p>
<p>이번 글에서는 <strong>고객이 장바구니에 담은 상품들을 기반으로 연관 상품을 추천</strong>하는 장바구니 추천 모델의 개선 과정을 공유하고자 합니다. 추천 시스템과 기본적인 머신러닝 개념에 익숙한 분들을 대상으로 시행착오와 개선 과정을 공유하며, 단순한 임베딩 유사도를 넘어 유저가 장바구니에 <strong>담은 상품들의 맥락을 이해하여 함께 구매할 만한 상품 추천</strong>의 성능을 개선한 경험을 소개합니다.</p>
<p><!-- TODO: 장바구니 추천 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/11/%EC%9E%A5%EB%B0%94%EA%B5%AC%EB%8B%88-%EC%B6%94%EC%B2%9C-296x750.png" width="150" alt="장바구니 추천"><br /><em style="color: #666;font-size: 13px;font-style: normal">그림 2. 장바구니 추천</em>
</div>
</p>
<h1>기존 모델 소개 및 아쉬운 점</h1>
<p>초기 장바구니 추천 모델은 빠른 도입과 구현 편의성을 위해 주문 데이터 기반의 <code>Item2Vec</code> 방식을 채택했습니다. 고객의 주문 이력을 하나의 문장으로, 주문 내 상품들을 단어(Word)로 간주하여 Skip-gram 방식으로 학습했으며 현재 장바구니에 담긴 상품들과 <strong>임베딩 유사도</strong>를 기반으로 상품을 추천하는 구조였습니다.</p>
<p>하지만 추천 모델을 운영하면서 장바구니 추천의 목적과 상충되는 몇 가지 문제점을 발견하게 되었습니다.</p>
<h3>대체재 편향</h3>
<p><strong>Item2Vec</strong> 모델은 동일한 주문 내에서 함께 등장하는 상품들을 유사한 벡터 공간에 매핑합니다. 이는 유사한 구매 패턴을 갖는 상품들이 비슷한 임베딩을 갖게 되는 결과로 이어집니다.</p>
<p>예를 들어, 고객이 <code>우유</code>를 장바구니에 담았을 때를 살펴보겠습니다.</p>
<ul>
<li><strong>기대되는 추천</strong>: <code>시리얼</code>, <code>빵</code> 등 우유와 <strong>함께 구매</strong>되는 상품</li>
<li><strong>실제 추천</strong>: 다른 브랜드의 <code>우유</code> 상품군</li>
</ul>
<p>이는 여러 브랜드의 우유가 비슷한 주문 패턴(예: 시리얼, 빵 등과 함께 구매)을 가지기 때문에, 서로 유사한 임베딩을 갖게 되어 발생합니다. 유사한 상품군을 추천하는 것도 의미가 있을 수 있지만, <strong>임베딩 유사도에만 의존</strong>하면 추천 결과가 동일한 카테고리 내 대체재로 편중되어 <strong>추천 다양성이 크게 떨어지는</strong> 문제가 있습니다. 장바구니 추천으로 우리가 달성하려는 핵심 목표인 <strong>크로스 셀링</strong>을 위해서는 다양한 보완 상품군을 제안할 수 있어야 합니다.</p>
<h3>시퀀스 맥락 부재</h3>
<p>장바구니에 상품을 담는 순서에는 고객의 구매 의도가 담겨 있습니다. 하지만 Item2Vec은 주문 내 상품의 동시 출현만을 학습하므로 이러한 순서 정보를 반영하지 못합니다.</p>
<p>예를 들어 다음 두 고객의 장바구니를 살펴보겠습니다.</p>
<ul>
<li>고객 1: <code>[라면, 삼겹살, 상추]</code></li>
<li>고객 2: <code>[삼겹살, 상추, 라면]</code></li>
</ul>
<p>두 고객의 장바구니에는 <strong>동일한 상품들이 담겨 있지만 순서가 다릅니다.</strong> 1번 고객은 라면을 먼저 담았고 이후 고기와 채소를 추가했으므로 고기 요리에 필요한 <code>마늘</code>을 추천하는 것이 적합합니다. 반면 2번 고객은 고기와 채소를 먼저 담은 후 라면을 추가했으므로 라면과 어울리는 <code>김치</code>를 추천하는 것이 자연스럽습니다. 하지만 Item2Vec은 순서를 고려하지 못하기 때문에 이러한 맥락 차이를 구분하지 못하는 한계가 있었습니다.</p>
<p>이에 <strong>담은 상품의 시퀀스를 이해하고 자연스럽게 다음 상품으로 이어질 수 있는 추천</strong>을 목표로 모델 개선을 진행했습니다.</p>
</p>
<h1>구매 맥락을 고려한 추천 모델</h1>
<p><strong>&quot;어떤 맥락에서 상품들이 담겼는지&quot;</strong>를 이해하기 위해서는, <strong>상품 간의 관계</strong>뿐만 아니라 고객이 <strong>상품을 담는 순서</strong>까지 함께 고려해야 합니다. 이를 위해 <strong>2-stage 파이프라인</strong>을 구성하여, 첫 번째 단계에서 구매 패턴 기반으로 상품 및 카테고리 임베딩을 생성하고, 이후 시퀀스 기반 추천을 통해 맥락을 학습하는 방식으로 접근했습니다.</p>
<ul>
<li>
<p><strong>Stage 1. 그래프 기반 상품 &amp; 카테고리 임베딩</strong>: 주문 데이터를 바탕으로 <strong>함께 구매되는 패턴</strong>을 그래프로 구조화하고, <code>Node2Vec</code>을 통해 상품 및 카테고리의 임베딩 벡터를 생성합니다.</p>
</li>
<li>
<p><strong>Stage 2. 맥락 기반의 다음 상품 예측</strong>: Stage 1에서 생성된 상품 및 카테고리 임베딩을 입력으로 활용하여, <code>Transformer</code> 모델이 장바구니에 담긴 상품들의 맥락을 파악하고 다음에 담을 상품을 예측합니다.</p>
</li>
</ul>
<h2>Stage 1. 그래프 기반 상품, 카테고리 임베딩</h2>
<p>주문 데이터 특성상 롱테일(Long-tail) 상품의 경우 주문 빈도가 낮아 데이터 희소성 문제가 발생합니다. 이러한 환경에서도 견고한 추천 성능을 확보하기 위해 <code>Node2Vec</code>을 도입했습니다. <code>Node2Vec</code>은 실제 주문 데이터가 부족한 상황에서도 <strong>Random Walk</strong>를 통해 시퀀스를 생성할 수 있어, 상품 간의 구조적 연관성을 효과적으로 학습할 수 있습니다.</p>
<h3><strong>그래프 정의</strong></h3>
<p><!-- TODO: 그래프 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%EA%B7%B8%EB%9E%98%ED%94%84-%EC%98%88%EC%8B%9C-750x632.jpg" width="350" alt="그래프"><br /><em style="color: #666;font-size: 13px;font-style: normal">그림 3. 함께 구매 데이터 기반 그래프 예시</em>
</div>
<ul>
<li>
<p><strong>Node 타입</strong></p>
<ul>
<li><strong>상품 노드</strong>: 주문 데이터에 등장한 개별 상품을 나타내는 노드 (예: <code>삼겹살</code>, <code>쌈장</code>, <code>청상추</code>, <code>깐마늘</code>, <code>된장</code>)</li>
<li><strong>카테고리 노드</strong>: 상품이 속한 카테고리를 나타내는 노드 (예: <code>육류</code>, <code>채소</code>, <code>조미료</code>) </li>
</ul>
</li>
<li>
<p><strong>Edges &amp; Weights</strong></p>
<ul>
<li><strong>Item-Item</strong> (ㅡ): 상품 노드들 간의 연결을 나타냅니다. <strong>서로 강한 보완 관계</strong>를 가진 상품끼리 더 강하게 연결되도록, 상품 페어 간 주문 데이터 기반의 Association Rule을 활용하여 Edge Weight를 세팅했습니다. 단순 동시 구매 빈도가 아닌 <strong>상품 간 연관도</strong>를 기반으로 가중치를 부여하여, 인기 상품으로만 편중되는 것을 방지했습니다.</li>
<li><strong>Item-Category</strong> (- -): 각 상품 노드와 카테고리 노드 간의 연결입니다. 상품 노드가 주문 데이터를 기반으로 생성되므로, 신규 상품이나 주문이 없는 상품은 임베딩을 생성할 수 없는 문제가 있습니다. 이를 보완하기 위해 카테고리 노드를 추가하였고, 각 상품은 소속된 카테고리에 연결됩니다. <strong>상품 임베딩</strong>과 함께 생성된 <strong>카테고리 임베딩</strong>을 추후 Next Item Prediction 단계에서 학습 이력이 없는 상품의 초기 벡터로 활용하여 Cold Start 상품 문제를 완화했습니다.</li>
</ul>
</li>
</ul>
<h3><strong>시퀀스 생성 및 임베딩 학습</strong></h3>
<ul>
<li>
<p>구축된 그래프상에서 <strong>Weighted Random Walk</strong>를 수행하여 가상의 노드 시퀀스를 생성했습니다. Edge Weight를 고려한 Random Walk를 통해 보완 관계가 강한 상품들이 시퀀스 내에서 자주 등장하도록 하여, 상품 간의 구조적 연관성을 효과적으로 포착할 수 있습니다. </p>
</li>
<li>
<p>그래프에는 상품 노드와 카테고리 노드가 함께 존재하며, 각 상품은 소속된 카테고리와 연결되어 있습니다. Random Walk는 상품 간 연결뿐만 아니라 상품-카테고리 간 연결도 탐색하며, 이를 통해 상품 수준과 카테고리 수준의 정보가 모두 반영된 시퀀스가 생성됩니다. 예를 들어, 다음과 같은 가상 시퀀스가 생성됩니다.</p>
</li>
</ul>
<blockquote>
<p>[한돈 삼겹살 500g → &quot;육류&quot; → 무항생제 목살 500g → 유기농 상추 → 국내산 깐마늘 → &quot;채소&quot; → &#8230;]</p>
<p>[룸모 스파게티면 → &quot;스파게티/파스타면&quot; → 바릴라 링귀니면 → 국내산 깐마늘 → 무띠 토마토소스 → &quot;파스타소스&quot; → &#8230;]</p>
</blockquote>
<p>이렇게 생성된 시퀀스를 바탕으로 <code>Node2Vec</code>을 학습하여 각 상품과 카테고리의 임베딩 벡터를 생성했습니다. </p>
<p>최종적으로 생성된 임베딩은 구매 패턴의 연관성을 함축하고 있으며, Stage 2의 Transformer 모델의 초기 입력으로 활용됩니다.</p>
<p></p>
<h2>Stage 2. Transformer 기반 시퀀스 추천</h2>
<p>장바구니에 상품을 담는 과정을 하나의 시퀀스로 간주하고, &quot;지금까지 담은 상품들&quot;을 분석하여 다음에 고객이 담을 가능성이 가장 높은 상품을 예측합니다.</p>
<p><!-- TODO: 모델 아키텍처 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%EB%AA%A8%EB%8D%B8-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90-750x302.jpg" width="500" alt="추천"><br /><em style="color: #666;font-size: 13px;font-style: normal">그림 4. 모델 아키텍처</em>
</div>
<h3><strong>학습 데이터 구성</strong></h3>
<p>주문 데이터에서 장바구니에 담긴 상품의 순서를 활용하여 학습 데이터를 구성했습니다. 시퀀스 내 특정 시점 <strong>t</strong>의 상품을 예측 대상으로 설정하고, 그 이전 시점의 상품들을 입력으로 사용합니다.</p>
\[\text{Input: } [i_1, i_2, \dots, i_{t-1}] \rightarrow \text{Target: } i_t\]
<h3><strong>입력 임베딩</strong></h3>
<p>Transformer에 입력되는 각 상품은 Stage 1에서 학습된 <strong>상품 임베딩</strong>과 <strong>카테고리 임베딩</strong>을 결합한 후, <strong>위치 임베딩</strong>을 더하여 표현됩니다.</p>
\[h_i = [e_{\text{item}}(i) ; e_{\text{category}}(i)] + e_{\text{pos}}(i)\]
<p>상품 임베딩과 카테고리 임베딩을 결합하고 위치 정보를 더하여 각 상품의 특성, 카테고리, 그리고 담은 순서를 모두 반영할 수 있습니다. </p>
<p>특히 주문 이력이 부족한 <strong>Cold Start 상품</strong>의 경우, Node2Vec으로 상품 임베딩이 생성되기는 하지만 그래프 내 연결이 약하고 Random Walk에서 충분히 학습되지 못해 임베딩의 신뢰도가 낮을 수 있습니다. 하지만 <strong>카테고리 임베딩과 결합</strong>함으로써 이러한 약점을 보완할 수 있습니다. 예를 들어, 신규 출시된 <code>프리미엄 한우 등심</code>은 주문 데이터가 거의 없어 상품 임베딩만으로는 정확한 추천이 어렵지만, <code>육류</code> 카테고리 임베딩을 함께 활용하여 삼겹살, 소고기 등과 유사한 구매 맥락(채소, 양념 등)을 반영한 추천이 가능합니다.</p>
<h3><strong>Transformer 기반 맥락 학습</strong></h3>
<p>상품 담기 순서에 담긴 맥락을 학습하기 위해 <strong>Transformer Encoder</strong> 구조를 채택하였으며, 다음 두 가지 핵심 구성 요소로 이루어져 있습니다.</p>
<ul>
<li>
<p><strong>Masked Self-Attention</strong>: SASRec(Self-Attentive Sequential Recommendation)을 참고하여 Causal Masking을 적용했습니다. <strong>각 시점에서 이전 상품들만 참조</strong>하여 예측 타깃 정보가 유출되는 것을 방지합니다. Self-Attention 메커니즘을 통해 시퀀스 내 상품 간의 상호 연관성을 계산하여 동일한 상품이 마지막에 담겼더라도 <strong>이전 맥락에 따라 다른 추천 결과</strong>를 도출합니다.</p>
</li>
<li>
<p><strong>Feed Forward Network</strong>: Self-Attention 결과를 비선형 변환하여 더 풍부한 표현을 학습합니다.</p>
</li>
</ul>
<p>이러한 Transformer 구조를 통해 동일한 상품 조합이라도 담는 순서에 따라 서로 다른 추천이 가능합니다. <code>[라면, 삼겹살, 상추]</code>를 담은 고객에게는 고기 요리에 필요한 <code>마늘</code>을, <code>[삼겹살, 상추, 라면]</code>을 담은 고객에게는 라면과 어울리는 <code>김치</code>를 더 높은 가중치로 추천하도록 학습되어 <strong>구매 의도를 반영한 Context Vector</strong>를 생성합니다.</p>
<h3><strong>모델 학습 구성 및 Loss함수</strong></h3>
<ul>
<li><strong>Multi-Task Learning</strong>: Context Vector를 기반으로 다음에 올 <strong>상품과 해당 상품의 카테고리를 동시에 예측</strong>하도록 설계했습니다. 상품 수준의 구체적인 예측과 카테고리 수준의 일반적인 예측을 함께 학습함으로써, 특정 상품에 대한 과적합을 방지하고 더 일반화된 구매 패턴을 학습할 수 있습니다. 두 task의 loss는 Weighted Sum 방식으로 결합하여 최종 loss를 계산했습니다.</li>
<li><strong>Focal Loss</strong>: 주문 데이터에서 발생하는 인기 상품과 롱테일 상품 간의 심각한 클래스 불균형(Class Imbalance) 문제를 완화하기 위해 적용했습니다. Focal Loss는 모델이 높은 확신으로 예측하는 쉬운 샘플의 손실 가중치를 감소시키고, 낮은 확신으로 예측하는 어려운 샘플에 집중하도록 설계되어 있어, 자주 등장하지 않는 롱테일 상품에 대한 학습을 강화하고 모델의 일반화 성능을 향상시킵니다.<br />
</li>
</ul>
<h1>실험 결과 및 평가</h1>
<h2>예측 결과 비교</h2>
<p>동일한 장바구니 맥락에 대해 Item2Vec(AS-IS)과 개선 모델(TO-BE)이 어떤 추천을 제공하는지, <strong>실제 예시</strong>를 통해 살펴보겠습니다.  </p>
<p><!-- TODO: 예시 첨부 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%EC%B6%94%EC%B2%9C-%EA%B2%B0%EA%B3%BC-%EB%B9%84%EA%B5%90-1-750x415.png" width="500" alt="추천 결과 비교"><br /><em style="color: #666;font-size: 13px;font-style: normal">그림 5. 추천 모델 예측 결과 비교</em>
</div>
<p></p>
<p><strong>Item2Vec</strong>은 임베딩 유사도에 기반해 <strong>비슷한 카테고리의 상품</strong>을 추천하는 경향이 있는 반면, <strong>개선 모델</strong>은 장바구니에 담긴 상품들의 <strong>맥락을 고려하여 실제 함께 구매할 만한 보완 상품</strong>을 주로 제안합니다. </p>
<p>이러한 차이가 실제 지표 개선으로 이어졌는지 정량적으로 평가한 결과는 다음과 같습니다.</p>
<h2>오프라인 평가</h2>
<p>장바구니 추천을 제공하는 여러 셀러를 대상으로 기존 모델(Item2Vec) 대비 성능을 평가했습니다. 평가 데이터는 학습 기간 이후의 주문 내역을 사용하였으며, 장바구니에 담은 <strong>상품의 순서를 고려</strong>하여 <strong>주문 내 마지막 상품을 정답</strong>으로 설정했습니다. </p>
<ul>
<li><strong>Hit Rate@10</strong>: 모델 예측 상위 10개 상품 중 정답 상품 포함 비율</li>
<li><strong>Category Diversity</strong>: 추천된 상위 10개 상품의 서로 다른 카테고리 개수(평균)</li>
</ul>
<p>다음은 일부 셀러의 평가 결과입니다.</p>
<table>
<thead>
<tr>
<th style="text-align: center;">셀러 유형</th>
<th style="text-align: center;">셀러</th>
<th style="text-align: center;">Hit Rate@10 개선율</th>
<th style="text-align: center;">Category Diversity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>슈퍼마켓</strong></td>
<td style="text-align: center;"><strong>셀러 A</strong></td>
<td style="text-align: center;"><strong>51%</strong> ↑</td>
<td style="text-align: center;"><strong>7.04개 → 8.13개</strong></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"><strong>셀러 B</strong></td>
<td style="text-align: center;"><strong>71%</strong> ↑</td>
<td style="text-align: center;"><strong>7.38개 → 8.35개</strong></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"><strong>셀러 C</strong></td>
<td style="text-align: center;"><strong>120%</strong> ↑</td>
<td style="text-align: center;"><strong>8.57개 → 8.38개</strong></td>
</tr>
<tr>
<td style="text-align: center;"><strong>편의점</strong></td>
<td style="text-align: center;"><strong>셀러 D</strong></td>
<td style="text-align: center;"><strong>54%</strong> ↑</td>
<td style="text-align: center;"><strong>3.51개 → 4.98개</strong></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"><strong>셀러 E</strong></td>
<td style="text-align: center;"><strong>40%</strong> ↑</td>
<td style="text-align: center;"><strong>4.80개 → 6.51개</strong></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;"><strong>셀러 F</strong></td>
<td style="text-align: center;"><strong>87%</strong> ↑</td>
<td style="text-align: center;"><strong>5.51개 → 7.11개</strong></td>
</tr>
</tbody>
</table>
<p>오프라인 평가를 통해 다음과 같은 결과를 확인했습니다.</p>
<ul>
<li>기존 Item2Vec 대비 <strong>Hit Rate@10이 40~120% 향상</strong>되었습니다. 특히 데이터가 적은 롱테일 셀러(셀러 C, F)에서 개선폭이 컸는데 이는 Transformer의 Self-Attention이 적은 데이터로도 맥락을 효과적으로 학습했음을 보여줍니다.</li>
<li>대부분의 셀러에서 <strong>추천 상품의 다양성</strong>이 증가했습니다. 특정 카테고리의 유사 상품이 아닌, 함께 구매할 만한 <strong>다양한 상품군</strong>을 추천하는 방향으로 개선되었습니다. 다만 셀러 C에서는 다양성이 소폭 감소했는데, 이는 데이터가 적은 롱테일 셀러의 특성상 모델이 정확도 향상에 집중하면서 더 확실한 추천을 제공하는 방향으로 학습된 것으로 해석할 수 있습니다.</li>
<li>슈퍼마켓과 편의점 모두에서 일관된 성능 향상을 보여 서로 다른 도메인에서도 모델이 안정적으로 작동함을 확인할 수 있었습니다.</li>
</ul>
<h2>온라인 A/B 테스트 결과</h2>
<p>오프라인 평가에서 긍정적인 결과를 확인한 후, 실제 서비스 환경에서의 효과를 검증하기 위해 일부 셀러를 대상으로 2주간 A/B 테스트를 진행했습니다. 기존 Item2Vec 모델을 제공받는 Control 그룹과 개선된 Transformer 모델을 제공받는 Treatment 그룹으로 나누어, 주요 비즈니스 지표를 비교 분석했습니다.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><strong>지표</strong></th>
<th style="text-align: center;"><strong>설명</strong></th>
<th style="text-align: center;"><strong>개선율</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>전체 담기율</strong></td>
<td style="text-align: center;">노출된 추천 상품을 장바구니에 담은 비율</td>
<td style="text-align: center;"><strong>28%</strong> ↑</td>
</tr>
<tr>
<td style="text-align: center;"><strong>바로담기율</strong></td>
<td style="text-align: center;">상세 페이지를 거치지 않고, 장바구니에 바로 담은 비율</td>
<td style="text-align: center;"><strong>30%</strong> ↑</td>
</tr>
<tr>
<td style="text-align: center;"><strong>카테고리 다양성</strong></td>
<td style="text-align: center;">추천된 상위 10개 상품의 카테고리 다양성</td>
<td style="text-align: center;"><strong>13%</strong> ↑</td>
</tr>
<tr>
<td style="text-align: center;"><strong>주문율</strong></td>
<td style="text-align: center;">추천 상품을 담은 후 구매 완료한 비율</td>
<td style="text-align: center;"><strong>36%</strong> ↑</td>
</tr>
</tbody>
</table>
<p>A/B 테스트 결과 <strong>다양한 지표에서 개선 효과</strong>가 있었습니다. 특히 메인 지표인 전체 담기율은 <strong>28% 크게 상승</strong>했으며, 테스트 기간 동안 안정적으로 높은 수준을 유지했습니다. 다음은 일자별 전체 담기율 추이입니다.</p>
<p><!-- TODO: 지표 bar 그래프 추가 --></p>
<div style="text-align: center">
  <img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/1%EC%B0%A8-AB%EA%B2%B0%EA%B3%BC-750x220.jpg" width="450" alt="AB테스트"><br /><em style="color: #666;font-size: 13px;font-style: normal">그림 6. 일자별 전체 담기율 추이</em>
</div>
</p>
<p>특히 바로담기율은 <strong>30% 증가</strong>했는데, 이는 고객이 상세 페이지를 확인하지 않고도 추천된 상품의 적합성을 판단할 수 있었음을 의미합니다. 카테고리 다양성 역시 <strong>13% 증가</strong>하여, Item2Vec의 대체재 편향 문제를 극복하고 <strong>다양한 보완 상품</strong>을 제안할 수 있게 되었습니다. 또한, 가드레일 지표인 <strong>주문율과 평균 주문 금액이 함께 개선</strong>되며 추천이 단순히 클릭을 유도하는 것을 넘어 실제 구매로 이어지고 있음을 확인했습니다. </p>
<p></p>
<h1>한 단계 더: 모델 고도화</h1>
<p>A/B 테스트에서 좋은 성과를 거두었지만 실제 서비스를 운영하면서 개선할 여지를 더 발견했습니다.</p>
<p>당시 모델은 마트와 편의점 타입의 셀러를 대상으로 서비스되고 있었는데 두 셀러 타입을 구분하지 않고 하나의 통합 추천을 제공하고 있었습니다. 하지만 <strong>셀러 타입 간 데이터 차이</strong>가 있으며 특히 <strong>함께 구매 데이터가 희소한 상품</strong>들의 경우 추천 품질이 저하되는 문제도 발견했습니다. 이러한 문제를 해결하기 위해 모델을 한 단계 더 고도화했습니다.</p>
<h2>Stage 1. 상품,  카테고리 임베딩 개선</h2>
<h3>(1) 셀러 타입별 임베딩 학습 분리</h3>
<p>기존 모델은 마트와 편의점 셀러를 구분하지 않고 <strong>하나의 통합된 그래프와 임베딩</strong>을 사용하고 있었습니다. 하지만 두 셀러 타입은 다음과 같이 명확한 차이를 보였습니다.</p>
<p>먼저 <strong>판매 상품군</strong>을 살펴보면, 마트는 신선식품 중심, 편의점은 간편식품 중심으로 주력 카테고리가 달랐습니다. 또한 마트가 약 3배 더 많은 카테고리의 상품을 판매하고 있었습니다.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><strong>셀러 타입</strong></th>
<th style="text-align: center;"><strong>카테고리 수</strong></th>
<th style="text-align: center;"><strong>주력 판매 상품군</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>마트</strong></td>
<td style="text-align: center;">약 3,000개</td>
<td style="text-align: center;">채소/축산/과일 등의 신선식품</td>
</tr>
<tr>
<td style="text-align: center;"><strong>편의점</strong></td>
<td style="text-align: center;">약 1,000개</td>
<td style="text-align: center;">스낵/음료 간식류, 라면/도시락 등의 간편식품</td>
</tr>
</tbody>
</table>
<p><strong>구매 유저군</strong>도 큰 차이를 보였습니다. 3개월간 구매 유저 데이터를 분석한 결과, 두 셀러 타입을 모두 이용하는 유저는 소수에 불과했습니다.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><strong>구매 패턴</strong></th>
<th style="text-align: center;"><strong>비율</strong></th>
<th style="text-align: center;"><strong>특징</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>마트만</strong> 구매</td>
<td style="text-align: center;">약 <strong>81%</strong></td>
<td style="text-align: center;">전체 유저의 대다수</td>
</tr>
<tr>
<td style="text-align: center;"><strong>편의점만</strong> 구매</td>
<td style="text-align: center;">약 <strong>10%</strong></td>
<td style="text-align: center;">편의점 특화 유저군</td>
</tr>
<tr>
<td style="text-align: center;">마트와 편의점 <strong>모두</strong> 구매</td>
<td style="text-align: center;">약 <strong>9%</strong></td>
<td style="text-align: center;">두 셀러 교집합</td>
</tr>
</tbody>
</table>
<p>특히 마트 구매자의 약 90%는 마트에서만 구매하는 반면 편의점 구매자의 절반 정도는 마트도 함께 이용하는 비대칭적 구매 패턴을 보였습니다. 이러한 데이터는 두 셀러 타입의 <strong>유저군이 명확히 구분</strong>되며 동일한 카테고리의 상품이라도 셀러 타입에 따라 구매 맥락과 패턴이 다를 수 있음을 보여줍니다. </p>
<p>따라서 마트와 편의점의 특성을 각각 반영하기 위해 <strong>셀러 타입별로 독립적인 그래프를 구성</strong>하고 별도의 임베딩을 학습하는 방식으로 개선했습니다.</p>
<h3>(2) 그래프 구조 고도화: 연결 정보 강화</h3>
<p>상품-상품 간의 함께 구매 데이터는 롱테일(Long-tail) 특성을 가지며 특히 신규 상품이나 구매 빈도가 낮은 상품 간의 연결 정보가 부족해 Edge Weight의 신뢰도가 떨어지는 문제가 있었습니다.</p>
<p>이러한 데이터 희소성 문제를 완화하고 그래프의 표현력을 높이기 위해 <strong>Category-Category 연결을 추가</strong>하고 Edge Weight에 <strong>Bayesian Smoothing을 적용</strong>했습니다. 카테고리 간 Edge를 추가함으로써 Random Walk 시 카테고리를 경유한 상품 탐색이 가능해져 더 다양한 시퀀스를 생성할 수 있게 되었으며 동시에 데이터 희소성도 보완할 수 있었습니다.</p>
<h4><strong>카테고리 간 Edge 추가</strong></h4>
<p>다음 그림은 기존 그래프에 Category-Category 연결을 추가하여 개선한 구조입니다.</p>
<p><!-- TODO: 그래프 이미지 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/%EA%B7%B8%EB%9E%98%ED%94%84-%EC%98%88%EC%8B%9C2-750x632.jpg" width="350" alt="그래프 개선"><br /><em style="color: #666;font-size: 13px;font-style: normal">그림 7. 개선된 그래프</em>
</div>
<p></p>
<p>기존 그래프는 <strong>Item-Item</strong>과 <strong>Item-Category</strong> 연결만 존재했습니다. 이 구조에서는 상품 간 직접 연결이 없으면 Random Walk로 도달하기 어렵다는 한계가 있었습니다.</p>
<p><strong>Category-Category</strong> 연결을 추가하여, <code>상품1 → 카테고리1 → 카테고리2 → 상품2</code>의 경로로도 탐색할 수 있게 개선했습니다. 주문 데이터를 기반으로 함께 구매된 상품들의 카테고리를 집계하여, Association Rule을 활용해 카테고리 간 연결 강도를 계산하고 그래프에 반영했습니다. 이를 통해 실제로 함께 구매할 가능성이 높은 카테고리들(예: &quot;육류&quot;와 &quot;채소&quot;) 간의 연결이 강화되어, Random Walk 시 이러한 카테고리 조합이 더 자주 생성되도록 했습니다.</p>
<p>예를 들어, 신규 출시된 <code>프리미엄 한우 등심</code>처럼 구매 이력이 부족한 상품의 경우, 다른 상품들과의 직접적인 함께 구매 데이터가 거의 없어 연결이 제한적입니다. 이런 상황에서 카테고리 간 연결은 다음과 같은 차이를 만듭니다.</p>
<blockquote>
<p><strong>[기존] 상품 간 직접 연결이 부족하여 탐색 제한</strong><br />
프리미엄 한우 등심 200g → &quot;육류&quot; → 호주산 소고기 안심 → &#8230;<br />
프리미엄 한우 등심 200g → &quot;육류&quot; → 소고기 채끝 → &#8230;</p>
<p><strong>[개선] 카테고리 간 연결로 다양한 보완 상품 발견</strong><br />
프리미엄 한우 등심 → &quot;육류&quot; → &quot;채소&quot; → 유기농 상추 → &#8230;<br />
프리미엄 한우 등심 → &quot;육류&quot; → &quot;조미료&quot; → 쌈장 300g → &#8230;</p>
</blockquote>
<p>다만 그래프가 풍부해지면 Random Walk가 과도하게 자유로워질 수 있어 실제 구매 패턴에서 벗어난 비현실적인 시퀀스가 생성될 우려가 있었습니다. 예를 들어 카테고리만 계속 이동하거나(<code>&quot;육류&quot; → &quot;채소&quot; → &quot;조미료&quot; → &quot;음료&quot; → ...</code>) 동일 카테고리만 반복되는 시퀀스(<code>삼겹살 → 목살 → &quot;육류&quot; → 소고기 → ...</code>)는 임베딩 학습에 노이즈가 될 수 있습니다. </p>
<p>이를 방지하기 위해 <strong>이종 그래프에서의 Metapath 방식</strong>을 참고하여 노드 타입 간 제약 조건을 추가했습니다. 이를 통해 실제 구매 패턴에 가까운 의미 있는 시퀀스를 생성하도록 했습니다.</p>
<ul>
<li><strong>동일 타입 노드 반복 제한</strong>: 상품 또는 카테고리 노드가 연속으로 등장하는 횟수를 제한하여 자연스러운 상품-카테고리 교차 패턴을 유지</li>
<li><strong>카테고리 다양성 보장</strong>: 동일 카테고리의 상품만 반복적으로 등장하는 것을 방지하여 다양한 상품군을 포함한 시퀀스 생성 </li>
</ul>
<h4><strong>Bayesian Smoothing 적용</strong></h4>
<p>카테고리 간 연결을 추가하여 그래프를 풍부하게 만들었지만 여전히 상품-상품 간 직접 연결의 신뢰도 문제가 남아있었습니다. 특히 구매 횟수가 적은 상품 쌍의 경우 Edge Weight의 신뢰도가 낮아 노이즈가 될 수 있습니다. </p>
<p>이를 해결하기 위해 <strong>상위 개념인 카테고리-카테고리 간 Edge Weight를 활용</strong>하는 Bayesian Smoothing을 도입했습니다. 예를 들어, <code>프리미엄 한우 등심</code>과 <code>유기농 상추</code> 간의 직접 구매 데이터가 부족하더라도, 두 상품이 속한 <code>&quot;육류&quot;</code>와 <code>&quot;채소&quot;</code> 카테고리 간의 연관성(상위 개념)을 활용하여 Edge Weight를 보정하는 방식입니다.</p>
\[w_{ij}^{\text{smoothed}} = \lambda \times w_{ij} + (1 &#8211; \lambda) \times w_{ij}^{\text{category}}\]
<p>여기서 λ는 관측 데이터(상품 간 함께 구매 횟수)의 신뢰도를 나타내는 계수로 데이터가 많을수록 1에 수렴합니다. 상품 간 함께 구매 횟수가 적을수록 카테고리 수준의 Prior(w<sub>ij</sub><sup>category</sup>)에 더 많이 의존하고 구매 횟수가 많아질수록 상품 수준의 Likelihood(w<sub>ij</sub>)를 더 신뢰하는 구조입니다. 이를 통해 함께 구매 데이터가 희소한 상황에서도 상위 개념의 통계적 정보를 활용하여 안정적인 Edge Weight를 유지할 수 있습니다.</p>
<p>구매 횟수가 적어 우연히 높은 Edge Weight를 가진 노이즈성 상품 쌍들의 가중치가 하락하여 그래프의 신뢰도가 향상됩니다. 이는 Random Walk 시 품질이 낮은 연결을 따라가는 것을 방지하여 더 의미 있는 노드 시퀀스를 생성할 수 있도록 합니다. 다음은 실제 상품 쌍(<code>name_1</code>, <code>name_2</code>)의 Edge Weight이 어떻게 조정되었는지 보여주는 예시입니다. Bayesian Smoothing 적용 후, 신뢰도가 낮은 상품 쌍의 가중치는 하락하여 노이즈성 edge가 개선됨을 확인할 수 있습니다.</p>
<p><strong>Bayesian Smoothing 결과</strong></p>
<p><!-- TODO: 베이지안 예시 추가 --></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/bayesian-%EC%98%88%EC%8B%9C-750x569.png" width="400" alt="베이지안 예시1"></div>
<p></p>
<div style="text-align: center">
<img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/bayesian-%EC%98%88%EC%8B%9C2-750x561.png" width="400" alt="베이지안 예시2"><br /><em style="color: #666;font-size: 13px;font-style: normal">그림 8. Bayesian Smoothing을 통한 노이즈성 edge 개선</em>
</div>
<p></p>
<h2>Stage 2. Transformer 기반 시퀀스 추천 개선</h2>
<p>Stage 1에서 임베딩을 개선한 후, Stage 2에서는 Transformer 모델의 학습 방식을 개선했습니다. 기존 모델을 분석하던 중 Next Item Prediction 시 <strong>고정된 타깃</strong>을 사용하고 있다는 점을 발견했습니다. 즉, 최초에 랜덤하게 추출한 타깃을 학습 시 모든 Epoch에서 동일하게 사용하고 있었으며 이로 인해 모델이 동일한 시퀀스에서 다양한 상황을 학습하지 못하는 한계가 있었습니다. </p>
<p>모델의 일반화 성능을 향상시키기 위해 <strong>Epoch별로 타깃을 새롭게 샘플링</strong>하는 방식으로 변경했습니다. 이를 통해 동일한 주문 샘플에서도 매 Epoch마다 다른 타깃을 학습하게 되어 다양한 길이와 맥락을 활용할 수 있도록 했습니다. 또한 샘플링 시 랜덤 시드에 Epoch 번호를 포함시켜 실험 재현성을 보장할 수 있도록 설계했습니다. </p>
<p>예를 들어, <code>[삼겹살, 상추, 마늘, 쌈장]</code> 시퀀스가 있을 때</p>
<blockquote>
<p><strong>[기존] 최초 선택된 고정 타깃 사용</strong><br />
────────────────<br />
Epoch 1:  [삼겹살, 상추, 마늘] → 쌈장<br />
Epoch 2:  [삼겹살, 상추, 마늘] → 쌈장<br />
Epoch 3:  [삼겹살, 상추, 마늘] → 쌈장<br />
&#8230;</p>
<p><strong>[개선] 매 Epoch마다 타깃 샘플링</strong><br />
────────────────<br />
Epoch 1:  [삼겹살, 상추] → 마늘<br />
Epoch 2:  [삼겹살, 상추, 마늘] → 쌈장<br />
Epoch 3:  [삼겹살] → 상추<br />
&#8230;</p>
</blockquote>
<p>또한 기존 모델은 타깃 기준으로 이전에 담긴 모든 시퀀스를 입력으로 사용했으나 다양한 시퀀스 길이에 대한 실험을 통해 <strong>최근 5개 상품만으로도 유사한 성능</strong>을 낼 수 있음을 확인했습니다. 성능과 계산 효율성을 고려한 실험 결과를 바탕으로 최적의 시퀀스 길이를 설정하여 <strong>모델의 계산량을 줄이면서도 성능을 유지</strong>할 수 있도록 개선했습니다.</p>
<p></p>
<h1>V2 모델 검증</h1>
<h2>온라인 A/B 테스트 결과</h2>
<p>오프라인 평가에서 긍정적인 결과를 확인한 V2 모델을 실제 서비스 환경에 적용하여 효과를 검증했습니다. V2 모델은 Stage 1의 <strong>셀러 타입별 임베딩 분리, 그래프 구조 개선</strong>과 Stage 2의 <strong>Epoch-wise Target Sampling</strong>이 모두 반영되어 있습니다. V1 모델을 제공받는 Control 그룹과 V2 모델을 제공받는 Treatment 그룹으로 나누어, 일정 기간 동안 주요 비즈니스 지표를 비교 분석했습니다.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><strong>지표</strong></th>
<th style="text-align: center;"><strong>설명</strong></th>
<th style="text-align: center;"><strong>개선율</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>전체 담기율</strong></td>
<td style="text-align: center;">노출된 추천 상품을 장바구니에 담은 비율</td>
<td style="text-align: center;"><strong>4%</strong> ↑</td>
</tr>
<tr>
<td style="text-align: center;"><strong>바로담기율</strong></td>
<td style="text-align: center;">상세 페이지를 거치지 않고 바로 장바구니에 담은 비율</td>
<td style="text-align: center;"><strong>5%</strong> ↑</td>
</tr>
<tr>
<td style="text-align: center;"><strong>주문율</strong></td>
<td style="text-align: center;">추천 상품을 담은 후 구매 완료한 비율</td>
<td style="text-align: center;"><strong>4%</strong> ↑</td>
</tr>
</tbody>
</table>
<p>V1 모델에서 이미 큰 폭의 성과를 거둔 상황에서 V2 모델은 추가로 전체 담기율 <strong>4%</strong>, 바로담기율 <strong>5%</strong>, 주문율 <strong>4%</strong>의 추가 개선을 달성했습니다. 이는 Stage 1의 셀러 타입별 임베딩 분리와 그래프 구조 개선, Stage 2의 Epoch-wise Target Sampling이 실질적인 추가 효과를 만들어냈음을 의미합니다.</p>
<p>또한 가드레일 지표인 평균 주문 금액 역시 안정적으로 유지되어 비즈니스 건전성을 확보하면서도 핵심 지표 개선을 달성할 수 있었습니다.</p>
<h2>셀러 타입별 성과</h2>
<p>셀러 타입별로 분리하여 학습한 임베딩의 효과를 더 자세히 살펴보기 위해 마트와 편의점을 나누어 결과를 분석했습니다.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><strong>셀러 타입</strong></th>
<th style="text-align: center;"><strong>전체 담기율</strong></th>
<th style="text-align: center;"><strong>바로담기율</strong></th>
<th style="text-align: center;"><strong>주문율</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>마트</strong></td>
<td style="text-align: center;"><strong>6%</strong> ↑</td>
<td style="text-align: center;"><strong>7%</strong> ↑</td>
<td style="text-align: center;"><strong>4%</strong> ↑</td>
</tr>
<tr>
<td style="text-align: center;"><strong>편의점</strong></td>
<td style="text-align: center;"><strong>2%</strong> ↑</td>
<td style="text-align: center;"><strong>3%</strong> ↑</td>
<td style="text-align: center;"><strong>5%</strong> ↑</td>
</tr>
</tbody>
</table>
<p>마트와 편의점 타입의 셀러 모두 긍정적인 성과를 보였습니다. 마트 타입의 셀러에서 지표 개선폭이 더 컸는데 다양한 상품 구성과 복잡한 구매 패턴의 특성이 분리 학습된 임베딩에 효과적으로 반영된 것으로 보입니다. 편의점은 스낵류와 간편식품 중심의 특성이 명확해 상대적으로 개선폭은 작지만 전체 담기율부터 주문율까지 모든 지표에서 꾸준한 개선을 보였습니다.</p>
<p></p>
<h1>결론 및 향후 계획</h1>
<p>기존 Item2Vec 방식은 <strong>대체재 편향과 시퀀스 맥락 부재</strong>라는 한계가 있었습니다. 이를 해결하기 위해 <strong>2-stage 파이프라인 기반의 Transformer 모델</strong>을 도입했고, 단계적 개선을 통해 장바구니 추천 성능을 크게 향상시켰습니다.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><strong>단계</strong></th>
<th style="text-align: center;"><strong>주요 개선</strong></th>
<th style="text-align: center;"><strong>효과</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>V1 모델</strong></td>
<td style="text-align: center;">Graph Embedding + Transformer 도입</td>
<td style="text-align: center;">담기율 28%, 주문율 36% 개선</td>
</tr>
<tr>
<td style="text-align: center;"><strong>V2 모델</strong></td>
<td style="text-align: center;">임베딩 분리 및 그래프 개선, 모델 Generalization 능력 향상</td>
<td style="text-align: center;">담기율 4% 추가 개선</td>
</tr>
</tbody>
</table>
<p>Item2Vec에서 시작하여 단계적 개선을 거친 결과 <strong>담기율, 평균  주문금액, 추천 다양성 등의 주요 비즈니스 지표에서 의미 있는 성과</strong>를 거두었습니다. </p>
<p>장바구니 추천 모델 개선의 핵심은 단순히 지표를 향상시키는 것을 넘어 유저가 장바구니에 담은 <strong>구매 맥락을 이해</strong>하고 그에 맞는 <strong>보완 상품을 제안</strong>하여 실질적인 쇼핑 경험 개선을 이뤄냈다는 점입니다. 특히 셀러 타입별로 임베딩을 분리 학습함으로써 마트와 편의점이라는 서로 다른 도메인 특성을 반영하면서도 일관된 성능 향상을 달성할 수 있었습니다.</p>
<h2>향후 계획</h2>
<h3>개인화 도입</h3>
<p>현재 모델은 장바구니 맥락을 기반으로 일반화된 추천을 제공하지만, 유저 개개인의 선호도는 반영하지 못하고 있습니다. 예를 들어, 특정 브랜드를 선호하는 유저에게는 해당 브랜드의 상품을, 유기농 상품을 선호하는 유저에게는 유기농/친환경 상품군을 추천하는 것이 더 적합할 수 있습니다. </p>
<p>유저의 구매 이력과 선호도를 반영하면 동일한 맥락에서도 유저별로 최적화된 추천이 가능할 것입니다. 이를 위해 후처리 단계에서의 개인화 필터링이나 유저 임베딩 기반 리랭킹 모델 등을 검토하고 있습니다. 나아가 <strong>유저의 단기/장기 선호도를 모두 고려</strong>하여 단기/장기 취향을 균형있게 반영하는 방향도 고려해 볼 수 있습니다.</p>
<h3>Cold Start 문제 개선</h3>
<p>현재는 신규 상품이나 구매 이력이 부족한 상품에 대해 소속 카테고리의 임베딩을 활용하고 있으나 이는 같은 카테고리 내 상품들을 동일하게 표현하는 한계가 있습니다. 상품명, 브랜드, 상세 설명 등의 메타데이터를 활용한 <strong>Content-based 임베딩</strong>을 협업 필터링 기반 임베딩과 결합하는 Hybrid 접근법을 도입하면 신규 상품에 대해서도 개별 특성을 반영한 추천이 가능할 것입니다. </p>
<h3>더 넓은 맥락 이해</h3>
<p>현재는 장바구니 내 상품 시퀀스만을 고려하지만 실제 구매 의도는 더 복잡한 요인들의 영향을 받습니다. <strong>시간대, 요일, 날씨, 계절, 최신 트렌드</strong> 등의 컨텍스트 정보를 모델에 반영하면 다양한 상황에 더 정교하게 대응할 수 있습니다. 이러한 컨텍스트 정보를 추가로 반영하여 시공간적 맥락을 고려한 더욱 정교한 추천이 가능할 것으로 기대됩니다.</p>
<p></p>
<h1>마무리</h1>
<p>이번 글에서는 고객의 구매 맥락을 이해하기 위해 그래프 기반 임베딩과 Transformer를 활용한 장바구니 추천 모델 개선 사례를 소개했습니다. </p>
<p>추천프로덕트팀은 이처럼 고객에게 <strong>최상의 경험</strong>을 제공하기 위해 <strong>끊임없이 추천 시스템을 발전</strong>시켜 나가고 있습니다. 앞으로도 데이터 속에서 고객의 니즈를 발견하고 이를 실제 서비스로 연결하며, 그 과정에서 얻은 인사이트를 함께 공유하겠습니다.</p>
<p>다음 글에서는 배민의 <strong>음식 배달 추천</strong>에 대해 소개드리려고 합니다. 고객이 앱을 열어 음식을 주문하기까지 어떤 추천들이 함께하고 있는지 궁금하시다면 앞으로도 많은 관심 부탁드립니다!</p>The post <a href="https://techblog.woowahan.com/24434/">“함께 구매하면 좋은 상품” 추천 모델 고도화</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></content:encoded>

					<wfw:commentRss>https://techblog.woowahan.com/24434/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>


			</item>
		<item>
		<title>우리는 코드처럼 문화도 리팩토링한다</title>
		<link>https://techblog.woowahan.com/24820/</link>
					<comments>https://techblog.woowahan.com/24820/#respond</comments>

		<dc:creator><![CDATA[우희제]]></dc:creator>
		<pubDate>Wed, 10 Dec 2025 07:35:09 +0000</pubDate>
				<category><![CDATA[Culture]]></category>
		<category><![CDATA[Frontend]]></category>
		<category><![CDATA[문정힘]]></category>
		<category><![CDATA[조직문화]]></category>
		<category><![CDATA[커머스]]></category>
		<category><![CDATA[프론트엔드]]></category>
		<guid isPermaLink="false">https://techblog.woowa.in/?p=24820</guid>

					<description><![CDATA[<p>팀 소개 커머스웹프론트개발팀(이하 “커머프팀”)은 배달의민족의 모든 커머스 서비스와 플랫폼은 물론, 백오피스부터 뒷단의 물류시스템에 이르기까지 웹 클라이언트 영역을 담당하는 거대한 규모의 팀입니다. 각기 다른 서비스를 담당하던 팀이 모여 하나의 큰 팀을 이루었고, 배달의민족이 꿈꾸는 커머스의 새로운 챕터를 열기 위한 힘찬 발걸음을 내디뎠습니다. 팀의 키를 잡은 초보 팀장은 얼마 못 가 혼자서는 이 거대한 조직의 복잡도를 감당해 [&#8230;]</p>
The post <a href="https://techblog.woowahan.com/24820/">우리는 코드처럼 문화도 리팩토링한다</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></description>
										<content:encoded><![CDATA[<div>
<h2 style="margin-top: 80px;margin-bottom: 40px;font-size: 24px;font-weight: bold">팀 소개</h2>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">커머스웹프론트개발팀(이하 “커머프팀”)은 배달의민족의 모든 커머스 서비스와 플랫폼은 물론, 백오피스부터 뒷단의 물류시스템에 이르기까지 웹 클라이언트 영역을 담당하는 거대한 규모의 팀입니다. 각기 다른 서비스를 담당하던 팀이 모여 하나의 큰 팀을 이루었고, 배달의민족이 꿈꾸는 커머스의 새로운 챕터를 열기 위한 힘찬 발걸음을 내디뎠습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">팀의 키를 잡은 초보 팀장은 얼마 못 가 혼자서는 이 거대한 조직의 복잡도를 감당해 내는 것이 불가능하다는 것을 깨닫게 됩니다. 하지만 다행히도 커머프팀에는 유능하고 팀을 돕고자 하는 팀원들이 많이 있었습니다. 팀을 이끄는 것은 사람이 아니라 함께 만들어가는 문화라는 것에 공감한 우리는, 이 문화를 코드처럼 지속적으로 리팩토링해나갈 “문화 리딩 그룹”을 꾸리게 됩니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 48px">오늘은 커머프팀과 문화 리딩 그룹이 함께 팀의 비효율을 걷어내고, 더 나은 구조를 만들기 위해 치열하게 고민했던 저희의 여정을 &#8216;조직 구조&#8217;, &#8216;소통 방식’, &#8216;기록 체계&#8217; 관점에서 나누어 소개해 드리고자 합니다. 이제 막 팀을 꾸려 문화를 마련하고자 하는 팀, 혹은 레거시 코드처럼 단단히 굳어버린 비효율 때문에 리팩토링이 절실한 팀에게 저희의 시행착오가 조금이나마 도움이 되기를 바라며, 이야기를 시작해 보겠습니다.</p>
<h2 style="margin-top: 80px;margin-bottom: 40px;font-size: 24px;font-weight: bold">하나의 목표, 유연한 조직: 경계가 없는 파트</h2>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">커머프팀은 기술적 깊이를 추구하는 기능 조직의 일원인 동시에, 각 비즈니스 과제를 책임지는 목적 조직의 성격도 함께 가지고 있습니다. 이 두 가지 역할을 조화롭게 수행하는 것이 팀의 중요한 특징입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">하지만 거의 20명 규모의 FE개발자로만 구성된 개발팀이 비즈니스 과제와 티켓들을 효율적으로 처리하는 것은 언제나 난제였습니다. 팀원 모두가 한자리에 모여 업무 계획을 짜는 것은 집중력도 떨어지고, 물리적인 시간 소모도 너무 컸습니다. 단일 팀으로 운영하기에는 소통 비용이 한계에 다다른 것입니다. 결국 팀을 여러 파트로 나눠야 했지만, “어떻게” 나누느냐가 가장 큰 숙제였습니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">비효율적인 분할 방식을 버리다</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">규모 있는 팀을 효율적으로 움직이기 위해 고민하던 당시, 우리 앞에는 “ONE COMMERCE”라는 거대한 목표가 놓여 있었습니다. 이는 배달의민족 내에 흩어져 있던 B마트, 배민스토어 등 다양한 커머스 서비스들을 기술적으로, 그리고 경험적으로 통합해내야 하는 수많은 과제들이 복잡하게 얽힌 거대한 미션이었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">목표를 달성하기 위해 먼저 일반적인 조직 구성 방식들을 검토했습니다. 하지만 곧 몇 가지 전통적인 분할 방식들이 오히려 우리가 목표로 하는 “통합”과 “유연성”을 저해한다는 사실을 발견했습니다.</p>
<ul style="margin-bottom: 24px;line-height: 1.75">
<li><b>프로젝트별 분할</b>: 과제의 발생 시기나 규모가 불규칙하기에, 특정 시기에 일부 파트로만 업무가 쏠리는 등 리소스 불균형이 심화되었습니다.</li>
<li><b>담당 페이지/퍼널 단위 분할</b>: 퍼널(고객의 단계별 경험)을 기준으로 나누면, 맡은 지면 외의 영역에 대한 이해도가 낮아져 전체적인 서비스 흐름을 파악할 수 없었습니다.</li>
<li><b>서비스 vs 백오피스 분할</b>: 이는 거대한 팀을 단순히 반으로 쪼개는 것에 불과해, 상호 간의 교류를 막고 시너지를 기대하기 어려웠습니다.</li>
</ul>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이러한 문제들을 분석하며 우리는 한 가지 공통 원인을 찾았습니다. 바로 구성원을 특정 업무 도메인에 지나치게 강하게 묶어두고 있다는 점이었습니다. 우리는 이러한 특정 역할에 고정된 경직된 구조가, 급변하는 비즈니스 상황과 통합이라는 과제에 유연하게 대처할 수 없게 만드는 가장 큰 걸림돌이 될 것이라 판단했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이 문제를 해결하기 위해 개인과 도메인 사이의 경직된 경계를 허물기로 했습니다. 특정 영역을 전담하는 칸막이를 없애고, 팀 전체가 “ONE COMMERCE”라는 하나의 목표를 향해 언제든 유연하게 움직일 수 있도록 특정 도메인에 얽매이지 않는 “경계 없는 파트”를 만들기로 결정한 것입니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">R＆R을 넘어 R＆E로: 책임과 확장</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">경계 없는 파트가 제대로 작동하기 위해서는, 팀원을 특정 역할에 가두는 기존의 R&amp;R(Role &amp; Responsibility) 방식부터 개선해야 했습니다. 우리는 이를 대신할 “R&amp;E(Responsibility &amp; Expandability)”라는 새로운 방향성을 정의했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이는 “내 일의 경계를 두지 않고 문제를 끝까지 해결한다”는 우아한형제들의 일하는 원칙 “Own It”과도 정확히 맞닿아 있습니다. 단순히 주어진 역할만 수행하는 것에 그치지 않고, 책임을 넘어서 경계를 허물고 업무 영역을 확장하여 서로를 돕는다는 의미입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">실제 업무는 유기적으로 진행됩니다. 업무 요청이 들어오면 팀장-파트장 간 싱크업을 거쳐 3개로 나뉜 파트로 배분하되, 팀원들은 경계 없는 협력을 통해 서로의 빈자리를 유동적으로 메워주는 시스템이 핵심입니다.</p>
<figure style="text-align: center;margin: 30px 0"><img loading="lazy" decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/SCR-20251210-mkic.jpeg" alt="" width="750" height="407" class="size-medium wp-image-24831" style="max-width: 100%;height: auto" srcset="https://techblog.woowahan.com/wp-content/uploads/2025/12/SCR-20251210-mkic.jpeg 2480w, https://techblog.woowahan.com/wp-content/uploads/2025/12/SCR-20251210-mkic-750x407.jpeg 750w, https://techblog.woowahan.com/wp-content/uploads/2025/12/SCR-20251210-mkic-870x472.jpeg 870w, https://techblog.woowahan.com/wp-content/uploads/2025/12/SCR-20251210-mkic-768x417.jpeg 768w, https://techblog.woowahan.com/wp-content/uploads/2025/12/SCR-20251210-mkic-1536x834.jpeg 1536w, https://techblog.woowahan.com/wp-content/uploads/2025/12/SCR-20251210-mkic-2048x1112.jpeg 2048w, https://techblog.woowahan.com/wp-content/uploads/2025/12/SCR-20251210-mkic-1568x851.jpeg 1568w" sizes="(max-width: 750px) 100vw, 750px" /><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">조직의 목적과 부합한 성과</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이러한 유연한 조직 구조는 우리가 지향했던 ONE COMMERCE라는 거대한 목표를 현실로 만드는 핵심 열쇠가 되었습니다. 경계 없는 파트제는 모든 프로덕트를 아우르며 각 서비스 간의 도메인 차이를 파악하고 실질적인 통합을 이뤄내는 데 매우 효과적이었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">실제로 B마트와 배민스토어의 상품 카드나 상세 화면을 통합하고 API 구조를 맞추는 과정에서 이 강점이 여실히 드러났습니다. 만약 담당자가 서비스별로 나뉘어 있었다면, 서로의 레거시 코드를 파악하고 스펙을 조율하는 데에만 상당한 시간이 소요되었을 것입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">하지만 우리는 평소 경계 없는 파트를 통해 구성원 모두가 각 서비스의 도메인 맥락을 폭넓게 공유하고 있었습니다. 덕분에 특정 페이지 단위가 아닌 커머스 전체의 관점에서 구조를 바라볼 수 있었고, 중복된 로직을 과감히 제거하고 공통 모듈로 추상화하여 코드 베이스의 일관성을 확보하고 견고한 통합 아키텍처를 구축할 수 있었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">비즈니스 성과는 곧 구성원의 성장으로 이어졌습니다. 팀원들은 특정 서비스나 지면에 국한된 개발을 넘어, 대(對)고객 서비스의 UX부터 어드민의 데이터 흐름까지 전방위적인 도메인 지식을 동시에 학습할 수 있었습니다. 이를 통해 특정 서비스의 담당자가 아닌, 커머스 도메인 전체를 조망하는 엔지니어로 성장할 수 있는 기회를 얻게 되었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이처럼 개개인이 다룰 수 있는 업무 영역이 넓어지면서, 조직 운영의 효율성 또한 자연스럽게 개선되었습니다. 바쁜 시기에 과제가 몰리더라도 유연하게 리소스를 배분하여 병목 현상을 최소화할 수 있었고, 무엇보다 버스 팩터(Bus Factor: 프로젝트가 중단되기 위해 필요한 결원 수)가 크게 향상되었습니다. 특정 인원이 부재하더라도 누구나 맥락을 이어받을 수 있는, 한층 더 견고하고 안전한 조직 구조를 완성했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">나아가, 유연해진 구조는 건강한 협업 문화를 만드는 단단한 토양이 되었습니다. 팀원들은 다양한 과제를 경험하며 폭넓은 코드 리뷰를 진행했으며, 정기적인 파트 셔플을 통해 여러 동료와 일하며 신선함과 서로 다름에서 배우는 교류의 문화를 지속할 수 있었습니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">성장통과 그 극복 과정</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">물론 이 실험적인 조직구조가 완벽하지만은 않았기에, 우리는 현실적인 문제들을 해결하기 위한 노력을 병행했습니다. 특히 “경계 없는 파트”라는 대원칙을 훼손하지 않으면서 현실적인 문제들을 보완하는 것이 중요했습니다.</p>
<h4 style="margin-top: 24px;margin-bottom: 12px;font-size: 18px;font-weight: bold">지식의 파편화와 의존성</h4>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">너무 넓은 범위를 다루다 보니 개개인이 모든 맥락을 기억하기 어렵고, 특정 인원에 대한 의존도가 지나치게 높아질 우려가 있었습니다. 우리는 지식의 저장소를 “사람”에서 “문서”로 옮기는 작업에 집중했습니다. 개인이 파편적으로 가지고 있던 지식을 팀 차원의 자산으로 남기기 위해 <a href="https://adr.github.io/">ADR</a>(Architectural Decision Record; 아키텍처 결정 기록) 문화를 강화한 것입니다. 이에 대한 구체적인 이야기는 뒤에서 다시 한번 다루겠습니다.</p>
<h4 style="margin-top: 24px;margin-bottom: 12px;font-size: 18px;font-weight: bold">컨텍스트 스위칭의 어려움</h4>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">잦은 과제 변경으로 인한 피로도를 줄이기 위해, 연속성 있는 후속 과제들은 최대한 같은 팀원들이 이어갈 수 있도록 각 파트에서 배정에 신중을 기했습니다. 단, 이것이 특정인에게만 업무 맥락이 쌓이는 부작용을 낳지 않도록, 규모가 큰 과제는 2인 페어(Pair)로 진행하거나 위클리 시간을 통해 ADR 내용을 공유했습니다. 이를 통해 담당자가 아니더라도 언제든 해당 과제의 맥락을 파악하고 투입될 수 있도록, 도메인 전환의 진입 장벽을 낮추는 노력을 병행했습니다.</p>
<h4 style="margin-top: 24px;margin-bottom: 12px;font-size: 18px;font-weight: bold">파트 간 사일로화 방지</h4>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">파트가 업무 분배 단위일 뿐임을 명확히 하고, 파트만의 별도 규칙을 만드는 것을 금지했습니다. 좋은 시도는 팀 전체로 빠르게 공유하여 모두가 함께 발전할 수 있도록 했습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img loading="lazy" decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/SCR-20251210-mkki.png" alt="" width="750" height="407" class="size-medium wp-image-24831" style="max-width: 100%;height: auto"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">구조를 넘어, 소통의 리팩토링으로</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">결국 20명 규모 팀의 비효율성과 경직성을 해결하기 위해, 우리는 도메인 구분이 없는 파트와 “R&amp;E”라는 파격적인 해답을 찾아냈습니다. 이 유연한 구조는 팀원 모두가 경계를 확장하고 지식을 교류하게 만들었으며, ONE COMMERCE와 같은 대형 프로젝트에서도 팀이 흔들리지 않도록 강력한 기동력을 제공했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">그러나 조직 구조라는 하드웨어를 리팩토링했다고 해서 시스템이 완벽해진 것은 아니었습니다. 오히려 파트 간 경계가 사라지고 역할이 확장되자 구성원들이 알아야 할 맥락은 기하급수적으로 늘어났고, 이는 곧 소통과 협업의 새로운 병목이 되었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 48px">20명이 하나의 유기체처럼 움직이기 위해서는, 바뀐 구조에 걸맞은 새로운 소통 프로토콜이 필요했습니다. 우리는 다시 한번 리팩토링을 시작했습니다. 이번 대상은 조직도가 아니라, 우리가 “대화하고 일하는 방식”입니다.</p>
<h2 style="margin-top: 80px;margin-bottom: 40px;font-size: 24px;font-weight: bold">리팩토링으로 인한 사이드 이펙트 해소</h2>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">가장 먼저 해결해야 했던 부분은 맥락의 공유였습니다. 팀 구성원 간의 거리는 가까우면서도 때로는 멀게 느껴집니다. 같은 과제를 함께 풀어나가는 팀원 간에는 긴밀한 소통과 협업이 이뤄지지만 바로 옆에서 다른 과제를 하는 구성원 간에는 다른 팀이라고 해도 될 만큼 거리가 느껴질 수 있습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">주간 회의(a.k.a 위클리)는 팀을 연결해주는 중요한 요소입니다. 전통적인 분할 방식을 벗어나 R&amp;E로의 책임 확장을 통해 각자가 알아야 할 맥락은 더 커졌습니다. 이때 위클리는 팀 구성원이 과제에서 마주친 문제와 고민 그리고 해결 과정을 온전히 공유할 수 있는 시간입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">그러나 문제는 위클리 시간이 길다는 것입니다. 대한민국 교육부의 교육과정에 따르면, 초·중·고 수업시간은 40분·45분·50분 입니다. 사람이 집중력을 잃지 않고 몰입할 수 있는 한계이지 않을까 싶습니다. 20명의 팀 구성원이 한마디씩 의견을 보태다 보면 위클리 시간은 2시간 반을 넘어가기 십상이고, 그러면 회의실에 산소가 부족해지고 집중력도 흐려집니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">저희의 업무 메신저 Slack도 해결책이 되지 못했습니다. 길어지는 위클리를 단축시키기 위해 회의 진행자가 논의를 중재하고 Slack 스레드를 통해 이어갈 수 있도록 해보았지만, 위클리 만큼 뜨거운 논의가 진행될 수 없었습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img loading="lazy" decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/SCR-20251210-mkmj.jpeg" alt="" width="750" height="511" class="size-medium wp-image-24840" style="max-width: 100%;height: auto" srcset="https://techblog.woowahan.com/wp-content/uploads/2025/12/SCR-20251210-mkmj.jpeg 2088w, https://techblog.woowahan.com/wp-content/uploads/2025/12/SCR-20251210-mkmj-750x511.jpeg 750w, https://techblog.woowahan.com/wp-content/uploads/2025/12/SCR-20251210-mkmj-870x593.jpeg 870w, https://techblog.woowahan.com/wp-content/uploads/2025/12/SCR-20251210-mkmj-768x524.jpeg 768w, https://techblog.woowahan.com/wp-content/uploads/2025/12/SCR-20251210-mkmj-1536x1048.jpeg 1536w, https://techblog.woowahan.com/wp-content/uploads/2025/12/SCR-20251210-mkmj-2048x1397.jpeg 2048w, https://techblog.woowahan.com/wp-content/uploads/2025/12/SCR-20251210-mkmj-1568x1069.jpeg 1568w" sizes="(max-width: 750px) 100vw, 750px" /><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">불판: 가장 뜨거워질 수 있는 곳</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">그래서 뜨겁게 논의를 불태워 보자는 의미로 만든 게 불판입니다. <a href="https://docs.gitlab.com/user/project/issues/">GitLab Issue</a>를 불판이라는 이름과 함께 기술 논의 전용 공간으로 사용했습니다. 고민을 불판에 올리면 Slack 팀 채널로 알림이 오고 관심이 있는 구성원 누구나 자유롭게 참여할 수 있습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">처음엔 이게 될까 싶었습니다. GitLab Issue라고 다를게 있을까? 하지만 달랐습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이유는 간단했습니다. 항상 코드 리뷰로 소통하던 저희에게 Gitlab Issue는 너무나 익숙한 공간이었습니다. Gitlab Issue는 표·영상·사진·인용구·코드 등 기본적인 에디팅 도구뿐만 아니라 담당자·라벨·마감일 등 다양한 컨텍스트를 제공합니다. 또한, Slack 스레드는 다른 스레드에 의해 밀려나고 휘발되지만 GitLab Issue는 항상 그 자리에 뜨겁게 남아있습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">불판의 장점 중 하나는 타이밍을 놓치지 않는 것입니다. 고민이 생긴 그 순간에 올리다보니, 회의 일정 잡을 필요도 없고 20명의 시간 맞출 필요도 없습니다. 그리고, 2~3일 간 논의된 내용을 주간 회의에서 잠깐 다루고 추가적인 논의는 또 불판에서 불태웁니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">“지난주 이런 불판이 있었고, 이렇게 결론 났습니다. 궁금하신 분은 불판 링크 확인해주세요.”</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">덕분에 위클리 시간이 절반 가까이 줄었고, 다양한 관점에서 꼬리에 꼬리를 무는 논의로 끝없이 길어지던 위클리는 모두가 온전히 집중할 수 있는 시간이 되었습니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/SCR-20251210-mkpz.png" alt="" class="size-medium wp-image-24840" style="max-width: 100%;height: auto"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">MR 리뷰 부탁드립니다.</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">저희 팀 Slack 채널에 매일 빠짐없이 올라오는 메시지로, MR(Merge Request) 코드 리뷰를 부탁한다는 얘기입니다. 적절한 코드 리뷰 문화를 찾는 과정은 대부분의 개발 팀이 마주하는 문제이지 않을까 싶습니다. 코드 리뷰는 서로 다른 과제의 맥락과 전체적인 서비스를 이해할 수 있게 돕기에, R&amp;E 라는 팀 방향성을 이루기 위해서 반드시 해결해야 할 과제였습니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">코질라: 바나나 하나 주면 안잡아 먹지</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">코드 리뷰에 “문화”라는 단어가 붙는다는 것은, 그 과정이 강제성만으로 이뤄질 수 없기 때문 이라고 생각합니다. 그래서 적절한 동기부여와 최소한의 강제성을 통해 이 문제를 해결하고자 했고 그 결과물이 코드 리뷰 Slack 봇 코질라(Code + Gozilla) 입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">코질라는 하루에 단 한 개의 코드 리뷰도 하지 않은 사람을 찾아내서 팀 채널에 알립니다. 누구도 뭐라하지 않지만 내 이름이 팀 채널에 올라오는 것만으로 충분한 동기부여를 가지게 됩니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">하루에 한 개의 코드 리뷰를 하기 위해 모두가 쉬운 MR만 찾지 않도록, 난이도에 따른 보상 체계도 있습니다. MR 작성자는 High 라벨을 붙여 코드 리뷰 난이도가 어렵다는 것을 알릴 수 있습니다. 이때 누군가 High MR에 대해 코드 리뷰를 하면 바나나를 보상으로 받게 되고 다음날 1일 1코드 리뷰에서 면제됩니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/SCR-20251210-mkrp.png" alt="" class="size-medium wp-image-24840" style="max-width: 100%;height: auto"></figure>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">코질라 덕분에, 실제로 미완료된 평균 MR 개수는 10개 내외로 줄고 MR 병합 시간도 2-3일 내로 단축되었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 48px">하지만 이게 정답이라고 생각하지 않습니다. 시간이 지나다 보면 리팩토링은 또 필요하기 마련입니다. 팀 채널에 이름이 올라오는 것쯤은 언제든 무감각해질 수 있으니까요. 그 때가 되면 팀 채널이 아니라 상위 조직 채널로 가야할 것입니다.</p>
<h2 style="margin-top: 80px;margin-bottom: 40px;font-size: 24px;font-weight: bold">어제의 방식에 머물지 않는 팀</h2>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">커머프팀은 기능 개발뿐 아니라 일하는 방식 자체도 계속 리팩토링하는 팀입니다. 업무 흐름이 익숙해질수록 비효율은 점점 잘 보이지 않게 숨어들고, “원래 이렇게 해왔어요”라는 말이 자연스럽게 튀어나오곤 합니다. 우리는 바로 그 지점을 가장 경계했습니다. 익숙함이라는 이유만으로 유지되는 구조나 프로세스를 의심하고, 손이 많이 가는 루틴과 기록 방식, 그리고 반복 업무를 하나씩 꺼내어 다시 설계하는 실험을 이어가고 있습니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">루틴도 리팩토링합니다: 반복 업무의 재설계</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">루틴은 시간이 지나면 금방 굳어버리기 쉽습니다. 업무 주기인 스프린트나 매일 아침에 진행되는 데일리(일일 업무 공유 회의)도 마찬가지입니다. 처음엔 팀의 흐름을 맞춰 주는 중요역할을 했지만, 시간이 지나면서 어느 순간 형식만 남은 숙제처럼 변해버렸습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">팀에서 진행하는 정기적인 회고나 설문에서도 같은 신호가 나왔습니다. 제목만 말하고 끝나는 데일리, 일정이 들쭉날쭉한 회의, 사람마다 전부 다른 방식의 업무 공유, 실제 일정과 잘 맞지 않는 스프린트 운영까지. ‘늘 해오던 거니까’, 익숙하다는 이유만으로 방치했던 익숙한 루틴들이 어느새 팀의 속도를 떨어뜨리고 있었던 겁니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">그래서 작은 부분을 손보는 대신, 아예 원점으로 돌아가 질문을 던졌습니다. “이걸 왜 하고 있지?” 스프린트는 외부 일정에 휘둘리지 않고 내부 리소스를 주도적으로 관리하는 단위여야 했고, 데일리는 보고를 하는 시간이 아니라 “도움이 필요하거나 막힌 지점을 찾아내는 시간”이어야 했습니다. 목적을 다시 정의하고 나니 남길 것과 버릴 것이 명확해졌고, 그 기준에 맞춰 루틴을 다시 설계할 수 있었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">스프린트 운영 방식은 크게 두 번의 진화과정을 겪었습니다. 초기에는 서로 다른 팀의 방식들을 하나의 언어로 맞추는 데 집중했다면, 이번에는 실무자의 불편함을 해소하는 방향에 초점을 맞추었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">우선, 추상적인 난이도 점수였던 스토리 포인트(SP)는 난이도가 아닌 ‘실제 투입 시간 (1SP=4시간)’으로 단순화했습니다. 다 함께 모여 난이도를 산정하느라 준비도 길고 효용성이 떨어지는 플래닝 포커(<a href="https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%81%AC%EB%9F%BC_(%EC%95%A0%EC%9E%90%EC%9D%BC_%EA%B0%9C%EB%B0%9C_%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)">참고</a>)는 과감히 없앴습니다. 대신 긴급하게 들어온 이슈도 이제는 예외가 아니라 스프린트 흐름 안에서 SP와 워크로그로 관리하게 했습니다. 규칙을 많이 만드는 것보다, 누구나 자연스럽게 따라갈 수 있는 단순함을 택한 것입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">데일리도 마찬가지였습니다. 사람마다 기대치가 다르다 보니 같은 회의를 하고 있는데도 서로가 전혀 다른 목적을 갖고 있었죠. 그래서 데일리를 ‘어제 완료한 일, 오늘 할 일, 일을 막는 장애 요소(어려운 점)’ 세 가지를 짧게 공유하는 시간으로 다시 정의했습니다. 도구도 파트별 Slack 스레드로 통일했고, 회의 시간은 15분으로 고정했습니다. 만약 깊은 논의가 필요하다면 파트 구분 없이 꼭 필요한 사람들끼리만 별도로 모여 해결하도록 했습니다. 매일 같은 말을 반복하더라도 단순히 ‘했다’가 아니라 ‘어떤 흐름으로 가고 있다’가 보이도록 하는 게 핵심입니다.</p>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/SCR-20251210-mkva.png" alt="" class="size-medium wp-image-24840" style="max-width: 100%;height: auto"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">사소해 보일 수 있지만, 이 작은 변화들이 팀의 리듬을 다시 안정시켰습니다. 루틴은 한 번 굳어지면 아무도 말하지 않는 사이에 계속 무거워지기 마련입니다. 커머프팀은 “원래 이렇게 해왔어요”라는 말이 들리는 순간 다시 그 지점을 의심해봅니다. 그리고 필요하다면 언제든 익숙한 구조를 새롭게 재설계합니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">기록 방식의 버전업: 1Pager에서 ADR로</h3>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/SCR-20251210-pibp.png" alt=""><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">문서의 양식을 바꾸게 된 계기는 아주 작은 불편함들이 쌓이면서부터였습니다. 오랫동안 팀의 표준으로 자리 잡았던 1pager(원페이저)는 처음엔 유용한 도구였습니다. 일반적으로 원페이저는 프로젝트 발의나 기획 용도로 쓰이지만, 우리팀은 일의 과정과 최종 결과, 성과 측정까지 모든 것을 이 문서 하나에 담아왔습니다. 하지만 시간이 지날수록 본래의 목적을 잃고 무거워졌습니다. 기획서 링크, 디자인 피그마 링크, API 문서, Slack에서 오간 긴 논의들이 뒤섞여 내용은 방대해졌고, 정작 “이 기능을 왜 이렇게 구현했지?”라는 단순한 질문에도 여러 문서를 뒤져야 했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">그래서 먼저 1Pager를 가볍게 만드는 시도를 했습니다. 작업 목록을 나열하는 대신 ‘문제–해결–결과’ 중심으로 핵심만 남기도록 서식을 개편했습니다. 작업이 모두 끝난 시점에 회고하듯 정리하는 이 방식은 한동안 잘 작동했고, 실제로 가독성도 꽤 좋아졌습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">하지만 여러 차례 개편을 거치면서 오히려 더 명확해진 한계가 있었습니다. 1Pager는 ‘작업 요약’을 남기기에는 적합하지만, ‘왜 그런 기술적 선택을 했는가’를 남기기에는 맞지 않았습니다. 아키텍처 변경, 라이브러리 도입, 도메인 복잡도에 따른 기술적 타협 같은 결정들은 결과보다 문제의 배경과 고민의 흐름을 온전히 담은 ‘맥락’이 훨씬 중요합니다. 하지만 성과 보고 중심의 1Pager 틀 안에서는 그 치열했던 고민의 과정들이 자주 생략되곤 했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이 지점에서 우리는 Architectural Decision Record(ADR)이라는 새로운 방식을 도입하게 됩니다. ADR은 이름 그대로 기술적 판단과 맥락을 기록하는 데 최적화된 도구입니다. 이 형식을 팀에 맞게 다음과 같이 정의하여 사용하고 있습니다.</p>
<ul style="margin-bottom: 24px;line-height: 1.75">
<li><b>Context (맥락)</b>: 어떤 문제 상황에서 논의가 시작되었는가?</li>
<li><b>Decision (결정)</b>: 여러 선택지 중 무엇을 선택했고, 그 이유는 무엇인가?</li>
<li><b>Consequences (결과)</b>: 그 결정으로 얻는 이득과 감수해야 할 비용은 무엇인가?</li>
<li><b>Retrospective (회고)</b>: 진행하며 얻은 인사이트나 교훈은 무엇인가?</li>
</ul>
<figure style="text-align: center;margin: 30px 0"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/SCR-20251210-mtaf.png" alt="" class="size-medium wp-image-24840" style="max-width: 100%;height: auto"><figcaption style="font-size: 13px;color: #999;margin-top: 8px">출처: 생성형 AI 이미지, Gemini</figcaption></figure>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">하나의 의사결정이 하나의 문서로 독립되어 남기 때문에 시간이 지나도 당시의 고민을 그대로 복기할 수 있습니다. 기존 문서를 덮어쓰는 대신 새로운 ADR을 차곡차곡 쌓는 방식 덕분에 의사결정의 히스토리를 자연스럽게 추적할 수 있게 되었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">결국 1Pager 사용을 공식적으로 종료하고 ADR 기반의 기록 방식으로 완전히 전환했습니다. 흩어져 있던 기록의 파편들이 ADR이라는 체계 안에서 정리되었고, 이제 기술적 흐름을 팀 전체가 같은 시각으로 바라볼 수 있게 되었습니다. 기록은 더 이상 의무적으로 작성하는 귀찮은 문서가 아니라, 미래의 우리에게 길을 안내하는 팀의 기억 장치가 되었습니다.</p>
<h3 style="margin-top: 50px;margin-bottom: 15px;font-size: 20px;font-weight: bold">우리는 귀찮음을 레거시로 남기지 않습니다: 자동화</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">자동화는 그저 편함을 쫓는 작업이 아닙니다. 반복적인 입력과 수작업을 줄여 사람이 해야 할 판단과 문제 해결에 집중할 수 있는 환경을 만들어내는 과정입니다. 반복 업무는 하루 단위로 보면 사소해 보이지만, 쌓이면 팀 전체의 리듬을 끊고 실수를 유발하며 중요한 순간의 대응 속도를 떨어뜨리는 부채가 됩니다. 그래서 “이 일을 굳이 사람이 계속해야 하나?”라는 질문이 나오면 주저 없이 자동화를 시도했습니다. 많은 자동화가 팀 속에 녹아 있지만 이 글에서는 대표적인 네 가지를 소개하고자 합니다.</p>
<h4 style="margin-top: 24px;margin-bottom: 12px;font-size: 18px;font-weight: bold">수기 입력을 최소화한 Jira 이슈 관리</h4>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">회사에서 이슈 관리 솔루션으로 사용하는 Jira는 강력한 도구지만, 관리 자체가 또 다른 업무처럼 느껴지는 때가 많았습니다. 시작일, 종료일, 릴리즈 연동, Story Point 등 다양한 필드는 모두 중요하지만 이를 매번 사람이 직접 입력하는 과정은 불필요한 에너지 소모를 일으켰습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이를 해결하기 위해 Jira Automation을 도입했습니다. 작업자가 티켓을 ‘완료’ 상태로 변경하면 시스템이 종료일을 자동으로 기록하고, Story Point를 기입하면 예상 일정을 계산해 줍니다. 릴리즈 날짜를 지정하는 순간 해당 날짜의 릴리즈 버전이 생성되기도 합니다. 또한, 기한이 지난 티켓 목록은 주기적으로 Slack DM으로 알림이 발송되어 놓치는 업무 없이 챙길 수 있도록 돕습니다. 자세한 흐름은 다음의 기술블로그를 통해 확인하실 수 있습니다 <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /><a href="https://techblog.woowahan.com/23377">Jira Automation으로 반복 업무를 효율적으로 관리해보자 | 우아한형제들 기술블로그</a></p>
<h4 style="margin-top: 24px;margin-bottom: 12px;font-size: 18px;font-weight: bold">담당자를 스스로 찾아가는 장애 알림 시스템</h4>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">장애를 감지하는 속도도 높였습니다. 모니터링 도구인 센트리(Sentry)를 최적화하여 특정 레벨 이상의 에러가 발생하면 즉시 팀 Slack 채널로 알림을 전송하고, 담당 파트를 자동으로 멘션하도록 구성했습니다. 덕분에 장애 발생 시 “누가 이거 확인할 수 있을까요?”라고 묻고 답하느라 허비하던 시간을 없애고 담당자가 즉시 문제를 인지하고 해결에 뛰어들 수 있게 되었습니다. 자세한 내용은 아래 기술블로그에서도 확인할 수 있습니다 <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /><a href="https://techblog.woowahan.com/21604/">선제적 장애 대응을 위한 Sentry 최적화 적용기 | 우아한형제들 기술블로그</a></p>
<h4 style="margin-top: 24px;margin-bottom: 12px;font-size: 18px;font-weight: bold">골든타임을 사수하는 원터치 장애 선포</h4>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">장애 대응 프로세스 중 장애 선포 과정에서도 자동화는 큰 역할을 합니다. 긴박한 상황에서 절차를 챙기는 건 쉽지 않습니다. 이제는 팀 채널에서 /선포 또는 /장애선포를 입력만 하면 회사 표준 포맷에 맞는 장애 채널이 생성되고 유관 부서 담당자들이 자동으로 초대됩니다. 1분 1초가 중요한 장애 상황에서 이 자동화는 대응의 속도와 정확도를 크게 개선하는 데 도움을 주었습니다.</p>
<h4 style="margin-top: 24px;margin-bottom: 12px;font-size: 18px;font-weight: bold">배포 안정성을 높이는 릴리즈 노트 자동화</h4>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">최근에는 배포 과정에도 자동화를 더했습니다. Jira 티켓에 배포 날짜가 지정되면 그 날짜를 기반으로 릴리즈 플랜 문서가 자동으로 생성됩니다. 이 문서는 배포 전 점검해야하는 항목을 구조화해서 보여주기 때문에, 담당자가 부재중이거나 급하게 배포해야 할 때에도 어떤 항목을 검토하고 유사시 어떻게 롤백해야 하는지 직관적으로 파악할 수 있어 배포 안정성을 크게 높였습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이 모든 자동화는 반복은 기계에게 맡기고, 사람은 더 중요한 고민을 하자는 단순한 의지에서 출발했습니다. 작은 시도들이 모여 팀의 업무 흐름은 가벼워졌고, 우리는 더 가치 있는 문제 해결에 에너지를 쏟을 수 있게 되었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 48px">하지만 좋은 도구와 시스템만으로는 충분하지 않습니다. 자동화로 아낀 시간을 무엇으로 채울지, 리팩토링한 구조 위에서 어떻게 협업할지를 결정하는 것은 결국 &#8216;사람&#8217;과 &#8216;문화&#8217;이기 때문입니다. 효율적인 시스템이 &#8216;잘 달릴 수 있는 도로&#8217;라면 그 위를 달리는 것은 실패를 두려워하지 않고 핸들을 꺾어보는 팀원들의 &#8216;마음가짐&#8217;입니다. 커머프팀이 변화를 지속할 수 있었던 진짜 동력은 이러한 시스템 위에서 끊임없이 새로운 시도를 멈추지 않은 &#8216;도전적인 문화&#8217;에 있습니다. 물론 새로운 시도는 언제나 예상과 다른 결과를 만들 수 있고 모든 선택이 항상 최적의 답으로 이어지지는 않습니다.</p>
<h2 style="margin-top: 80px;margin-bottom: 40px;font-size: 24px;font-weight: bold">실패가 아니라 과정입니다</h2>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">그럼에도 커머프팀은 그런 시행착오를 ‘실패’로 단정 짓기보다는 더 나은 방향을 찾기 위한 과정의 일부로 받아들이고 있습니다. 다만 시도에는 언제나 명확한 목적과 근거가 필요하며, 결과에 대해서도 팀이 함께 책임지고 회고합니다. 이렇게 쌓인 경험들이 결국 팀의 기준이 되고 다음 선택을 더 단단하게 만드는 자산이 되고 있다고 믿습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">우리는 팀이 심리적으로 안전한 울타리가 되어야 한다고 생각합니다. 반대 의견을 냈다고 눈치를 보지 않아도 되고, 실수를 했다고 위축되지 않아도 되며, 당당하게 모른다고 말할 수 있는 분위기가 기본이 되었으면 합니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">다만 이러한 튼튼한 울타리 안에서 가만히 머무는 팀이 되는 것은 경계합니다. 안전함에 안주하지 않고, 편안함에 정체되지 않도록 서로가 서로에게 건강한 자극이 되는 팀이 되고자 합니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">“이 구조가 정말 최선일까”, “새롭게 시도해볼 수는 없을까”</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이런 질문들을 누구든 가볍게 던질 수 있고 누구라도 가볍게 흘려보내지 않는 팀이 되기 위해, 의도적으로 함께 성장하고 함께 실험하는 구조를 만들고 있습니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">질문이 스터디가 되는 팀</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이처럼 업무를 하다 자연스럽게 생긴 기술적인 고민들과 문제 의식을 팀 전체로 끌어올리고, 함께 해결해나가는 구조를 만들기 위해 정기적으로 주제들을 모아서 팀 스터디를 진행하고 있습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">실제로 한 번은 팀 내에서 인프라 구조와 비용에 대한 이해가 충분하지 않다는 공감대가 형성된 적이 있었습니다. 현재 우리의 구조가 최선인지, 합리적인 비용을 사용하고 있는지 자신있게 설명하기 어려운 순간들이 반복되었기 때문입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이러한 문제를 개인의 학습 과제로 남기지 않고, 팀 전체의 과제로 인식하여 AWS 스터디를 진행했습니다. 단순히 스터디를 진행하는 것을 넘어 우리가 사용하는 인프라 구조를 살펴보고, 더 나은 대안이 없을지 검토하며, 비용 청구서를 기반으로 더 비용을 절감할 수 있는 방법을 탐구했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">그 결과, 인프라 구조에 대한 관점이 한층 단단해질 수 있었고 불필요한 비용 사용을 자체적으로 절감할 수 있었습니다. 이러한 변화는 단순한 학습을 넘어 스터디에 참여한 멤버 전원이 AWS 자격증을 취득할만큼 각자의 전문성을 끌어올리는 계기가 되었습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">물론 스터디의 결과물이 항상 자격증일 필요는 없습니다. 때로는 백오피스 서비스에 대한 이해를 높이기 위해 함께 모여 토론의 장을 열기도 하고, 데이터 분석 역량 강화를 위한 쿼리 작성 스터디가 자연스럽게 이루어지기도 합니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">이 모든 시도는 우리가 더 일을 잘하는 팀이 되기 위한 과정이며, 편안함에 머무르지 않기 위한 선택입니다. 개인의 노력이 모여서 팀의 기반이 되고, 그 기반이 다시 새로운 방향성을 만들어냅니다.</p>
<h3 style="margin-top: 30px;margin-bottom: 15px;font-size: 20px;font-weight: bold">조금 더 단단한 팀으로</h3>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">커머프팀은 팀이라는 울타리가 제공하는 심리적 안전감(Psychological Safety)을 바탕으로 각자가 마음껏 도전하고 실패해볼 수 있는 환경을 만드는 것을 중요하게 생각합니다. 아이디어를 내는 것에서 그치지 않고 직접 적용해보고 시행착오를 겪는 경험이 성장을 만든다고 믿기 때문입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">누구나 자유롭게 불판을 통해 기술 토론을 제안할 수 있고, 스터디를 통해 함께 성장하며 배운 것을 실제 서비스에 옮겨볼 수 있습니다. 저희는 이 옮겨보는 과정 자체를 소중하게 여깁니다. 아이디어를 떠올리고 가능성을 검토하는 것까지는 비교적 쉽지만, 실제로 서비스에 적용해보는 과정에서 마주하는 수많은 변수와 문제를 몸으로 겪어보는 경험은 훨씬 값지기 때문입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">그래서 커머프팀에서는 누군가의 작은 문제의식이 바텀업 기술 과제로 이어지고, 하나의 아이디어가 TF로 확장되며, 그 시도들이 다시 서비스 개선으로 연결되는 흐름이 자연스럽게 만들어집니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">팀이 만들어진 이후 팀원들은 커머스 서비스의 성능과 안정성을 높이기 위한 수많은 시도를 이어왔습니다. 그 치열했던 과정과 배움은 우아콘 세션을 통해 공유하기도 했습니다.</p>
<ul style="margin-bottom: 24px;line-height: 1.75">
<li>대규모 트래픽 환경에서의 성능개선 경험: <a href="https://youtu.be/vW8bQCA1pQI?si=o623GYW94l4lLoO1">장보기⋅쇼핑 성능 최적화 고군분투기</a></li>
<li>품질을 지키는 자동화 전략: <a href="https://youtu.be/htXJO3LscXA?si=xX89FQg-cEvFaAbw">로그 회귀 테스트 구축 세션</a></li>
</ul>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">또한, 우리가 마주한 구체적인 문제 해결 과정과 새로운 시도들은 기술블로그를 통해 꾸준히 기록하며 공유해 왔습니다.</p>
<ul style="margin-bottom: 24px;line-height: 1.75">
<li>장애를 보다 빠르게 감지하고 대응하기 위한 <a href="https://techblog.woowahan.com/21604/">Sentry 재정비</a></li>
<li><a href="https://techblog.woowahan.com/24605/">접근성 개선</a>하기</li>
<li>웹과 네이티브의 공존을 위한 <a href="https://techblog.woowahan.com/24165/">플로팅웹뷰 기술 도전</a></li>
<li>개발과 디자인 사이의 협업 방식을 개선하기 위한 <a href="https://techblog.woowahan.com/21850/">디자인옵스 TF 활동</a></li>
<li>팀의 업무 효율을 개선하기 위한 <a href="https://techblog.woowahan.com/23377/">자동화 여정</a></li>
</ul>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">모든 시도들이 항상 성공적이었던 것은 아닙니다. 기대만큼 효과를 내지 못한 경우도 있었고, 되돌려야 했던 선택도 있었습니다. 그럼에도 이 시도들이 의미있었던 이유는 성공 여부와 관계없이 그 모든 경험이 팀의 자산으로 남았기 때문입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">우리는 결과만을 남기기보다 그 과정에서 어떤 판단을 했고 왜 그런 선택을 했는지를 더 중요하게 돌아봅니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">그러한 고민들이 차곡차곡 쌓여 팀의 기준은 점점 더 단단해졌고, 선택의 순간마다 참고할 수 있는 경험의 두께도 자연스럽게 두터워졌습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 48px">이 경험들이 모여 팀이라는 울타리를 단단하게 만들고 있다고 믿습니다.</p>
<h2 style="margin-top: 80px;margin-bottom: 40px;font-size: 24px;font-weight: bold">마무리: 오늘의 정답이 내일의 레거시가 되지 않도록</h2>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">지금까지 커머프팀이 걸어온 문화 리팩토링의 여정을 소개해 드렸습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">우리는 경직된 조직 구조를 경계 없는 파트로 리팩토링하여 유연한 아키텍처를 확보했고, 지식의 깊이를 더하는 ADR과 반복을 줄이는 자동화를 통해 시스템의 효율을 높였습니다. 또한 비대해진 소통 비용을 줄이기 위해 “불판”과 “코질라”라는 새로운 프로토콜을 도입했습니다. 그리고 이 모든 변화가 두려움 없이 지속될 수 있도록 “심리적 안전감”이라는 테스트 환경을 구축했습니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">물론 공유한 이 방식들이 모든 팀의 정답은 아닐 것입니다. 심지어 우리 팀에게조차 영원한 정답은 아닙니다. 팀의 규모가 더 커지거나 비즈니스 상황이 변하면, 지금 우리가 자랑스럽게 여기는 R&amp;E 문화나 비동기 소통 방식도 언젠가는 걷어내야 할 레거시가 될지 모릅니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">하지만 이 과정을 통해 확인한 변하지 않는 사실이 하나 있습니다. 바로 마치 좋은 코드가 시스템을 견고하게 지탱하듯 건강한 문화가 팀을 지탱한다는 것입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">그렇기에 우리는 앞으로도 멈추지 않을 것입니다. 끊임없이 팀이라는 코드를 들여다보고, 비효율이라는 버그를 찾아내고 더 나은 구조로 개선해 나갈 것입니다. 코드 품질을 지속적으로 관리하듯이 우리의 문화도 매일 조금씩 더 나은 방향으로 지속적 배포(Continuous Deployment) 를 이어갈 것입니다.</p>
<p style="text-align: left;line-height: 1.75;margin-bottom: 24px">지금 이 순간에도 조직의 성장통으로 고민하고 계신 분들이 있다면 거창한 개편이 아니어도 좋습니다. 팀을 무겁게 만드는 “문화 부채”가 무엇인지 찾아보는 작은 회고부터 시작해보는 건 어떨까요? 커머프팀의 문화 리팩토링 여정이 여러분의 팀을 디버깅하는 데 작은 힌트가 되었기를 바랍니다.</p>
</div>The post <a href="https://techblog.woowahan.com/24820/">우리는 코드처럼 문화도 리팩토링한다</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></content:encoded>

					<wfw:commentRss>https://techblog.woowahan.com/24820/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>


			</item>
		<item>
		<title>잃어버린 접근성을 찾아서</title>
		<link>https://techblog.woowahan.com/24605/</link>
					<comments>https://techblog.woowahan.com/24605/#respond</comments>

		<dc:creator><![CDATA[이주암]]></dc:creator>
		<pubDate>Fri, 05 Dec 2025 06:20:00 +0000</pubDate>
				<category><![CDATA[Frontend]]></category>
		<guid isPermaLink="false">https://techblog.woowa.in/?p=24605</guid>

					<description><![CDATA[<p>개발한 서비스의 접근성을 직접 확인해 보신 적 있나요? 바쁜 일정 속에 각종 요구사항을 반영하다 보면, 접근성은 흔히 &#8216;언젠가 챙겨야 할 착한 일&#8217; 정도로 치부되곤 합니다. 부끄럽지만 저희도 마찬가지였습니다. 그러나 접근성을 소홀히 하면 실제 사용 과정에서 예상보다 큰 불편이 생길 수 있습니다. 가령 상품을 구매하고자 화면을 수백 번 터치해야 한다면, 과연 그 서비스를 정상적인 서비스라고 부를 [&#8230;]</p>
The post <a href="https://techblog.woowahan.com/24605/">잃어버린 접근성을 찾아서</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></description>
										<content:encoded><![CDATA[<p>개발한 서비스의 접근성을 직접 확인해 보신 적 있나요? 바쁜 일정 속에 각종 요구사항을 반영하다 보면, 접근성은 흔히 &#8216;언젠가 챙겨야 할 착한 일&#8217; 정도로 치부되곤 합니다. 부끄럽지만 저희도 마찬가지였습니다.</p>



<p>그러나 접근성을 소홀히 하면 실제 사용 과정에서 예상보다 큰 불편이 생길 수 있습니다. 가령 상품을 구매하고자 화면을 수백 번 터치해야 한다면, 과연 그 서비스를 정상적인 서비스라고 부를 수 있을까요?</p>



<p>웹의 창시자 &#8216;팀 버너스 리(Tim Berners-Lee)&#8217;는 이렇게 말했습니다.</p>



<blockquote class="wp-block-quote is-layout-flow wp-block-quote-is-layout-flow">
<p>&#8220;웹의 힘은 보편성에 있습니다. 장애에 상관없이 모두가 접근할 수 있다는 것이 가장 중요한 부분입니다.&#8221;</p>
</blockquote>



<p>보편성을 지키지 못한다면 우리 서비스는 누군가에게 아예 사용 불가능한 무용지물이나 다름없습니다.</p>



<p>이 글은 접근성 준수라는 숙제를 하려다, &#8216;사용 불가능한 수준의 사용자 경험&#8217;을 마주하고 이를 뜯어고친 치열한 개선기입니다. </p>



<p>웹 접근성의 영역은 넓고 방대하지만 이번 작업에서는 스크린 리더 사용자들의 경험에 집중했습니다. 스크린 리더의 실제 발화를 기준으로 상품 상세 페이지의 접근성을 어떻게 개선했는지 소개하겠습니다.</p>



<blockquote class="wp-block-quote is-layout-flow wp-block-quote-is-layout-flow">
<p>스크린 리더란?<br>Android의 TalkBack, iOS의 VoiceOver 등의 접근성 지원 도구입니다.<br>좌우 스와이프로 요소를 하나씩 탐색하며 음성으로 읽어줍니다.</p>



<p>참고: 이 글의 스크린 리더 발화 예시는 iOS VoiceOver를 기준으로 작성되었습니다.</p>
</blockquote>



<h2 class="wp-block-heading">구매하기 버튼까지 300번 이상 스와이프했습니다</h2>



<p>Lighthouse를 이용해 측정한 상품 상세 페이지의 접근성 점수는 60~70점으로 좋은 점수는 아니었지만, 버튼에 aria-label을 추가하거나 이미지에 alt 속성을 넣는 등 널리 알려진 방법만으로도 90점 이상의 점수를 받을 수 있었습니다. 하지만 실제로도 개선된 걸까요?</p>



<blockquote class="wp-block-quote is-layout-flow wp-block-quote-is-layout-flow">
<p>Lighthouse란?<br>구글에서 개발한 웹 페이지 품질 측정 자동화 도구입니다. 성능(Performance), 접근성(Accessibility), SEO 등 5가지 핵심 영역을 점검하여 0~100점의 점수로 환산해 줍니다.</p>
</blockquote>



<p>눈을 가리고 스크린 리더만을 사용해서 상품을 구매해 보겠습니다.</p>



<p class="has-text-align-center has-medium-font-size"><strong>두둥!</strong></p>


<div class="wp-block-image size-medium wp-image-24618 is-style-default">
<figure class="aligncenter"><img loading="lazy" decoding="async" width="402" height="750" src="https://techblog.woowa.in/wp-content/uploads/2025/12/접근성_개선_01-402x750.png" alt="" class="wp-image-24618" srcset="https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_01-402x750.png 402w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_01-466x870.png 466w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_01.png 560w" sizes="(max-width: 402px) 100vw, 402px" /><figcaption class="wp-element-caption">상품 상세 페이지 스크린 리더 발화 일부</figcaption></figure></div>


<p>휴대기기에서 스크린 리더로 테스트해 본 결과는 충격적이었습니다.</p>



<p>기기마다 사소한 차이는 있었지만, 사용자 흐름의 종점이 되는 구매하기 버튼까지 300번 이상의 스와이프 동작이 필요했습니다. 탐색 도중 궁금하지 않은 내용이 있어도 스와이프하며 꼭 지나가야 했고, 이는 상당한 피로감을 유발했습니다.</p>



<p>또한 한 번에 읽혀야 할 텍스트가 분리되어 읽혔습니다. “990원”으로 읽히는 게 아니라 “990”과 “원”으로 나뉘어 읽힌다면 스크린 리더 사용자들에게 추가적인 스와이프 동작이 필요할 뿐만 아니라, 맥락을 파악하기도 어려워집니다.</p>



<p>버튼을 읽을 때 역할이 불분명하다는 문제도 있었습니다. 예를 들어 “배달팁 자세히 보기” 버튼이 단순히 버튼으로만 읽혀 어떤 동작을 하는지 알 수 없었습니다.</p>



<p>정리하면 아래와 같습니다.</p>



<ul class="wp-block-list">
<li>피로한 탐색: 모든 요소를 탐색해야 해서 시간이 오래 걸림</li>



<li>파편화된 발화: 함께 읽혀야 할 텍스트가 따로 읽혀 맥락 파악이 어려워짐</li>



<li>모호한 역할: 버튼에 역할이 명시되어 있지 않아 어떤 동작을 하는지 알 수 없음</li>
</ul>



<p>공통으로 시각을 활용한 탐색과 스크린 리더를 통한 탐색 경험에 큰 차이가 발생한다는 문제가 있었습니다.</p>



<p>이를 해결하기 위한 여정을 떠나봅시다.</p>



<h2 class="wp-block-heading">접근성을 되찾는 여정</h2>



<h3 class="wp-block-heading">1. 탐색 단위 만들기: 랜드마크와 머리말</h3>



<p>스크린 리더에는 강력한 탐색 기능이 있습니다. iOS VoiceOver는 &#8216;로터(Rotor)&#8217;, Android TalkBack은 &#8216;단위 탐색&#8217;이라는 기능으로 랜드마크와 머리말 단위로 빠르게 이동할 수 있습니다.</p>



<blockquote class="wp-block-quote is-layout-flow wp-block-quote-is-layout-flow">
<p>랜드마크란?<br>페이지의 주요 영역(헤더, 메인, 내비게이션, 푸터, 섹션 등)을 표시합니다. 랜드마크를 사용하면 스크린 리더 사용자가 원하는 영역을 빠르게 탐색할 수 있게 해주는 일종의 &#8216;페이지 내 지도&#8217; 역할을 합니다.</p>
</blockquote>



<p>하지만 우리 페이지에는 적절한 랜드마크와 머리말 구조가 없어서 사용자는 오직 순차 탐색만 가능했습니다. 책에서 원하는 내용을 찾으려고 할 때 목차 없이 첫 페이지부터 한 줄씩 읽어야 하는 것과 같습니다.</p>



<p>이 문제를 해결하기 위해 페이지를 의미 있는 섹션으로 나누고, 각 섹션에 명확한 머리말을 배치했습니다.</p>


<div class="wp-block-image size-medium wp-image-24620">
<figure class="aligncenter"><img loading="lazy" decoding="async" width="750" height="169" src="https://techblog.woowa.in/wp-content/uploads/2025/12/접근성_개선_02-750x169.png" alt="" class="wp-image-24620" srcset="https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_02-750x169.png 750w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_02-870x196.png 870w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_02-768x173.png 768w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_02.png 1010w" sizes="(max-width: 750px) 100vw, 750px" /><figcaption class="wp-element-caption">섹션 구조 전후 비교</figcaption></figure></div>


<blockquote class="wp-block-quote is-layout-flow wp-block-quote-is-layout-flow">
<p>목록 요소를 사용할 때 주의할 점<br>VoiceOver에서는 list-style: none이 설정된 요소를 목록으로 인식하지 않기 때문에, CSS로 목록 마커를 제거했다면 role=&#8221;list&#8221;를 명시해야 합니다.</p>
</blockquote>



<p>이제 스크린 리더 사용자는 &#8220;다른 사람들이 함께 본 상품&#8221;, &#8220;혜택&#8221; 등 머리말 또는 랜드마크 단위로 주요 영역을 빠르게 이동할 수 있습니다.</p>


<div class="wp-block-image size-medium wp-image-24621">
<figure class="aligncenter"><img loading="lazy" decoding="async" width="750" height="685" src="https://techblog.woowa.in/wp-content/uploads/2025/12/접근성_개선_03-750x685.png" alt="" class="wp-image-24621" srcset="https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_03-750x685.png 750w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_03-870x794.png 870w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_03-768x701.png 768w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_03.png 1148w" sizes="(max-width: 750px) 100vw, 750px" /><figcaption class="wp-element-caption">개선 후 단위 탐색이 가능해졌어요</figcaption></figure></div>


<p>이런 구조를 페이지 전체에 일관되게 적용하기 위해 재사용 가능한 컴포넌트를 만들어 활용하고 있습니다. section + heading + aria-labelledby 조합을 매번 반복해서 작성할 필요 없이, 컴포넌트가 자동으로 처리해 줍니다.</p>


<div class="wp-block-image size-full wp-image-24626">
<figure class="aligncenter"><img loading="lazy" decoding="async" width="500" height="252" src="https://techblog.woowa.in/wp-content/uploads/2025/12/접근성_개선_04.png" alt="" class="wp-image-24626" /><figcaption class="wp-element-caption">공통 컴포넌트 예시</figcaption></figure></div>


<h3 class="wp-block-heading">2. 파편화된 텍스트 통합하기</h3>



<p>판매가 &#8220;990원&#8221;이 스크린리더에서는 &#8220;990&#8221;과 &#8220;원&#8221;으로 따로 읽혔습니다. 그 외에도 많은 텍스트들이 파편화되어 탐색을 위해 불필요한 스와이프 동작이 필요했습니다.</p>


<div class="wp-block-image size-medium wp-image-24627">
<figure class="aligncenter"><img loading="lazy" decoding="async" width="750" height="449" src="https://techblog.woowa.in/wp-content/uploads/2025/12/접근성_개선_05-750x449.png" alt="" class="wp-image-24627" srcset="https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_05-750x449.png 750w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_05-870x520.png 870w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_05-768x459.png 768w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_05.png 918w" sizes="(max-width: 750px) 100vw, 750px" /><figcaption class="wp-element-caption">분리되어 읽히는 텍스트 예시</figcaption></figure></div>


<p>위의 경우 템플릿 리터럴을 활용하는 것이 좋은 방법입니다. 템플릿 리터럴을 활용해 데이터 정보까지 하나의 문자열로 표현하면 스크린 리더가 자연스럽게 읽을 수 있습니다.</p>


<div class="wp-block-image">
<figure class="aligncenter"><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/접근성_개선_06.png" alt="" /></figure></div>


<p>하지만 스타일링 때문에 어쩔 수 없이 텍스트를 분리해야 하는 경우도 있습니다. 이럴 때는 시각적으로 보이지 않는 요소를 활용했습니다.</p>


<div class="wp-block-image wp-image-24629 size-full">
<figure class="aligncenter"><img loading="lazy" decoding="async" width="500" height="372" src="https://techblog.woowa.in/wp-content/uploads/2025/12/접근성_개선_07.png" alt="" class="wp-image-24629" /><figcaption class="wp-element-caption">스크린 리더 발화용 컴포넌트 활용</figcaption></figure></div>


<p>더는 스크린 리더가 텍스트를 분리해서 읽지 않아, 불필요한 스와이프가 줄고 내용 파악이 쉬워졌습니다.</p>



<blockquote class="wp-block-quote is-layout-flow wp-block-quote-is-layout-flow">
<p>왜 span에 aria-label을 사용하지 않았나요?<br>span이나 div 같은 일반 컨테이너에 aria-label을 사용하면 Android TalkBack에서는 정상 작동하지만, iOS VoiceOver에서는 무시됩니다.<br>aria-label은 버튼, 링크 같은 대화형 요소, 랜드마크, 이미지 등에서만 지원되기 때문입니다. 다양한 환경에서 일관된 경험을 제공하기 위해 NoScreen 컴포넌트와 aria-hidden을 조합한 방법을 선택했습니다.</p>
</blockquote>



<h3 class="wp-block-heading">3. 상호작용 요소의 역할 명확히 하기</h3>



<p>상품 상세 페이지 내 많은 버튼이 &#8220;버튼&#8221;이라고만 읽히거나, 맥락 없이 &#8220;전체 보기&#8221;, &#8220;자세히&#8221;로만 읽혔습니다. &#8220;무엇을&#8221; 전체 보기 하는지, &#8220;무엇을&#8221; 자세히 보는지 설명을 추가하여 명확한 맥락을 제공했습니다.</p>


<div class="wp-block-image size-medium wp-image-24630">
<figure class="aligncenter"><img loading="lazy" decoding="async" width="750" height="207" src="https://techblog.woowa.in/wp-content/uploads/2025/12/접근성_개선_08-750x207.png" alt="" class="wp-image-24630" srcset="https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_08-750x207.png 750w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_08-870x240.png 870w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_08-768x212.png 768w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_08.png 913w" sizes="(max-width: 750px) 100vw, 750px" /><figcaption class="wp-element-caption">버튼 요소 aria 속성 적용 전후 비교</figcaption></figure></div>


<p>토글 버튼도 문제였습니다. 스크린 리더가 찜하기 버튼의 현재 찜한 상태에 대한 정보를 알 수 없었습니다. aria-pressed를 사용하여 토글 버튼의 상태를 스크린 리더에게 알려줬습니다.</p>


<div class="wp-block-image size-medium wp-image-24631">
<figure class="aligncenter"><img loading="lazy" decoding="async" width="750" height="460" src="https://techblog.woowa.in/wp-content/uploads/2025/12/접근성_개선_09-750x460.png" alt="" class="wp-image-24631" srcset="https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_09-750x460.png 750w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_09-870x534.png 870w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_09-768x471.png 768w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_09.png 919w" sizes="(max-width: 750px) 100vw, 750px" /><figcaption class="wp-element-caption">토글 버튼에 aria 속성 적용 전후 비교</figcaption></figure></div>


<p>마찬가지로, 모달이나 바텀시트를 여는 버튼도 클릭했을 때 무슨 일이 일어날지 예측하기 어려웠습니다. aria-haspopup과 aria-expanded로 상태를 알렸습니다.</p>


<div class="wp-block-image size-medium wp-image-24632">
<figure class="aligncenter"><img loading="lazy" decoding="async" width="750" height="323" src="https://techblog.woowa.in/wp-content/uploads/2025/12/접근성_개선_10-750x323.png" alt="" class="wp-image-24632" srcset="https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_10-750x323.png 750w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_10-870x375.png 870w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_10-768x331.png 768w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_10.png 919w" sizes="(max-width: 750px) 100vw, 750px" /><figcaption class="wp-element-caption">팝업 요소 버튼 aria 속성 적용 전후 비교</figcaption></figure></div>


<p>마침내 스크린 리더 발화만으로 버튼의 역할과 동작을 알 수 있게 되었습니다.</p>



<h2 class="wp-block-heading">다시 찾은 접근성</h2>



<p>개선 작업 후 가장 극적인 변화는 탐색 횟수였습니다. 구매하기 버튼 도달까지 필요한 스와이프가 20회 미만으로 줄어들었습니다. 기존 대비 90% 이상의 개선이었습니다. 텍스트 발화와 상호작용 요소도 개선하면서 스크린 리더를 통한 탐색 경험이 시각적 탐색 경험과 한층 가까워졌습니다.</p>



<h2 class="wp-block-heading">개발자를 위한 접근성</h2>



<p>접근성 개선 작업은 스크린 리더 사용자를 위해 시작했습니다. 하지만 작업을 하고 나니 개발자에게도 다양한 이점이 있었습니다.</p>



<p>첫 번째로, 적절한 시맨틱 태그를 사용하니 코드를 읽는 것만으로 구조를 이해하기 쉬워졌습니다. 태그의 이름이 곧 해당 요소의 역할과 의미를 정의하기 때문입니다. &#8216;디자인을 위한 상자&#8217;에 불과했던 태그가 &#8216;데이터의 의미를 담는 그릇&#8217;이 되었습니다.</p>


<div class="wp-block-image size-medium wp-image-24633">
<figure class="aligncenter"><img loading="lazy" decoding="async" width="750" height="508" src="https://techblog.woowa.in/wp-content/uploads/2025/12/접근성_개선_11-750x508.png" alt="" class="wp-image-24633" srcset="https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_11-750x508.png 750w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_11-870x589.png 870w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_11-768x520.png 768w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_11.png 1010w" sizes="(max-width: 750px) 100vw, 750px" /><figcaption class="wp-element-caption">시맨틱 태그 적용 전후 비교</figcaption></figure></div>


<p>다음으로, 실제 사용자가 요소를 탐색하는 과정과 동일한 흐름으로 테스트할 수 있습니다. 기존의 className이나 data-testid 같은 선택자는 사용자의 경험과는 거리가 멀었던 것에 비해, 이를 role 기반으로 변경하여 더 의미 있는 테스트 코드를 작성할 수 있었습니다.</p>


<div class="wp-block-image size-medium wp-image-24634">
<figure class="aligncenter"><img loading="lazy" decoding="async" width="750" height="241" src="https://techblog.woowa.in/wp-content/uploads/2025/12/접근성_개선_12-750x241.png" alt="" class="wp-image-24634" srcset="https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_12-750x241.png 750w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_12-870x279.png 870w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_12-768x246.png 768w, https://techblog.woowahan.com/wp-content/uploads/2025/12/접근성_개선_12.png 1010w" sizes="(max-width: 750px) 100vw, 750px" /><figcaption class="wp-element-caption">접근성 개선 후 변경된 테스트 코드</figcaption></figure></div>


<h2 class="wp-block-heading">마치며</h2>



<p>접근성 개선, 어렵게 느껴지시나요?</p>



<p>저희도 처음엔 막연하고 어려운 일이라고 생각했습니다. 하지만 막상 시작해 보니 생각보다 어렵지 않았고, 몰랐던 지식을 많이 배웠습니다.</p>



<p>가장 인상 깊었던 것은 Lighthouse 점수를 맹신하면 안 된다는 점이었습니다. 점수가 높아도 실제로는 스크린 리더로 탐색하기 매우 어려울 수 있다는 걸 체험하고 나서야 깨달았습니다. 수백 번 스와이프를 직접 해보는 것만큼 문제의 심각성을 체감하게 해주는 건 없었습니다.</p>



<p>이번 작업을 통해 배운 내용은 가이드 문서로 작성했습니다. 시맨틱 태그 사용 가이드, ARIA 속성 적용 패턴, 코드 리뷰 시 접근성 체크리스트, 그리고 재사용할 수 있는 접근성 컴포넌트 예시까지 포함되어 있습니다.</p>



<p>접근성을 찾는 여정은 여기서 끝이 아닙니다. 이번 경험을 바탕으로 접근성 개선 작업을 다른 페이지로 확장할 예정입니다. 또한 효율적인 개발을 위한 접근성 테스트 자동화를 검토하고 있으며, 새로운 컴포넌트를 생성할 때부터 접근성이 고려되도록 AI를 위한 접근성 rule을 작성 중입니다.</p>



<p>이 글을 읽으신 여러분도 오늘 잠시 시간을 내어 휴대전화의 스크린 리더를 켜보시는 건 어떨까요? 매일 보던 익숙한 화면이 낯설게 느껴지는 순간, 그리고 그 안에서 다양한 문제들을 발견할 때 모두를 위한 웹을 만드는 첫걸음이 시작됩니다.<br>저희의 고민이 접근성을 개선하는 여러분의 여정에 작은 도움이 되기를 바랍니다.</p>The post <a href="https://techblog.woowahan.com/24605/">잃어버린 접근성을 찾아서</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></content:encoded>

					<wfw:commentRss>https://techblog.woowahan.com/24605/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>


			</item>
		<item>
		<title>기획부터 개발까지 전부 직접 했습니다 &#8211; 우테코 7기 크루 서비스 론칭!</title>
		<link>https://techblog.woowahan.com/24251/</link>
					<comments>https://techblog.woowahan.com/24251/#respond</comments>

		<dc:creator><![CDATA[서준수]]></dc:creator>
		<pubDate>Fri, 05 Dec 2025 02:00:26 +0000</pubDate>
				<category><![CDATA[Education]]></category>
		<guid isPermaLink="false">https://techblog.woowa.in/?p=24251</guid>

					<description><![CDATA[<p>우아한테크코스(이하 우테코)는 우아한형제들이 운영하는 10개월 과정 개발자 교육 프로그램입니다. 개발자 교육에서 기술만 배우면 될까요? 우테코는 소프트 스킬도 중요하게 생각하고 있습니다. 그래서 웹 백엔드, 웹 프론트엔드, 모바일 안드로이드와 같은 기술적인 과정뿐만 아니라 말하기와 글쓰기 교육을 같이 진행하고 있습니다. 커리큘럼은 5단계의 레벨로 구성되어 있는데요. 레벨 1, 2에서는 프로그래밍 기초와 프레임워크를 배우고, 레벨 3, 4에서는 기획부터 디자인, 개발까지 [&#8230;]</p>
The post <a href="https://techblog.woowahan.com/24251/">기획부터 개발까지 전부 직접 했습니다 – 우테코 7기 크루 서비스 론칭!</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></description>
										<content:encoded><![CDATA[<p>우아한테크코스(이하 우테코)는 우아한형제들이 운영하는 10개월 과정 개발자 교육 프로그램입니다. </p>
<p>개발자 교육에서 기술만 배우면 될까요? 우테코는 소프트 스킬도 중요하게 생각하고 있습니다. 그래서 웹 백엔드, 웹 프론트엔드, 모바일 안드로이드와 같은 기술적인 과정뿐만 아니라 말하기와 글쓰기 교육을 같이 진행하고 있습니다. 커리큘럼은 5단계의 레벨로 구성되어 있는데요. 레벨 1, 2에서는 프로그래밍 기초와 프레임워크를 배우고, 레벨 3, 4에서는 기획부터 디자인, 개발까지 모두 팀 내에서 자체적으로 해결해야 하는 팀 프로젝트를 진행합니다.</p>
<p>이러한 과정을 거치면서 다음과 같은 고민을 하게 됩니다.</p>
<ul>
<li>개발자인 내가 왜 기획을 해야 하지?</li>
<li>나는 디자인에 자신 없는데 왜 이걸 개발자가 해야 하지?</li>
<li>어떤 아키텍처를 도입하는 것이 좋을까?</li>
<li>아키텍처부터 고민하는 것이 좋은 방법일까?</li>
<li>왜 팀원들이 내 생각에 동조해 주지 않지?</li>
<li>왜 저 사람은 자기주장이 강할까?</li>
<li>etc.</li>
</ul>
<p>현업 개발자들이 보면 &#8216;허허 나도 저럴 때가 있었지&#8217; 하는 생각을 하지 않을까 싶습니다. 그리고 왜 개발자도 기획에 관여해야 하는지, 아키텍처 고민은 어떻게 도입하면 좋을지 경험을 통해 깨달은 바가 스쳐 지나갈 것이라고 생각합니다.</p>
<p>우테코 크루들도 마찬가지입니다. 이제는 경험했기 때문에 나름의 철학과 답을 찾았을 것이라고 믿습니다.</p>
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/7기_론칭_페스티벌_01-750x563.jpg" alt="" /></p>
<p>개발 경험도 열심히 갈고닦았습니다. 실제 사용자를 유치하고, 서비스를 운영하는 과정을 통해서 책이나 강의만으로 배울 수 없는 많은 경험을 했습니다. 2주 단위 스프린트로 운영되는 개발 프로세스, 모니터링 환경 구축, 배포 등 실무와 비슷한 경험을 통해 현장에 필요한 문제 해결 역량을 키웠습니다.</p>
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/7기_론칭_페스티벌_단체사진-750x423.jpg" alt="" /></p>
<p>그럼, 치열한 과정을 거쳐 탄생한 7기 크루들의 서비스를 한번 만나볼까요?</p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/픽잇_logo.png" alt="" /></p>
<h2>픽잇 서비스</h2>
<p>에드: &quot;오늘 뭐 먹지?&quot;<br />
머핀: &quot;난 다 좋아.&quot;<br />
에드: &quot;그럼 돈가스?&quot;<br />
슬링키: &quot;아 별로 안 당기는데…&quot;<br />
에드: &quot;햄버거?&quot;<br />
머핀: &quot;어제 먹었어.&quot;<br />
에드: &quot;따로 먹자.&quot;<br />
(픽잇이 없던 시절, 매일 겪던 점심시간의 대화..)</p>
<p>같이 식사할 때마다 &quot;아무거나&quot;라는 말 뒤에 숨겨진 기피 음식들, 다이어트 중이라 먹기 힘든 메뉴, 최근에 먹은 음식까지… 다양한 제약이 얽히다 보면 결국 소극적인 사람이 참고 말거나, 모두가 찜찜한 결정을 하게 됩니다.</p>
<p>픽잇(Pickeat)은 이런 고민을 줄이기 위해 만들어졌습니다. 모든 구성원의 취향과 제약을 반영해 ‘최적의 식사 선택’을 돕는 협업형 서비스입니다. 템플릿과 위치 정보를 바탕으로 식당을 자동 조회하고, 참여자들이 좋아하는/싫어하는 식당에 실시간으로 투표합니다.</p>
<p>회식이나 미팅처럼 반복되는 상황에서도, 매번 새로 의견을 모을 필요 없이 빠르게 결정할 수 있습니다. 이제 픽잇과 함께, 더 이상 &quot;아무거나&quot; 없는 식사 선택을 경험해 보세요.</p>
<h3>개발 후기</h3>
<p>여러 번의 데모데이와 홍보를 통해 실제 사용자 피드백을 받으며 매번 서비스의 방향을 조정했습니다. 생각보다 요구사항이 자주 바뀌었고, 프론트엔드는 UI를 갈아엎고, 백엔드는 도메인 구조를 다시 짜야 하는 순간들도 많았습니다. 처음 세웠던 기획이 끝까지 유지되는 경우가 오히려 드물었죠.</p>
<p>팀 내부에서도 의견이 엇갈릴 때가 많았지만, 그럴 때마다 빠르게 구현하고 실제 사용자 반응으로 방향을 다시 잡는 방식을 택했습니다. 이 과정을 반복하면서, 협업은 단순히 역할을 나누는 게 아니라 서로의 판단 기준을 맞추고, 사용자에게 더 나은 가치를 전달하기 위해 한 방향으로 나아가는 일이라는 걸 배웠습니다. 팀이 같은 방향을 바라보게 된 순간마다 서비스도 함께 성장했다고 생각합니다. 그래서인지, 완성된 결과보다 그 과정을 함께 만든 시간이 더 오래 기억에 남습니다.</p>
<h3>픽잇 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>픽잇에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://github.com/woowacourse-teams/2025-pick-eat/wiki">픽잇 소개글 보러 가기</a></p>
<h3>픽잇 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>픽잇 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://pickeat.io.kr">픽잇 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/보따리_logo.png" alt="" /></p>
<h2>보따리 서비스</h2>
<blockquote>
<p>중요한 순간, 물건 하나 놓쳐서 후회해 본 적 있으신가요?</p>
</blockquote>
<p><strong>보따리</strong>는 출근, 여행, 이사, MT, 캠핑, 출장 등 어떤 상황에서도 빠짐없이 짐을 챙길 수 있도록 돕는 <strong>체크리스트 서비스</strong>입니다. 템플릿 기반의 리스트 생성, 아이템 공유, 실시간 동기화 기능을 통해 사용자는 단 몇 번의 터치만으로 자신만의 ‘보따리’를 완성할 수 있습니다. &quot;잊지 말고 챙기자&quot;는 단순한 기능을 넘어, 보따리는 <strong>사용자의 기억을 대신 챙겨주는 동반자</strong>가 되는 것을 목표로 합니다.</p>
<h3>개발 후기</h3>
<p>보따리는 단순한 체크리스트 앱이 아니라 <strong>&quot;사용자의 기억을 대신 챙겨주는 서비스&quot;</strong>를 만들기 위한 도전이었습니다.</p>
<p>가장 기본이 되는 기능은 <strong>개인용 체크리스트</strong>입니다. 사용자가 출근, 여행, 이사, 캠핑 등 상황에 맞게 짐을 챙길 수 있도록 돕는 것이 보따리의 출발점이자 핵심 가치였습니다. 하지만 우리는 거기서 한 걸음 더 나아가고 싶었습니다.</p>
<p><strong>&quot;템플릿 기반 리스트 생성&quot;</strong>으로 누구나 손쉽게 상황별 보따리를 만들 수 있도록 했고 <strong>&quot;팀 보따리(실시간 협업 체크리스트)&quot;</strong> 기능을 통해 함께 짐을 챙기는 새로운 경험을 제안했습니다. 이를 구현하기 위해 단순한 기능 개발을 넘어 <strong>&quot;사용자가 실제로 잊지 않고 챙기게 되는 흐름은 무엇일까?&quot;</strong>를 끊임없이 고민했습니다.</p>
<p>템플릿 구조, 체크 상태 동기화, 알림 타이밍까지 모든 세부 요소를 사용자 경험 중심으로 다듬어 나갔습니다. 그 과정에서 깨달은 점은 명확했습니다. <strong>기술은 문제를 해결하는 도구일 뿐, 진짜 목표는 &#8216;사용자의 안심&#8217;이다.</strong> 보따리는 그 마음을 담아 완성된 결과물입니다.</p>
<p><strong>&quot;잊지 않고, 함께 챙기는 경험&quot;</strong><br />
이 문장이 우리가 개발 과정 내내 붙잡았던 보따리의 방향이었습니다.</p>
<h3>보따리 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>보따리에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://pine-amethyst-317.notion.site/238796fb6f2280f6bf29ea9a8921473f">보따리 소개글 보러 가기</a></p>
<h3>보따리 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>보따리 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://play.google.com/store/apps/details?id=com.bottari.bottari">보따리 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/커피빵_logo.png" alt="" /></p>
<h2>커피빵 서비스</h2>
<p>&quot;점심 커피 내기, 아직도 가위바위보로 하시나요?&quot;<br />
직장인이라면 점심시간에 한 번쯤 커피 내기를 해본 적 있을 거예요. 하지만 대부분 단순한 가위바위보로 정하다 보니, 재미도 긴장감도 부족하죠. 그래서 우리는 생각했습니다. &quot;커피 내기도 좀 더 재밌게 해보면 어떨까?&quot;</p>
<p>그렇게 탄생한 서비스가 &#8216;커피빵&#8217;입니다. 커피빵은 실시간 미니게임과 가중치 룰렛 시스템을 통해 누구나 즐겁게 커피 내기를 할 수 있도록 만들어졌습니다. 이제 친구들과, 팀원들과 함께 웃으면서 즐기는 커피 내기를 시작해 보세요.</p>
<h3>개발 후기</h3>
<p>커피빵 서비스를 개발하면서 즐겁기도 했지만, 많은 어려움도 겪었던 것 같습니다. 실시간 게임이라는 주제 자체가 도전적이었고, 웹소켓과 분산 환경은 팀 모두에게 생소한 영역이었습니다.</p>
<p>게임 밸런스를 맞추기 위해 룰렛 알고리즘을 여러 번 수정하는 일도 있었습니다. 그럼에도 끝에 가서는 사용자에게 재미있게 사용될 수 있을 만한 서비스인 커피빵을 만들어낼 수 있었습니다. 팀원들 모두 함께라서 가능했던 일이라고 생각하고 있습니다. 회의하면서 싸우기도 웃기도 했던 시간들, 우테코 크루들이 열심히 써주며 남겨준 피드백들, 실제로 재미있어하는 모습을 봤던 순간들이 모두 소중한 기억으로 남았습니다. 앞으로 어떤 도전이 닥쳐도 함께 해결할 수 있는 커피빵 팀이 되었으면 좋겠습니다.</p>
<h3>커피빵 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>커피빵에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://github.com/woowacourse-teams/2025-coffee-shout/blob/main/README.md">커피빵 소개글 보러 가기</a></p>
<h3>커피빵 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>커피빵 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://coffee-shout.com/">커피빵 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/봄봄_logo.png" alt="" /></p>
<h2>봄봄 서비스</h2>
<p>읽고 싶어서 구독했지만, 메일함 속에서 잊히는 뉴스레터들.<br />
&quot;언제 왔지?&quot; &quot;비슷한 소식은 없을까?&quot; &quot;메일함이 너무 지저분해…&quot;<br />
이런 생각 한 번이라도 해보셨다면, 봄봄에서 함께해보세요!</p>
<p>봄봄은 흩어진 뉴스레터를 한곳에 모아 읽고, 추천·하이라이트·메모까지 할 수 있게 만든 서비스입니다. 봄봄에서 발급한 이메일로 뉴스레터를 구독해 보세요. 복잡한 메일함 대신 뉴스레터 전용 공간에서 관리할 수 있습니다. 이제 막 뉴스레터에 관심을 갖는 분들은 봄봄에서 뉴스레터 읽는 습관을 형성해 보세요. 다양한 지표로 읽기 습관을 만들고 하이라이트 &amp; 메모로 지식을 가치화할 수 있습니다!</p>
<p>봄봄은 광고, 업무 등 여러 메일함에 흩어진 뉴스레터를 한 곳에서 체계적으로 관리하고 싶다는 패인 포인트에서 시작했습니다. 어떤 뉴스레터가 좋은지, 내 관심사에 맞는지 몰라서 구독을 망설이고 있는 분들을 위해 뉴스레터를 추천해 드리고 있어요! 또한 구독만 하고 쌓아두는 &#8216;수집가&#8217;가 아니라, 꾸준히 읽고 가치화하고 싶은 분들을 위해 다양한 지표를 제공하고 있습니다. 혼자 읽기보다 친구들과 함께 읽으며 동기를 부여받고, 가벼운 경쟁을 도모할 수 있도록 만들었습니다.</p>
<h3>개발 후기</h3>
<p>초기에 &quot;어떻게 하면 원하는 글을 더 빨리, 더 정확하게 찾게 할까?&quot;에 집중해 아키텍처를 단순하게 시작했고, 점진적으로 수집과 개인화 추천, &quot;이달의 독서왕&quot; 랭킹 기능을 붙여 나갔습니다.</p>
<p>론칭 과정에서 가장 큰 도전은 &quot;사용자가 정말로 원하는 흐름&quot;을 찾는 일이었습니다. 가입·초기 온보딩을 최대한 단순화하고, 다양한 분야에서 사용자가 뉴스레터를 골라 구독할 수 있도록 페이지를 구성했습니다. 하이라이트와 메모 기능을 통해 뉴스레터를 가치화할 수 있도록 도모했습니다. 내부·외부 피드백은 곧바로 다음 스프린트의 개선 목록으로 이어졌고, &quot;작게 출시하고 바로 고친다&quot;라는 리듬이 팀의 습관이 됐습니다. 앞으로는 발행사와의 협업을 넓히고, 주간 큐레이션과 읽기 루틴(연속 읽기, 리마인더)을 강화해 읽을 가치가 있는 콘텐츠를 더 빨리, 더 편하게 만날 수 있게 만들고자 합니다.</p>
<h3>봄봄 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>봄봄에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://guesung.notion.site/bombom?pvs=74">봄봄 소개글 보러 가기</a></p>
<h3>봄봄 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>봄봄 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /><br />
<a href="https://www.bombom.news/">봄봄 바로가기</a><br />
<a href="https://apps.apple.com/kr/app/%EB%B4%84%EB%B4%84/id6752014462">봄봄 iOS 바로가기</a><br />
<a href="https://play.google.com/store/apps/details?id=com.antarctica.bombom&amp;amp;pcampaignid=web_share">봄봄 Android 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/모잇지_logo.png" alt="" /></p>
<h2>모잇지 서비스</h2>
<p>모임을 잡았는데 정작 어디서 만날지에서 막힌 적 있지 않나요? 친구들과 &quot;중간이 어디지?&quot;를 헤매다 결국 강남·홍대 같은 익숙한 곳으로 타협하고, 후보를 고르느라 채팅방만 길어지곤 합니다. 스터디라면 조용한 카페가, 회식이라면 이동이 편한 번화가가 좋은데, 지도를 뒤지고 리뷰를 읽다 보면 어느새 밤이 됩니다. 그럴 때, 모잇지가 도와드릴게요.</p>
<p>모잇지는 함께 모이는 사람들의 출발지와 이동 경로, 그리고 모임의 목적을 함께 고려해, 모두에게 공평한 지하철 권역을 찾아드려요. 그리고 그 안에서 모임 분위기에 꼭 맞는 장소를 추천해 드릴게요. 스터디라면 집중하기 좋은 조용한 카페를, 회식이라면 이동이 편한 맛집을, 데이트라면 분위기 있는 공간을 제안하죠. 또한 각자의 출발지에서 추천 지역까지의 지하철 이동 경로와 소요 시간도 한눈에 확인할 수 있고, 누가 더 멀리 이동해야 하는지 쉽게 비교할 수 있습니다. 스터디, 팀 회식, 동아리 번개, 이제 &quot;어디서 볼까?&quot; 대신 &quot;몇 시에 볼까?&quot;만 정하세요.</p>
<h3>개발 후기</h3>
<p>&quot;모임 장소 정하기, 왜 이렇게 복잡할까?&quot;<br />
모잇지는 이 단순한 물음에서 출발했습니다. 처음엔 &#8216;중간 지점을 계산해 주는 간단한 서비스&#8217;를 상상했지만, 막상 만들어보니 문제는 훨씬 더 복잡했습니다. 단순히 위치를 계산하는 것을 넘어, 모든 사용자가 공평하게 이동할 수 있는 장소를 찾고, 그 장소가 목적에도 어울려야 한다는 조건이 따라왔기 때문이죠.</p>
<p>그래서 모잇지는 단순한 약속 장소 추천이 아닌, &quot;신뢰할 수 있는 결과를 빠르게 전달하기 위한 기술 실험장&quot;이 되었습니다. 초기엔 LLM에 의존했지만, 점차 더 정확한 결과를 위해 로직을 직접 구현하며 의존도를 줄였습니다. AI가 제시한 결과를 검증하고, 외부 API 데이터를 결합해 사람이 믿을 수 있는 추천을 만드는 데 집중했습니다. API 호출 제한과 응답 지연, 예외 처리 등 예상치 못한 문제들도 많았습니다. 그때마다 API의 특성을 이해하고, 장애에 대비한 시스템을 설계하며 서비스의 안정성을 높였습니다.</p>
<p>기술적인 문제만큼 어려웠던 건 팀의 방향을 하나로 맞추는 일이었습니다. &quot;공평함이란 무엇일까?&quot;, &quot;좋은 장소의 기준은 뭘까?&quot; 같은 질문에 대해 모두가 각자의 시선으로 답했습니다. 끊임없는 논의와 조율 끝에 각자의 아이디어가 기능으로 구현되는 과정을 경험하며, 우리는 기술 이상으로 팀워크를 배웠습니다.</p>
<p>결국 모잇지가 남긴 가장 큰 배움은 이것이었습니다. 기술은 문제 해결의 도구이며, 궁극적으로는 사용자가 믿을 수 있는 경험을 만드는 수단이라는 것. 그 믿음을 지키려 한 노력들이 모잇지를 기능적으로도, 기술적으로도 한층 단단하게 만들었습니다.</p>
<h3>모잇지 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>모잇지에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://www.notion.so/294b5a1edfe480649bf6d65ae41fa027">모잇지 소개글 보러 가기</a></p>
<h3>모잇지 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>모잇지 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://moitz.kr/">모잇지 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/토독토독_logo.png" alt="" /></p>
<h2>토독토독 서비스</h2>
<p>우리는 좋은 개발자의 답을 책에서 많이 찾아요. 하지만 기술 서적을 읽다 보면 이런 생각이 들 때도 있어요.<br />
&quot;이 부분은 왜 이렇게 설명했을까?&quot; &quot;저자의 의도는 알겠는데, 실무에서는 어떻게 적용해야 하지?&quot; &quot;북 스터디를 만들지 않아도 책에 대해 맘껏 얘기할 동료 개발자가 필요해.&quot;</p>
<p>책 속 문장을 곱씹어 보지만, 결국 혼자서는 명확히 이해하기 어렵고 함께 이야기할 개발자도 마땅치 않은 순간이 많습니다. 그래서 우리는 토독토독을 만들었습니다. 토독토독은 개발자들이 기술 서적을 함께 읽고 토론하는 모바일 서비스입니다. 읽은 책을 바탕으로 궁금한 점을 올리고, 다른 개발자들의 생각을 들어보며, 관심 있는 키워드로 토론을 찾아볼 수 있습니다.</p>
<p>혼자 책을 읽을 땐 놓쳤던 인사이트가, 함께 토론할 땐 명확한 이해로 이어질 거예요. 토독토독과 함께, 책을 넘기는 시간을 생각의 대화로 바꿔보세요.</p>
<h3>개발 후기</h3>
<p>단순한 커뮤니티라도 사용자의 특성과 도메인에 맞는 편의성을 고민하며 개선하다 보면, 그 자체로 차별화된 서비스가 될 수 있다는 것을 직접 경험했습니다. 우리가 &#8216;개발자라면 어떤 서비스를 쓰고 싶을까&#8217;에서 출발하니, 매일 기획부터 개발, 테스트, 리뷰까지 토론이 끊이지 않았습니다. 그 과정에서 &#8216;사용자를 생각하는 개발&#8217;이란 무엇인지 배우고, 팀원들과의 찐한 협업을 통해 생각을 맞춰가는 즐거움을 느꼈습니다. 앞으로도 사용자가 신뢰할 수 있는 좋은 서비스를 만들며, 좋은 개발자로 성장해 나갈 것입니다.</p>
<h3>토독토독 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>토독토독에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://www.notion.so/sonjh/294ee47a09a380f28e16ebf68cde49e7?source=copy_link">토독토독 소개글 보러 가기</a></p>
<h3>토독토독 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>토독토독 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://play.google.com/store/apps/details?id=com.team.todoktodok&amp;amp;pcampaignid=web_share">토독토독 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/런세권_logo.png" alt="" /></p>
<h2>런세권 서비스</h2>
<p><strong>개발 이유</strong><br />
최근 &#8216;런세권(러닝+역세권)&#8217;이라는 신조어가 생길 만큼 러닝 인구가 증가했지만, 러너들은 여전히 &#8216;어디서 뛰어야 할지&#8217;에 대한 정보를 찾는 데 어려움을 겪고 있습니다. 실제로 프로젝트를 시작하는 시점에서 진행한 설문의 결과를 통해서 러닝 코스를 잘 찾지 못하는 러너들이 많고, 러닝 코스를 추천해 주는 서비스에 대한 많은 수요도 확인할 수 있었습니다.</p>
<p>기존의 지도 앱은 &#8216;길 찾기&#8217;에 유용할 뿐, 러닝에 최적화된 코스 정보(코스의 길이, 경사도, 바닥 재질)를 제공하지 않습니다. 또한, 기존 러닝 앱들은 &#8216;기록&#8217;에 초점이 맞춰져 있어, 새로운 코스를 발견하려는 사용자의 니즈를 충족시키지 못했습니다. 특히, 초보 러너가 본인의 수준에 맞는 난이도의 코스를 찾거나, 여행지 등 낯선 장소에서 가볍게 뛸 만한 코스를 발견하기는 더욱 어려웠습니다.</p>
<p><strong>목표</strong><br />
러닝 코스 정보의 비대칭을 해소하여, 초보자부터 숙련된 러너까지 누구나 자신의 수준과 상황에 맞는 최적의 러닝 코스를 쉽게 발견하고, 더 많은 사람들이 러닝을 시작하고 지속할 수 있는 환경을 만드는 것입니다.</p>
<p><strong>서비스 설명</strong><br />
사용자는 앱을 통해 현재 위치 기반 코스 탐색, 조건별(코스 길이, 난이도) 코스 필터링, 현 위치로부터 길 찾기 기능을 제공받습니다.</p>
<h3>개발 후기</h3>
<p><strong>개발 과정</strong><br />
팀원들과 회의를 통해 MVP를 선정하여 구현한 다음, 스프린트 기간을 가지며 사용자로부터 받은 피드백을 기반으로 서비스를 개선해나갔습니다.</p>
<p><strong>도전과 극복</strong><br />
프로젝트를 하면서 팀원들의 의견이 달라 진행이 다소 지연되었던 적도 있습니다. 하지만 더 나은 서비스를 만들겠다는 목표는 같았기에 저희는 쉽게 다시 일어설 수 있었습니다.</p>
<p><strong>배운 점</strong><br />
이번 프로젝트를 통해 저희는 개인의 성장뿐만 아니라 협업의 중요성과 즐거움을 느꼈으며, 더 나은 서비스를 만들어가는 길을 계속해서 함께 걸어나가고자 합니다.</p>
<h3>런세권 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>런세권에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://spicy-lillipilli-407.notion.site/2936a72d19378054a8c2dfa714d36d98">런세권 소개글 보러 가기</a></p>
<h3>런세권 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>런세권 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://play.google.com/store/apps/details?id=io.coursepick.coursepick">런세권 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/피드줍줍_logo.png" alt="" /></p>
<h2>피드줍줍 서비스</h2>
<p><strong>서비스 소개</strong><br />
QR을 통해 웹으로 접속하여 고객 피드백을 받고, 관리자가 웹앱으로 확인 및 대응할 수 있는 피드백 처리 서비스</p>
<p><strong>서비스 개발 이유</strong><br />
팀 내에서 피드백을 받을 때 직급이나 관계에 의해 솔직한 의견을 나누기 어렵다는 점을 느꼈습니다. 또한 설문조사나 피드백 수집 도구들이 복잡하고 번거로워서, 더 간단하고 접근성 높은 익명 피드백 플랫폼의 필요성을 인지하게 되었습니다.</p>
<p><strong>서비스 목표</strong><br />
익명 피드백으로 솔직하게 작성하기<br />
피드백 관리를 한 곳에서 하기</p>
<h3>개발 후기</h3>
<p>4개월이라는 시간 안에, 팀 7명이 함께 기획부터 배포까지 한 서비스를 만들어냈다는 사실이 지금 돌아보면 가장 큰 성과입니다. 기술적으로도, 서비스적으로도, 팀워크적으로도 모두 성장했어요.</p>
<p>이 경험은 앞으로 저에게 &quot;사람의 마음을 담는 기술 구현&quot;이 얼마나 의미 있는지, 그리고 좋은 기술이란 단지 코드만 아니라 사람이 쓰고 느끼는 것임을 다시 한번 확인시켜줬습니다. 앞으로 이 경험을 기반으로 더 좋은 서비스를 만들고, 더 많은 사용자에게 가치 있는 경험을 제공하는 개발자로 나아가겠습니다.</p>
<h3>피드줍줍 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>피드줍줍에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://github.com/woowacourse-teams/2025-feed-zupzup">피드줍줍 소개글 보러 가기</a></p>
<h3>피드줍줍 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>피드줍줍 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://feedzupzup.com/">피드줍줍 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/튜립_logo.png" alt="" /></p>
<h2>튜립 서비스</h2>
<p>여행 유튜브 보다가 &quot;여기 꼭 가보고 싶다!&quot; 생각해 본 적 있으신가요? 하지만 막상 여행 계획을 세우려 하면, 영상 속 장소를 다시 찾는 일은 번거롭고 시간이 많이 걸립니다. 영상을 멈춰가며 지도를 검색하고, 메모장에 적고, 다시 경로를 확인하는 과정은 설렘보다 피로에 가깝죠.</p>
<p>튜립은 그런 불편함을 해결하기 위해 만들어졌습니다. 유튜브 여행 영상 속 장소 정보를 한 곳에 모아 보여주고, 나만의 여행 일정으로 만들 수 있는 서비스입니다. 사용자는 영상을 보며 마음에 드는 장소를 선택하기만 하면 됩니다.</p>
<p>튜립이 영상 속 장소를 지도 위에 표시해 주기 때문에 누구나 &quot;영상 속 그 여행을 그대로 따라가는 일정&quot;을 완성할 수 있습니다. 이제 영상 속 여행을 멀리서 보기만 하지 마세요. 튜립과 함께라면, 보고 즐기던 여행이 곧 떠날 수 있는 여행이 됩니다.</p>
<h3>개발 후기</h3>
<p>기획부터 개발까지 모든 과정을 팀원들과 함께 해나간 경험이 정말 의미 있었습니다. 이번 경험을 통해 서비스를 위해 필요한 건 뛰어난 실력보다 좋은 협업이라는 걸 느꼈습니다. 저희만의 규칙을 만들어가며 점점 단단한 팀이 되어갔던 시간이 정말 소중했습니다.</p>
<p>여러 번의 사용자 테스트를 거치며 실제 사용자들이 느낄 불편함에 대해 열정적으로 토론하고, 새벽까지 함께 개발하며 웃고 떠들던 시간들도 잊을 수 없습니다. 특히 팀원들과 여행을 다녀온 뒤 직접 브이로그를 만들어 서비스를 사용했던 게 정말 좋은 추억이 됐던 것 같습니다.</p>
<p>이 모든 과정에서 누구보다 열정적으로 참여해 준 팀원들 덕분에 끝까지 지치지 않고 나아갈 수 있었습니다. 튜립을 통해 저희는 단순히 기능을 구현하는 팀이 아니라, 사용자에게 의미 있는 경험을 고민하는 팀으로 성장했습니다. 함께 웃고, 고민하고, 부딪히며 만들어낸 모든 순간이 소중했습니다.</p>
<h3>튜립 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>튜립에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://agate-bandana-491.notion.site/turip">튜립 소개글 보러 가기</a></p>
<h3>튜립 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>튜립 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://play.google.com/store/apps/details?id=com.on.turip&amp;amp;hl=ko">튜립 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/아맞다_logo.png" alt="" /></p>
<h2>아맞다 서비스</h2>
<p>프로젝트 아맞다는 우아한테크코스 내에서 진행되는 다양한 이벤트를 한눈에 확인하고, 놓치지 않도록 리마인드해 주는 웹 서비스입니다. 아맞다는 우아한테크코스 내에서 실제로 겪은 불편함에서 출발했습니다.</p>
<p>현재 우아한테크코스의 슬랙 채널은 40개가 넘고, 코치님들과 크루들이 다양한 이벤트를 여러 채널에 게시합니다. 하지만 채널이 많다 보니 어느 채널에 이벤트 모집 글이 올라왔는지 확인하기 어렵고, &quot;나중에 참여해야지&quot; 했다가 잊어버려 기회를 놓치는 일이 잦았습니다. 저희는 이런 문제를 해결하고자 등장했습니다.</p>
<p>아맞다는 이러한 복잡한 커뮤니케이션 속에서도 이벤트를 쉽게 발견하고, 제때 참여할 수 있도록 돕는 서비스를 목표로 하고 있습니다. 이벤트 정보를 한곳에서 모아보고, 자동으로 리마인드를 받아볼 수 있게 함으로써, 사용자들이 놓치지 않고 더 활발히 참여할 수 있는 환경을 만들어가고 있습니다.</p>
<h3>개발 후기</h3>
<p>프로젝트 초반, 저희는 서비스의 핵심 가치를 먼저 정하고 가설을 설정했습니다. &quot;이벤트 공지가 묻히는 이유는 리마인드가 없어서다&quot;라는 가설을 빠르게 검증하기 위해 최소 기능을 구현하고, 실제 사용자 테스트를 진행했습니다.</p>
<p>알림 구현 방식부터 인증 방식까지 모든 선택이 막막했지만, 팀원들은 각자 학습한 내용을 공유하며 함께 고민했습니다. 때로는 구현해 보고 다시 뒤집기도 했습니다. 특히 사용자 피드백을 받고 유저의 편의성을 위해 기존 기능을 갈아엎었을 때, 유지 보수성이란 가치가 얼마나 중요한지 절실히 깨달았습니다. 이런 시간을 통해 &#8216;개발&#8217;이 아닌 &#8216;협업&#8217;의 중요성을 다시 한번 느낄 수 있었고, 그래서 모두가 애정을 가진 서비스를 만들 수 있었습니다. &#8216;아 맞다&#8217; 팀은 앞으로도 한 사람의 완벽한 코드보다, 모두가 함께 만들어가는 서비스에 더 큰 가치를 둘 수 있었습니다.</p>
<p>무엇보다 중요한 것은 유저의 의견이라는 것을 알게 되었습니다. 과거로 돌아갈 수 있다면 더 공격적인 마케팅과 핵심 가치와 일치하지 않더라도 일단 사용자를 위해서 기능 개발을 하는 것을 생각해 볼 것 같습니다.</p>
<h3>아맞다 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>아맞다에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://github.com/woowacourse-teams/2025-ah-madda/blob/main/readme.md">아맞다 소개글 보러 가기</a></p>
<h3>아맞다 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>아맞다 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://ahmadda.com/">아맞다 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/포게더_logo.png" alt="" /></p>
<h2>포게더 서비스</h2>
<p>포게더는 &#8216;특별한 순간을 함께 모으는 사진 공유 서비스’입니다. 졸업식, 전시회 등 특별한 날의 사진을 여러 사람에게 받아야 하는 상황에서 기존 공유 방식은 불편함이 있었습니다. 카카오톡, 드라이브, SNS, AirDrop 등 다양한 방법을 사용해야 했고, 연락처가 없는 경우에는 전달받기가 어렵다는 문제가 있었습니다.</p>
<p>이를 해결하기 위해 포게더는 업로드의 불편함을 최소화하고, 누구나 쉽게 사진을 모을 수 있는 플랫폼을 만들었습니다. 주인공이 사진 앨범인 &#8216;스페이스&#8217;를 생성하면, 게스트는 로그인 없이 QR 코드나 링크로 접속해 바로 업로드할 수 있습니다. 사진을 장기간 저장하는 드라이브와 달리, &#8216;하나의 플랫폼에 모은다&#8217;는 것에 의미가 있습니다.</p>
<p>최근 포게더는 &#8216;전시&#8217; 도메인으로 새 단장했습니다. 졸업 전시를 준비하는 대학생이 자신의 작품을 소개하고, 방문객이 사진과 방명록을 남길 수 있도록 기능을 확장했습니다. 주인공은 당신이니까, 사진은 포게더가 책임질게요.</p>
<h3>개발 후기</h3>
<p>포게더 팀원들은 각자의 색깔이 강합니다. 하나의 팀으로 융화되기 위해, 경쟁자가 아닌 동료로서 함께 자라기 위해 우리는 4개월간 많은 노력을 했습니다.</p>
<p>프로젝트를 진행하며 가장 중요한 것은 &#8216;개발 실력&#8217;보다도 &#8216;솔직한 소통&#8217;이었습니다. &#8216;팀원의 마음을 알아야 사용자의 마음까지도 알 수 있다&#8217;는 믿음으로 프로젝트에 임했어요. 각자의 목표는 무엇인지, 어떤 생각을 가지고 있는지 공유할수록 모두에게 성장의 기회가 생겼습니다. 포게더는 문제를 마주할 때마다 도망치지 않고 함께 해결 방법을 찾았습니다. 맥락 공유 세션으로 서로의 호흡을 맞추고, 주간 회고에서 솔직한 마음을 나누며, 익명 피드백으로 서로의 발전을 도왔어요. 데일리 스크럼의 &#8216;칭찬하기&#8217; 시간은 우리 팀의 하루를 기분 좋게 열어주는 루틴이 되었습니다.</p>
<p>데모 데이를 준비하느라 밤을 새우고, 부스를 운영하며 서비스를 세상에 내보이던 순간의 즐거움을 기억합니다. 포게더는 어느새 심리적 안전감이 단단한 하나의 팀이 되어 있었어요. 이 모든 것의 바탕에는 팀원들의 배려와 이해, 내가 조금 고생하더라도 동료를 돕고자 하는 마음, 상대방을 존중하는 태도가 있었습니다. 그것이 모두가 빛나는 팀을 만들고, 결국 더 나은 서비스를 만드는 원동력이 되었습니다.</p>
<h3>포게더 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>포게더에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://catkin-chokeberry-f58.notion.site/293864a9cb0380859a41feda0e2ff39c">포게더 소개글 보러 가기</a></p>
<h3>포게더 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>포게더 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://forgather.app/">포게더 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/아인슈타임_logo.png" alt="" /></p>
<h2>아인슈타임 서비스</h2>
<p><strong>책임질 사람 없이도, 쉽고 빠르게 약속을 확정해 주는 서비스</strong></p>
<blockquote>
<p>이런 경험, 다들 있으시죠?</p>
</blockquote>
<p>팀 프로젝트하면서 회의 일정 잡을 때 정말 답답했던 적 많으셨을 겁니다. 슬랙이든 카카오톡이든 디스코드든, &quot;다음 주 언제 괜찮으세요?&quot;라고 물어보면 항상 같은 일이 반복되거든요.</p>
<p>각자 가능한 시간 물어보고, 아직 답 안 한 사람 독촉하고, 모은 정보 다시 정리해서 공유하고&#8230; 이게 다 주최자 한 명한테만 몰리는 거예요. 약속 하나 잡으려고 또 다른 일이 생기는 이 구조적 병목, 정말 비효율적이지 않나요?</p>
<blockquote>
<p>그래서 만들었습니다!</p>
</blockquote>
<p>이 반복되는 귀찮음을 없애고 싶었습니다. 누가 언제 투표했는지 실시간으로 공유되고, 결과는 자동으로 집계되고, 마감 시간 되면 알아서 약속이 확정되는 서비스요.</p>
<p>핵심은 간단합니다. <strong>조율 과정의 책임을 분산시키고, 시스템이 알아서 최적의 시간을 찾아주는 것.</strong> 더 이상 누군가 고생할 필요가 없도록 말이죠.</p>
<h3>개발 후기</h3>
<p>사용자와 소통하면서 기획부터 개발까지 &quot;이 기능이 사용자에게 좋은 영향을 줄 수 있을까?&quot;를 깊게 고민해 보는 경험을 할 수 있었습니다. 연속적인 유저 테스트와 데모데이까지 기술적 성장뿐 아니라 팀원들과의 찐한 협업을 할 수 있어 좋았습니다. 프로젝트를 진행하는 과정에서 &quot;가장 필요하다고 생각하는 최소 기능으로 최대의 가치를 만들어 내는 것&quot;이 성공적인 서비스를 만드는 중요한 요소라는 것을 깨닫게 되었습니다.</p>
<h3>아인슈타임 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>아인슈타임에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://hoyychoi.notion.site/landing?source=copy_link">아인슈타임 소개글 보러 가기</a></p>
<h3>아인슈타임 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>아인슈타임 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://estime.today">아인슈타임 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/모아온_logo.png" alt="" /></p>
<h2>모아온 서비스</h2>
<p>개발자로 성장하면서 다양한 프로젝트를 경험하지만, 정작 그 프로젝트들이 &#8216;왜&#8217; 그런 기술을 선택했는지, &#8216;어떻게&#8217; 문제를 해결했는지에 대한 맥락을 찾기란 쉽지 않습니다. 깃허브에는 코드만 있고, 포트폴리오 사이트에는 결과물만 나열되어 있죠. 프로젝트의 기술 스택은 보이지만 그 이면의 고민과 시행착오, 팀의 협업 과정은 보이지 않습니다. 모아온은 프로젝트와 아티클을 양방향으로 연결해, 단순한 결과물 나열을 넘어 개발의 &#8216;맥락&#8217;을 함께 탐색할 수 있는 플랫폼입니다. 관심 있는 기술 스택과 주제로 프로젝트를 찾아보고, 그 프로젝트가 어떤 배경에서 시작되었는지, 왜 특정 기술을 도입했는지, 어떤 문제를 마주하고 해결했는지를 깊이 있는 아티클로 만나보세요. 프로젝트와 아티클이 만나는 곳, 모아온에서 개발자들의 진짜 이야기를 발견해 보세요.</p>
<h3>개발 후기</h3>
<p>프로젝트를 진행하면서 가장 어려웠던 건 기술이 아니라 &#8216;의사결정&#8217;이었습니다. 8명의 팀원이 각자 타당한 근거를 가지고 의견을 내다보니 하나의 방향으로 합의하는 게 정말 쉽지 않았고, 처음 도입했던 &quot;만장일치&quot; 원칙은 이상적으로만 보였을 뿐 현실에서는 끝나지 않는 회의로 이어졌습니다. 메인 페르소나를 정하는 회의가 이틀이 지나도 결론이 나지 않아 2차 데모데이에서 그 문제가 그대로 드러났고, 이를 계기로 모아온만의 독특한 회의 문화를 만들었습니다. 회의마다 진행자를 돌아가며 맡고, 안건별로 결정 시간을 정한 뒤 그 안에 의견이 모이지 않으면 진행자가 최종 결정하는 &#8216;진행자 독재&#8217; 방식이었죠. 이 방식을 도입한 후 제한된 시간 내에 더 명확하게 의견을 표현하게 됐고, 내 의견이 채택되지 않아도 충분히 납득할 수 있었습니다. 완벽한 합의를 기다리기보다 불완전해도 결정하고 나아가는 법을 배웠고, 돌이켜보면 이 독특한 회의 문화가 모아온을 완성도 있는 서비스로 만들 수 있었던 가장 큰 힘이었던 것 같습니다.</p>
<h3>모아온 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>모아온에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://brick-william-6f5.notion.site/2944e1733f21802f96a6e8e7b43d5aea?source=copy_link">모아온 소개글 보러 가기</a></p>
<h3>모아온 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>모아온 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://moaon.co.kr">모아온 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/루티_logo.png" alt="" /></p>
<h2>루티 서비스</h2>
<p>&quot;이번 주말 어디 갈까?&quot;<br />
친구들이랑 당일치기 계획을 짜다 보면, 카톡방은 금세 이런저런 대화로 가득하고, 지도랑 SNS를 오가느라 정신없죠. 하나의 공간에서 친구들과 함께 장소를 추가하고, 해시태그로 분류하고, 방문순서를 정하며 계획을 세워보세요. 함께 만드는 동선, 루티에서 시작해 보세요!</p>
<h3>개발 후기</h3>
<p>&quot;루티&quot;하면 저희 팀원들은 아마 &#8216;회의&#8217;부터 떠올릴 거예요. 처음엔 8명의 의견이 잘 맞지 않아서 &#8216;만장일치가 될 때까지&#8217; 8인 페어 회의를 했어요. 덕분에 우테코에서 회의를 오래 하는 팀으로 유명해졌죠. 물론 너무 비효율적이라 나중엔 TF 팀도 만들고, 회의마다 &#8216;진행자, 서기, 타임키퍼&#8217; 역할도 정해서 해결했답니다.</p>
<p>가장 큰 고비는 첫 론칭 데이 피드백이었어요. 저희는 동선 검증 기능을 핵심이라고 생각했는데, 사용자들은 입력해야 하는 정보가 너무 많아 불편해했어요. 결국 저희는 더 나은 사용자 경험을 위해, 레벨 4가 시작되자마자 기존 기능을 전부 갈아엎는 큰 결정을 내렸습니다! 다행히도, 론칭 데이에서 대부분의 사용자가 긍정적인 피드백을 주고, 서비스에 관심이 많아 뿌듯했죠. 단순히 개발만 하기보다는, 사용자를 위한 서비스를 만들기 위해 고민했던 정말 소중한 경험이었습니다!</p>
<h3>루티 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>루티에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://lively-whale-2a7.notion.site/Routie-294dbb571bbe80ddb43fe1cb1922e597?source=copy_link">루티 소개글 보러 가기</a></p>
<h3>루티 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>루티 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://routie.me/">루티 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/페스타북_logo.png" alt="" /></p>
<h2>페스타북 서비스</h2>
<p>대학 축제를 준비하거나 참여해 본 적이 있다면, 필요한 정보를 찾는 일이 생각보다 쉽지 않다는 걸 느끼셨을 거예요. 공연 일정은 SNS에 흩어져 있고, 부스 위치는 직접 찾아야 하며, 공지사항은 또 다른 채널에서 확인해야 하죠.</p>
<p>페스타북(festabook)은 이런 불편을 해결하기 위해 만들어졌습니다. 축제와 관련된 모든 정보를 한 곳에 모아, 학생회는 운영 효율을 높이고 실시간 소통이 가능한 시스템을, 학생은 직관적이고 빠른 정보 접근 경험을 얻을 수 있습니다.</p>
<h3>개발 후기</h3>
<p>페스타북은 단순한 프로토타입을 넘어, 실제 대학 축제 현장에서 사용된 서비스로 발전했습니다. 2025년 9월 첫 배포 이후, 국립강릉원주대학교·우석대학교·한서대학교·안산대학교·차 의과학대학교 등 5개 대학과 제휴를 맺었고, 약 2,000명의 사용자가 페스타북을 이용했습니다. 축제 종료 후 진행한 사용자 피드백 조사(구글폼)에서는 &quot;정보를 한눈에 볼 수 있어 편리했다&quot;, &quot;부스 찾기가 쉬워졌다&quot;와 같은 피드백을 받았습니다.</p>
<p>이 경험을 통해 팀은 &#8216;기술적인 완성도&#8217; 뿐 아니라 &#8216;실제 사용자에게 가치를 주는 서비스&#8217;를 만드는 과정을 배웠습니다. 현재는 2025년 제휴를 맺은 대학과의 협업을 잘 마무리하고 받은 피드백을 바탕으로, 2026년 더 다양한 축제를 아우르는 서비스로 발전을 준비하고 있습니다.</p>
<h3>페스타북 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>페스타북에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://www.notion.so/festabook-293a540dc0b78056a88fdf884f5fcc86">페스타북 소개글 보러 가기</a></p>
<h3>페스타북 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>페스타북 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://linktr.ee/festabook">페스타북 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/핏토링_logo.png" alt="" /></p>
<h2>핏토링 서비스</h2>
<p>&quot;운동이 처음이라 뭐부터 해야 할지 모르겠어요.&quot;<br />
&quot;스쿼트만 하면 무릎이 아파요!&quot;<br />
&quot;헬스장에 가기는 부담스럽고.. 간단히 상담받을 수 있는 곳 없을까요?&quot;</p>
<p>운동은 해야 한다는 걸 알지만, 막상 혼자 시작하려면 막막합니다.<br />
헬스장에 등록하기엔 부담스럽고, 검색해도 내 상황에 맞는 답은 찾기 어렵죠. 핏토링 은 그런 고민을 덜어주는 온라인 피트니스 멘토링 플랫폼입니다. 운동을 잘 아는 사람들이 자신의 노하우를 나누고, 처음 시작하는 사람들은 편하게 질문하며 피드백을 받을 수 있습니다.</p>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f3cb.png" alt="🏋" class="wp-smiley" style="height: 1em; max-height: 1em;" /> 실시간 1:1 채팅 멘토링<br />
궁금한 점을 멘토에게 바로 물어보세요.<br />
스쿼트 자세 교정, 운동 루틴 구성, 식단 조언까지!<br />
15분의 집중 멘토링으로 필요한 조언만 알차게 받아볼 수 있습니다.</p>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2615.png" alt="☕" class="wp-smiley" style="height: 1em; max-height: 1em;" /> 커피 한 잔 값으로 해결하는 운동 고민<br />
큰돈 들이지 않아도 충분합니다.<br />
헬스장 대신, 부담 없이 나에게 맞는 멘토를 찾아보세요.<br />
핏토링과 함께라면, 운동은 더 이상 혼자의 싸움이 아닙니다.<br />
지금 당신의 열정을 함께 이어갈 멘토를 만나보세요!</p>
<h3>개발 후기</h3>
<p>핏토링은 멘토와 멘티가 함께 만들어가는 서비스입니다. 이 구조 때문에 초반에는 멘토 확보가 가장 큰 과제였어요. 실제로 팀원들이 직접 헬스장을 찾아다니며 트레이너분들을 설득하고, 서비스의 취지를 설명하며 한 명 한 명 멘토를 모집했었어요. 사용자를 직접 만나고 피드백을 듣는 과정은 힘들었지만, 동시에 서비스가 &#8216;진짜 사람들에게 쓰이는구나&#8217;라는 실감을 주었습니다.</p>
<p>핏토링 개발 과정에서도 쉽지 않은 도전이 많았습니다. 서비스 주제 선정부터 기획, 디자인, 개발, 그리고 팀 문화까지 모든 걸 팀 내부에서 만들어가야 했기 때문에 정말 많은 소통과 조율이 필요했습니다. 어느 날은 의견이 충돌하기도 했고, 일정이 꼬이기도 했지만, 그때마다 서비스를 완성시키기 위해서 모두가 함께 노력했어요.</p>
<p>핏토링을 개발하면서 가장 크게 배운 건, 좋은 서비스는 좋은 협업에서 나온다는 사실이었습니다. 이렇게 찐하게 협업을 해볼 기회가 또 있을까 싶어요. 그래서 핏토링은 단순한 프로젝트가 아니라, 우리 모두가 함께 성장한 하나의 여정이었다고 생각해요!</p>
<h3>핏토링 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>핏토링에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://bini-team.notion.site/294cb79c55d08050b602efc447294a5f">핏토링 소개글 보러 가기</a></p>
<h3>핏토링 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>핏토링 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://www.fittoring.com">핏토링 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/모멘트_logo.png" alt="" /></p>
<h2>모멘트 서비스</h2>
<p>모멘트는 일상의 소소한 순간을 익명으로 기록하고 공감을 나누는 소셜 네트워크 서비스입니다. 많은 사람들이 기존 SNS에서 비교와 평가가 두려워 자신의 평범한 일상을 공유하지 못하고, 친구에게 매일 연락하기에는 부담스러운 상황을 겪고 있습니다. 저희는 자존감 회복이 일상의 소소한 순간을 소중히 여기고 인정받는 데서 온다고 판단했습니다.</p>
<p>모멘트는 SNS의 과시와 편향성 부작용을 해소하고, 비교 받지 않으면서도 공감받을 수 있는 심리적 안정 공간을 제공합니다. &#8216;누군가 딱 한 명이라도 알아줬으면 하는 마음&#8217;을 충족시키는 것이 모멘트의 핵심 가치입니다.</p>
<h3>개발 후기</h3>
<p>우리 팀은 항상 &#8216;7-1=0&#8217;이었습니다. 항상 함께 생각하고, 모두가 머리를 맞대고 고민했습니다. 그 결과 7명의 팀원 모두가 한 명도 빠짐없이 적극적으로 참여하며 끈끈한 팀이 되었습니다. 프론트엔드, 백엔드 구분 없이 서비스 전체에 대해 함께 고민했고, 기술적인 부분도 한 사람이 담당하는 것이 아니라 모두가 이해할 수 있도록 함께 진행했습니다.</p>
<p>칭찬 보드 작성, 속초 여행, 노들섬 나들이, 유강스(유연성 강화 스터디) 등 함께 보낸 시간들은 팀을 점점 더 끈끈하게 만들었고, 이는 자연스럽게 서비스에 대한 애정으로 이어졌습니다. 모멘트 팀과 함께 한 모든 순간은 서비스명답게 소중한 기억들로 남았습니다.</p>
<h3>모멘트 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>모멘트에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://github.com/woowacourse-teams/2025-moment/wiki/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%84%A4%EB%AA%85">모멘트 소개글 보러 가기</a></p>
<h3>모멘트 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>모멘트 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://connectingmoment.com/">모멘트 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/물깜_logo.png" alt="" /></p>
<h2>물깜 서비스</h2>
<p><strong>서비스 개발 이유</strong><br />
단순한 물 섭취 기록을 넘어, 사용자의 건강한 습관 형성을 돕고 재미를 더하기 위해 개발했습니다. 리마인드 기능과 운동·날씨 기반 추천 등을 통해 일상 속 자연스러운 수분 섭취 습관을 만들어줍니다.</p>
<p><strong>목표</strong></p>
<ul>
<li>사용자의 일상 속 물 섭취 습관 형성 지원</li>
<li>개인 맞춤형 리마인드 제공</li>
<li>재미와 동기 부여를 통한 지속 사용 유도</li>
<li>사용자 중심의 경험 설계</li>
</ul>
<h3>개발 후기</h3>
<p><strong>개발 과정</strong><br />
처음에는 단순히 물 섭취를 기록하는 기능에서 출발했지만, 사용자의 &#8216;습관 형성&#8217;과 &#8216;재미&#8217;를 중심으로 확장했습니다. 단순한 기록을 넘어, 리마인드와 추천 기능을 통해 사용자가 스스로 물을 마시는 이유를 느낄 수 있도록 설계했습니다.</p>
<p><strong>도전</strong><br />
재미 요소를 더하기 위해 소셜 기능(물 풍선 알림)을 구현했습니다. 친구에게 물 풍선을 던져 리마인드를 보내는 구조를 설계하며, 백엔드 엔티티와 데이터 흐름을 함께 고민했습니다. 안드로이드 팀은 Jetpack Compose를 도입해 새로운 UI 방식을 탐구하며 협력했고, 기술적 시도와 함께 즐거운 사용자 경험을 중심으로 한 일관된 인터페이스를 구현했습니다.</p>
<p><strong>배운 점</strong><br />
사용자는 우리가 예측한 대로 움직이지 않았습니다. &quot;컵&quot;이라는 핵심 용어조차 기대만큼 직관적이지 않았고, 이를 계기로 사용자 테스트와 피드백 중심 사고의 중요성을 체감했습니다. 이 경험을 통해 내가 아니라 유저의 시선으로 생각하는 습관이 생겼습니다.</p>
<p><strong>회고</strong><br />
이번 프로젝트에서는 서로의 강점을 보며 배우는 순간이 많았어요. 누군가는 실행력을, 또 누군가는 꾸준함이나 말의 태도를 닮고 싶다고 말했고, 그 덕분에 팀 안에서 자연스럽게 배움이 순환이 되었습니다. 대화를 통해 서로 부족한 부분을 자각하며, 메타인지와 커뮤니케이션 측면에서 한층 성장했다고 느꼈습니다.</p>
<h3>물깜 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>물깜에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://wealthy-clematis-4a5.notion.site/2945bca0ac228046a7ccee01c67930cd">물깜 소개글 보러 가기</a></p>
<h3>물깜 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>물깜 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://play.google.com/store/apps/details?id=com.mulkkam">물깜 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/히어릿_logo.png" alt="" /></p>
<h2>히어릿 서비스</h2>
<p>빠르게 변하는 IT 트렌드와 새로운 기술들. 공식 문서는 어렵고, 기술 블로그는 너무 많죠. 이럴 때 필요한 건, 바로 <strong>히어릿(hEARit)</strong>입니다.</p>
<p>히어릿은 개발자를 위한 IT 팟캐스트 플랫폼이에요. 복잡한 문서 대신, 기술 트렌드와 지식을 &#8216;귀로&#8217; 배우는 서비스입니다. 출퇴근길, 산책 중, 잠들기 전 언제 어디서든 다양한 팟캐스트를 들어보세요. 글 대신, 팟캐스트로 쉽게 공부하자! 개발자를 위한 오디오 학습 플랫폼, 히어릿(hEARit).</p>
<h3>개발 후기</h3>
<p>좋은 서비스는 결국 같은 목표를 향해 달리는 팀에서 나온다고 믿습니다. 기획과 디자인, 사용자 테스트를 반복하며 수많은 수정과 개선을 거쳤지만, 언제나 중심에는 ‘사용자에게 진짜 필요한 경험을 만들자’는 마음이 있었습니다. 그 마음과 함께 성장하고자 했기에, 우리는 히어릿(hEARit)이라는 서비스를 만들어낼 수 있었습니다.</p>
<p>항상 웃음이 끊이지 않고, 서로를 격려하며 나아가는 마치 &#8216;동물의 숲 주민들&#8217;처럼 따뜻한 팀원들이 함께했기에 개발자로서, 또 협업하는 동료로서 성장할 수 있었던 시간이었습니다. 해당 서비스의 팟캐스트를 만들며, 또 개발을 하며 기술적으로 많은 성장을 이뤘듯, 이제는 여러분이 히어릿(hEARit)을 통해 다양한 팟캐스트를 듣고, 새로운 인사이트를 얻으며 함께 성장하시길 바랍니다.</p>
<h3>히어릿 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>히어릿에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://glistening-eclipse-58b.notion.site/hEARit-IT-294d39b9c3c3806c9b19dfcff1cb40fc">히어릿 소개글 보러 가기</a></p>
<h3>히어릿 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>히어릿 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://play.google.com/store/apps/details?id=com.onair.hearit&amp;amp;hl=ko">히어릿 바로가기</a></p>
<hr />
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/야구보구_logo.png" alt="" /></p>
<h2>야구보구 서비스</h2>
<p>&quot;오늘이 몇 번째 직관이었지?&quot;, &quot;내가 직관했을 때 우리 팀 승률이 어떻게 되더라?&quot;</p>
<p>야구 직관을 다녀온 후 이런 생각을 해본 적 있으신가요? 흥분과 감동으로 가득했던 순간들이 시간이 지나면서 희미해지고, 정확한 기록은 남아있지 않습니다. 경기 날짜, 상대 팀, 결과를 일일이 정리하려니 귀찮고, 내 직관 기록을 꾸준히 남기기는 더욱 어렵습니다.</p>
<p>‘야구보구’는 클릭 한 번으로 모든 것을 해결합니다. 구장 방문을 인증하면 경기 정보, 결과, 나의 직관 통계까지 자동으로 기록됩니다. 오늘 구장별 팬 분포를 실시간으로 확인하고, 내 직관 승률과 기록을 한눈에 볼 수 있습니다.</p>
<p>야구보구와 함께, 직관의 모든 순간을 데이터로 남겨보세요!</p>
<h3>개발 후기</h3>
<p>프로젝트 초반, 일주일간 공들여 기획한 애니메이션 성지 인증 앱이 저작권 문제로 무산되며 큰 위기를 맞았습니다. 하지만 팀 전체가 빠르게 모여 해결책을 찾았고, 위치 인증 기술을 야구 직관에 적용한 &#8216;야구보구&#8217;가 탄생했습니다.</p>
<p>개발 과정은 도전의 연속이었습니다. 백엔드는 KBO 공식 API가 없어 동적 크롤링 시스템을 직접 구축해야 했고, 안드로이드는 GPS 기반 위치 인증 구현에 매진했죠. 잠실 야구장을 직접 방문해 야구팬들과 인터뷰하며 사용자 유형별로 니즈가 다르다는 것을 발견했고, 통계 특화 기능과 툴팁 설명을 추가하며 사용자가 진정 원하는 앱을 만들고자 노력했습니다.</p>
<p>가장 큰 수확은 협업의 가치였습니다. 7명의 서로 다른 개성이 하나의 하모니를 이루었고, 의사결정 기준이 &#8216;우리&#8217;에서 &#8216;사용자&#8217;로 자연스럽게 변화했어요. 우테코 내부의 프로젝트를 넘어 실제 유저가 매일 가입하고 인증하는 모습을 보며 서비스에 더욱 애정을 갖게 된 소중한 경험이었습니다.</p>
<h3>야구보구 소개 링크</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2b50.png" alt="⭐" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>야구보구에 대해 더 알고 싶다면?</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4dd.png" alt="📝" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://github.com/woowacourse-teams/2025-yagu-bogu/wiki/">야구보구 소개글 보러 가기</a></p>
<h3>야구보구 바로가기</h3>
<p><img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f449.png" alt="👉" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <strong>야구보구 사용해 보기!</strong> <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f4a1.png" alt="💡" class="wp-smiley" style="height: 1em; max-height: 1em;" /> <a href="https://get.yagubogu.com/">야구보구 바로가기</a></p>
<hr />The post <a href="https://techblog.woowahan.com/24251/">기획부터 개발까지 전부 직접 했습니다 – 우테코 7기 크루 서비스 론칭!</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></content:encoded>

					<wfw:commentRss>https://techblog.woowahan.com/24251/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>


			</item>
		<item>
		<title>AI와 함께하는 테스트 자동화: 플러그인 개발기</title>
		<link>https://techblog.woowahan.com/24568/</link>
					<comments>https://techblog.woowahan.com/24568/#respond</comments>

		<dc:creator><![CDATA[강규한]]></dc:creator>
		<pubDate>Thu, 04 Dec 2025 06:41:45 +0000</pubDate>
				<category><![CDATA[AI]]></category>
		<guid isPermaLink="false">https://techblog.woowa.in/?p=24568</guid>

					<description><![CDATA[<p>프롤로그 저희 팀에서 관리하는 레포지토리는 7개입니다. 빠른 비즈니스 과제를 해내가며 필수 테스트코드만 작성하다 보니 커버리지가 부족한 레포지토리가 생겼습니다. 특히 엣지케이스나 예외 상황에 대한 테스트가 부족했고, 이는 운영 안정성을 떨어뜨리는 원인이 되었습니다. 30분 만에 100개 테스트 자동 생성, 어떻게 했을까? 100개의 단위 테스트를 작성하고, 실제로 동작하는지 검증까지 완료하는 데 30분이 걸렸습니다. BUILD SUCCESSFUL 총 테스트: 100개 [&#8230;]</p>
The post <a href="https://techblog.woowahan.com/24568/">AI와 함께하는 테스트 자동화: 플러그인 개발기</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></description>
										<content:encoded><![CDATA[<h3>프롤로그</h3>
<p>저희 팀에서 관리하는 레포지토리는 7개입니다. 빠른 비즈니스 과제를 해내가며 필수 테스트코드만 작성하다 보니 커버리지가 부족한 레포지토리가 생겼습니다. 특히 엣지케이스나 예외 상황에 대한 테스트가 부족했고, 이는 운영 안정성을 떨어뜨리는 원인이 되었습니다.</p>
<hr />
<h2>30분 만에 100개 테스트 자동 생성, 어떻게 했을까?</h2>
<p>100개의 단위 테스트를 작성하고, 실제로 동작하는지 검증까지 완료하는 데 30분이 걸렸습니다.</p>
<pre><code>BUILD SUCCESSFUL

총 테스트: 100개
&#x2705; 통과: 97개 (97%)
&#x23ed; 스킵: 3개 (3%) - 통합 테스트 필요
&#x274c; 실패: 0개 (0%)

생성된 파일:
- ProductSortServiceTest.kt (25/25 TC 통과)
- ProductFilterServiceTest.kt (24/24 TC 통과)
- BadgePriorityServiceTest.kt (23/23 TC 통과)
- DiscountCalculatorTest.kt (25/25 TC 통과)</code></pre>
<p><strong>비결은 간단합니다.</strong></p>
<p>IntelliJ 플러그인이 컴파일 보장 템플릿을 생성하고, Amazon Q가 구현을 채워넣는 방식입니다.</p>
<pre><code>플러그인 (1분) → 컴파일 보장 템플릿 → Amazon Q (2분) → 완성된 테스트</code></pre>
<hr />
<h2>1. AI 에이전트로 테스트 코드 작성 시도</h2>
<h3>1.1 AI 에이전트 사용 경험</h3>
<p>ChatGPT, Claude, Gemini 같은 AI 에이전트들이 테스트 코드 생성에 도움을 줍니다. 특히 IDE에 통합된 AI 도구들은 프로젝트 컨텍스트를 이해하기 때문에 더 정확한 코드를 생성합니다.</p>
<p>여러 IDE 통합 AI 도구들을 실제로 비교 테스트해본 결과, Amazon Q를 선택했습니다.</p>
<p><strong>IDE 통합 AI 도구 비교</strong></p>
<table>
<thead>
<tr>
<th>도구</th>
<th>IDE 환경</th>
<th>비용 구조</th>
<th>의존성 인식</th>
<th>컨텍스트 이해</th>
</tr>
</thead>
<tbody>
<tr>
<td>GitHub Copilot</td>
<td>VS Code 기반</td>
<td>월 $10 고정</td>
<td>제한적</td>
<td>파일 단위</td>
</tr>
<tr>
<td>Amazon Q</td>
<td>IntelliJ 통합</td>
<td>월 $19 (Pro tier)</td>
<td>우수</td>
<td>프로젝트 전체</td>
</tr>
<tr>
<td>Cursor</td>
<td>독립 IDE</td>
<td>사용량 기반 (예측 어려움)</td>
<td>우수</td>
<td>프로젝트 전체</td>
</tr>
</tbody>
</table>
<p><strong>Amazon Q 선택 이유</strong></p>
<p>가장 큰 이유는 기존 개발 환경을 그대로 유지할 수 있다는 점입니다. 우리 팀은 이미 IntelliJ IDEA를 사용하고 있어 단축키, 환경설정, 플러그인 생태계에 익숙합니다. Cursor로 전환하면 새로운 IDE에 적응하는 학습 비용이 발생하지만, Amazon Q는 IntelliJ에 플러그인 형태로 통합되어 익숙한 환경에서 바로 AI 기능을 사용할 수 있습니다.</p>
<p><strong>실제 사용 과정</strong></p>
<pre><code>나: &quot;ProductDisplayService 클래스의 테스트 코드 작성해줘&quot;

Amazon Q: [테스트 코드 생성]

나: &quot;우리 팀은 Kotest FunSpec을 사용해. Context 구조로 작성해줘&quot;

Amazon Q: [수정된 코드 생성]

나: &quot;MockK를 사용하고, given-when-then 주석을 명시해줘&quot;

Amazon Q: [다시 수정된 코드 생성]</code></pre>
<p><strong>발견한 문제</strong></p>
<p>10개 클래스에 테스트를 작성하면서 패턴이 보였습니다.</p>
<ul>
<li>매번 같은 컨벤션 설명 반복</li>
<li>어떤 메서드를 테스트해야 할지 판단하기</li>
<li>생성된 코드의 빌드 오류 수정 (15% 정도)</li>
<li>클래스마다 10분씩 소요</li>
</ul>
<p><strong>실제 소요 시간 측정</strong></p>
<ul>
<li>ProductDisplayService: 11분 (빌드 오류 1회 수정)</li>
<li>MinOrderService: 9분 (빌드 오류 없음)</li>
<li>DeliveryFeeService: 12분 (빌드 오류 2회 수정)</li>
<li>평균: 약 10분/클래스</li>
</ul>
<p>이 반복 작업을 자동화하면 어떨까?</p>
<h3>1.2 해결 방법 모색</h3>
<p>세 가지 방법을 고민했습니다.</p>
<p><strong>방법 1: 프롬프트 템플릿</strong></p>
<ul>
<li>팀 컨벤션을 문서화해서 매번 복사</li>
<li>한계: 의존성은 여전히 수동, 클래스마다 다른 정보 필요</li>
</ul>
<p><strong>방법 2: 스크립트 자동화</strong></p>
<ul>
<li>간단한 스크립트로 클래스 정보 추출</li>
<li>한계: IDE 통합 부족, 사용성 떨어짐</li>
</ul>
<p><strong>방법 3: IntelliJ 플러그인</strong></p>
<ul>
<li>IDE에 완전히 통합</li>
<li>PSI 트리로 정확한 코드 분석</li>
<li>원클릭으로 모든 정보 수집</li>
</ul>
<p>세 번째 방법을 선택했습니다. 테스트 코드 작성 시간을 단축하기 위해 반복 작업을 자동화하는 IntelliJ 플러그인을 개발하기로 했습니다.</p>
<hr />
<h2>2. 첫 시도: 한계가 보였다</h2>
<h3>2.1 플러그인 첫 버전</h3>
<p><strong>목표</strong></p>
<ul>
<li>팀 테스트 패턴 자동 학습</li>
<li>클래스 의존성 자동 수집</li>
<li>커버리지 분석으로 우선순위 제시</li>
<li>AI에게 최적화된 프롬프트 전달</li>
</ul>
<h3>2.2 플러그인 첫 버전 사용 결과</h3>
<p>첫 버전은 간단한 구조였습니다. 클래스 코드와 의존성을 수집하고, Gemini API를 호출하여 완성된 테스트 코드를 생성하는 방식이었습니다.</p>
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/테스트코드자동화_01-750x376.png" alt="" /></p>
<p><strong>10개 클래스로 파일럿 테스트</strong></p>
<table>
<thead>
<tr>
<th>결과</th>
<th>건수</th>
<th>비율</th>
</tr>
</thead>
<tbody>
<tr>
<td>테스트 생성 성공</td>
<td>10/10</td>
<td>100%</td>
</tr>
<tr>
<td>컴파일 성공</td>
<td>1/10</td>
<td>10%</td>
</tr>
<tr>
<td>컴파일 실패</td>
<td>9/10</td>
<td>90%</td>
</tr>
<tr>
<td>수정 없이 바로 실행 가능</td>
<td>0/10</td>
<td>0%</td>
</tr>
</tbody>
</table>
<p>거의 모든 케이스에서 컴파일이 깨지는 형태로 코드가 생성되었습니다. 생성된 코드를 수정하는 데 추가 시간이 필요했고, 이는 처음부터 AI 어시스턴트를 사용하는 것보다 두 배의 작업을 야기했습니다.</p>
<p><strong>발견한 주요 문제들</strong></p>
<p><strong>문제 1: 기존 테스트가 사라진다</strong></p>
<p>가장 심각한 문제였습니다. 테스트를 추가하려고 했더니 기존 테스트가 완전히 대체되어 버렸습니다. 10개 클래스 모두에서 이 문제가 발생했습니다.</p>
<pre><code class="language-kotlin">// 기존 테스트 (163줄)
class ProductServiceTest : FunSpec({
    context(&quot;상품 조회&quot;) {
        test(&quot;정상 케이스&quot;) { ... }
        test(&quot;상품 없음&quot;) { ... }
    }
})

// AI 생성 결과 - 기존 테스트 완전 교체
class ProductServiceTest : FunSpec({
    context(&quot;새로운 테스트&quot;) {
        // 기존 테스트는 사라짐...
    }
})</code></pre>
<p><strong>문제 2: Import 오류 (23%)</strong></p>
<pre><code class="language-kotlin">import comor.example.domain.Product      // com → comor
import ioio.kotest.matchers.shouldBe     // io → ioio</code></pre>
<p><strong>문제 3: 존재하지 않는 클래스/필드 (18%)</strong></p>
<pre><code class="language-kotlin">import com.example.domain.ProductValidator  // 실제로는 없는 클래스

every { product.category } returns &quot;FOOD&quot;  // category 필드는 존재하지 않음</code></pre>
<p><strong>문제 4: 타입 불일치 (15%)</strong></p>
<pre><code class="language-kotlin">every { location.latitude } returns &quot;37.5&quot;  // Double인데 String</code></pre>
<p><strong>문제 5: 유효하지 않은 Mock 데이터 (12%)</strong></p>
<pre><code class="language-kotlin">enum class ProductStatus { ACTIVE, INACTIVE, DELETED }

every { status.name } returns &quot;PENDING&quot;  // 존재하지 않는 값</code></pre>
<p>완전 자동화 방식은 한계가 명확했습니다. AI가 생성한 코드는 &quot;그럴듯하지만&quot; 실제로는 동작하지 않는 경우가 많았습니다.</p>
<hr />
<h2>3. 팀 공유: 함께 발견한 개선점</h2>
<h3>3.1 팀원들의 사용 경험</h3>
<p>플러그인이 팀에 많은 도움이 될 거라 기대했지만, 현실은 녹록지 않았습니다.</p>
<p><strong>사용성 문제</strong></p>
<ul>
<li>플러그인 설치 복잡성</li>
<li>Amazon Q와의 차별성에 대한 의문</li>
<li>사용법을 알기 어려움</li>
</ul>
<p><strong>기술적 문제</strong></p>
<ul>
<li>컴파일 오류 빈번 발생 (Import 오타, 타입 불일치)</li>
<li>전체 메서드 커버리지 부족 (일부 메서드 누락)</li>
</ul>
<p>플러그인을 설치하고 사용법을 익히는 것 자체가 허들이었습니다. 새로운 도구를 도입하려면 그만큼 명확한 가치를 보여줘야 하는데, 컴파일 오류와 기존 테스트 손실 같은 문제들이 그 가치를 희석시켰습니다.</p>
<h3>3.2 발견한 문제 패턴</h3>
<p>팀원들과 함께 사용하면서 구체적인 문제 패턴이 보였습니다.</p>
<p><strong>문제 1: AI 할루시네이션</strong></p>
<pre><code class="language-kotlin">import comor.example.domain.Product  // com → comor (오타)
import com.example.domain.ProductValidator  // 없는 클래스</code></pre>
<p><strong>문제 2: 타입 불일치</strong></p>
<pre><code class="language-kotlin">every { location.latitude } returns &quot;37.5&quot;  // Double인데 String</code></pre>
<p><strong>문제 3: 기존 테스트 손실</strong></p>
<ul>
<li>추가 테스트 생성 시 기존 테스트 덮어쓰기</li>
<li>Git diff: 163줄 → 30줄로 축소</li>
</ul>
<p><strong>문제 4: 불완전한 커버리지</strong></p>
<ul>
<li>15개 메서드 중 10개만 테스트 생성</li>
<li>5개 메서드 누락</li>
</ul>
<p><strong>문제 5: 복잡한 프로젝트 구조에서의 혼란</strong></p>
<p>실제 운영 중인 프로젝트는 멀티모듈 구조에 외부 의존성이 많고, 같은 이름의 클래스가 다른 패키지에 존재하는 경우가 빈번합니다. AI는 이런 복잡한 환경에서 어떤 클래스를 import 해야 할지 혼란스러워합니다.</p>
<pre><code class="language-kotlin">// 실제로는 3개의 다른 Product 클래스가 존재
import com.example.api.dto.Product        // API 모듈
import com.example.domain.Product         // Domain 모듈
import com.example.external.Product       // 외부 라이브러리

// AI가 잘못된 것을 선택하거나, 존재하지 않는 패키지를 만들어냄
import com.example.service.Product        // 없는 클래스</code></pre>
<p>이런 문제는 단순한 예제 코드에서는 발생하지 않습니다. <strong>이 글의 예시 코드처럼 간단한 구조의 프로젝트라면 플러그인만으로도 테스트 코드가 잘 생성됩니다.</strong> 하지만 실제 멀티모듈 프로젝트에서는 이런 복잡성 때문에 AI가 빈번하게 오류를 만들어냈고, 이것이 플러그인 단독 사용을 포기하게 된 결정적 이유였습니다.</p>
<blockquote>
<p><strong>왜 실제 사례를 보여주지 않나요?</strong><br />
실제 멀티모듈 환경의 문제를 재현하려면 사내 코드를 공개하거나, 복잡한 멀티모듈 프로젝트를 별도로 구성해야 합니다. 이는 공수가 매우 크고 보안상 문제가 있어 이 글에서는 단순화된 예시만 다룹니다.</p>
</blockquote>
<hr />
<h2>4. 개선: 왜 문제가 생겼을까?</h2>
<h3>4.1 근본 원인 분석</h3>
<p>팀원들과 함께 원인을 분석했습니다.</p>
<p><strong>플러그인이 해결한 것</strong></p>
<ul>
<li>팀 컨벤션 자동 학습</li>
<li>의존성 자동 수집</li>
<li>우선순위 자동 제시</li>
</ul>
<p><strong>플러그인이 해결하지 못한 것</strong></p>
<ul>
<li>AI 생성 코드의 정확성</li>
<li>완전한 커버리지</li>
<li>컴파일 성공 보장</li>
<li>기존 테스트 보존</li>
</ul>
<p><strong>핵심 문제</strong></p>
<p>플러그인은 &quot;AI에게 더 좋은 정보를 주는 도구&quot;일 뿐입니다. AI 자체의 한계는 플러그인으로 극복할 수 없었습니다.</p>
<p>특히 멀티모듈 환경에서는 플러그인이 수집한 정보만으로는 부족했습니다. 같은 이름의 클래스가 여러 모듈에 존재하거나, 외부 라이브러리의 DTO와 내부 도메인 객체가 혼재된 상황에서 AI는 정확한 판단을 내리지 못했습니다.</p>
<h3>4.2 자동 수정의 한계</h3>
<p>&quot;AI가 오류를 자동으로 고치면 되지 않나요?&quot;</p>
<p>이 방법도 시도해봤습니다.</p>
<p><strong>실험 결과</strong></p>
<table>
<thead>
<tr>
<th>시도</th>
<th>성공률</th>
<th>평균 시간</th>
<th>비용</th>
</tr>
</thead>
<tbody>
<tr>
<td>1회</td>
<td>30%</td>
<td>40초</td>
<td>1x</td>
</tr>
<tr>
<td>2회</td>
<td>55%</td>
<td>80초</td>
<td>2x</td>
</tr>
<tr>
<td>3회</td>
<td>65%</td>
<td>120초</td>
<td>3x</td>
</tr>
</tbody>
</table>
<p>35%는 3번 시도해도 실패했고, 시간과 비용만 증가했습니다.</p>
<p><strong>왜 실패했을까?</strong></p>
<p>IDE 통합 AI와 외부 API의 차이 때문입니다.</p>
<p><strong>IDE 통합 AI (Amazon Q)</strong></p>
<ul>
<li>IDE와 완전히 통합</li>
<li>실시간 컴파일러 접근</li>
<li>정확한 타입 정보와 컨텍스트</li>
<li>구조화된 오류 정보</li>
</ul>
<p><strong>외부 API (Gemini)</strong></p>
<ul>
<li>IDE와 분리되어 정보 손실</li>
<li>텍스트 오류 메시지만 전달</li>
<li>컨텍스트 없이 추측으로 수정</li>
<li>같은 오류 반복 가능</li>
</ul>
<hr />
<h2>5. 전환: 템플릿 + Amazon Q 방식</h2>
<h3>5.1 새로운 접근</h3>
<p><strong>기존 방식</strong></p>
<pre><code>플러그인 → AI → 완성된 테스트 (오류 가능)</code></pre>
<p><strong>새로운 방식</strong></p>
<pre><code>플러그인 → 컴파일 보장 템플릿 → Amazon Q → 완성된 테스트</code></pre>
<p><strong>핵심 아이디어</strong></p>
<p>Amazon Q가 어려워하는 부분은 플러그인이 해결하고, Amazon Q가 잘하는 부분은 Amazon Q에게 맡기자. 이를 위해 역할을 다음과 같이 나눴습니다.</p>
<p><strong>플러그인 역할</strong></p>
<ul>
<li>정확한 템플릿 생성 (컴파일 보장)</li>
<li>모든 메서드 커버리지 보장</li>
<li>기존 테스트 보존</li>
<li>팀 컨벤션 적용</li>
</ul>
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/12/테스트코드자동화_02-737x750.png" alt="" /></p>
<p><strong>Amazon Q 역할</strong></p>
<ul>
<li>템플릿의 TODO 구현</li>
<li>IDE 컨텍스트로 정확한 코드 생성</li>
<li>실시간 오류 수정</li>
</ul>
<h3>5.2 실제 비교: 복잡한 레거시 코드로 테스트</h3>
<p>실무에서 흔히 볼 수 있는 &quot;빠르게 작성된&quot; 레거시 코드로 테스트했습니다.</p>
<p><strong>테스트 대상 코드</strong></p>
<pre><code class="language-kotlin">class ProductDisplayProcessor(
    private val productRepo: ProductRepository,
    private val categoryService: CategoryService,
    private val discountCalc: DiscountCalculator,
    private val badgeService: BadgeService
) {
    fun process(request: DisplayRequest): DisplayResponse {
        val products = productRepo.findByIds(request.productIds)
        val result = mutableListOf&lt;DisplayProduct&gt;()

        for (p in products) {
            if (p.stock &lt;= 0) continue
            if (p.status != &quot;ACTIVE&quot;) continue

            val category = categoryService.getCategory(p.categoryId) ?: continue
            if (!category.isDisplayable) continue

            val price = if (p.discountRate &gt; 0) {
                discountCalc.calculate(p.price, p.discountRate)
            } else p.price

            val badges = badgeService.getBadges(p.id)
            val mainBadge = badges.firstOrNull { it.priority == 1 }

            result.add(DisplayProduct(p.id, p.name, price, mainBadge?.name))
        }
        return DisplayResponse(result.sortedBy { it.priority })
    }
}</code></pre>
<p><strong>문제점</strong>: 5개 의존성, 복잡한 분기 로직, Null 체크 산재, 중첩 조건문</p>
<hr />
<p><strong>방식 1: Amazon Q만 사용</strong></p>
<pre><code>프롬프트: &quot;ProductDisplayProcessor 테스트 작성해줘. Kotest, MockK 사용&quot;</code></pre>
<p>생성된 테스트:</p>
<pre><code class="language-kotlin">context(&quot;process&quot;) {
    test(&quot;정상 케이스 - 모든 조건을 만족하는 상품&quot;) { /* 구현됨 */ }
    test(&quot;재고가 0인 상품은 제외&quot;) { /* 구현됨 */ }
    test(&quot;카테고리가 null인 경우&quot;) { /* 구현됨 */ }
    test(&quot;할인율이 있는 경우&quot;) { /* 구현됨 */ }
}</code></pre>
<p><strong>결과</strong>: 4개 테스트 생성, 커버리지 60%</p>
<p><strong>누락된 케이스</strong>:</p>
<ul>
<li>상태가 INACTIVE인 경우</li>
<li>카테고리가 노출 불가능한 경우  </li>
<li>할인율이 0인 경우</li>
<li>뱃지가 없는 경우</li>
<li>우선순위 정렬 검증</li>
</ul>
<hr />
<p><strong>방식 2: 플러그인 + Amazon Q</strong></p>
<p><strong>1단계: 플러그인이 생성한 템플릿</strong></p>
<pre><code class="language-kotlin">context(&quot;상품 필터링&quot;) {
    test(&quot;재고가 0인 상품은 제외된다&quot;) { /* TODO */ }
    test(&quot;상태가 ACTIVE가 아닌 상품은 제외된다&quot;) { /* TODO */ }
}
context(&quot;카테고리 검증&quot;) {
    test(&quot;카테고리가 null이면 상품은 제외된다&quot;) { /* TODO */ }
    test(&quot;카테고리가 노출 불가능하면 상품은 제외된다&quot;) { /* TODO */ }
}
context(&quot;할인 계산&quot;) {
    test(&quot;할인율이 0보다 크면 할인가가 계산된다&quot;) { /* TODO */ }
    test(&quot;할인율이 0이면 원가가 사용된다&quot;) { /* TODO */ }
}
context(&quot;뱃지 처리&quot;) {
    test(&quot;우선순위 1인 뱃지가 메인 뱃지로 선택된다&quot;) { /* TODO */ }
}
// ... 총 12개 테스트</code></pre>
<p><strong>2단계: Amazon Q에게 TODO 구현 요청</strong></p>
<pre><code>프롬프트: &quot;위 템플릿의 TODO를 모두 구현해줘&quot;</code></pre>
<p><strong>결과</strong>: 12개 테스트 모두 구현, 커버리지 95%, 컴파일 즉시 성공</p>
<hr />
<p><strong>비교 결과</strong></p>
<table>
<thead>
<tr>
<th>항목</th>
<th>Amazon Q만</th>
<th>플러그인 + Amazon Q</th>
</tr>
</thead>
<tbody>
<tr>
<td>생성된 테스트 수</td>
<td>4개</td>
<td>12개</td>
</tr>
<tr>
<td>커버리지</td>
<td>60%</td>
<td>95%</td>
</tr>
<tr>
<td>누락된 엣지케이스</td>
<td>5개</td>
<td>0개</td>
</tr>
<tr>
<td>추가 프롬프트 필요</td>
<td>많음</td>
<td>없음</td>
</tr>
<tr>
<td>소요 시간</td>
<td>8분</td>
<td>4분</td>
</tr>
</tbody>
</table>
<p><strong>핵심 차이</strong>: Amazon Q는 주요 케이스는 잘 생성하지만 엣지케이스를 놓치기 쉽습니다. 개발자가 &quot;뭘 놓쳤지?&quot;를 판단하고 추가 요청해야 합니다. 플러그인은 코드 분석으로 모든 분기를 빠짐없이 추출합니다.</p>
<h3>5.3 핵심 개선사항</h3>
<p><strong>개선 1: TC 리스트 정제 자동화</strong></p>
<p>대량의 TC 리스트에서 단위 테스트로 검증 가능한 케이스를 자동으로 선별합니다.</p>
<pre><code>TC 리스트 정제 작업: 60~120초 (과제당 1회만 수행)
- UI 테스트 제외
- API 통합 테스트 제외
- 단위 테스트 가능 케이스만 추출</code></pre>
<p>플러그인은 Gemini API를 활용하여 TC 리스트를 분석하고, 다음과 같은 형태로 정제된 결과를 반환합니다.</p>
<blockquote>
<p>아래는 실제 서비스 테스트 케이스와는 다른 예시입니다.</p>
</blockquote>
<pre><code class="language-json">{
  &quot;refinedTCs&quot;: [
    {
      &quot;tcNumber&quot;: &quot;TC-001&quot;,
      &quot;unitTestGoal&quot;: &quot;상품 우선순위에 따른 정렬 순서 검증&quot;,
      &quot;serverLogic&quot;: &quot;우선순위 값이 낮을수록 상위 노출&quot;,
      &quot;testableConditions&quot;: [
        &quot;priority: [1, 3, 2] → sorted: [1, 2, 3]&quot;
      ]
    },
    {
      &quot;tcNumber&quot;: &quot;TC-002&quot;,
      &quot;unitTestGoal&quot;: &quot;품절 상품 필터링 로직 검증&quot;,
      &quot;serverLogic&quot;: &quot;재고가 0인 상품 제외&quot;,
      &quot;testableConditions&quot;: [
        &quot;stock: 0 → filtered out&quot;
      ]
    }
  ]
}</code></pre>
<p>이렇게 정제된 TC는 각 클래스의 책임에 맞게 자동으로 분산되어 템플릿으로 생성됩니다.</p>
<p><strong>개선 2: 아키텍처 분석</strong></p>
<p>단순히 모든 TC를 한 클래스에 몰아넣지 않고, 각 클래스의 역할을 분석하여 적절히 분산합니다.</p>
<pre><code class="language-kotlin">class ArchitectureAnalysisService {
    fun analyzeArchitecture(targetClass: PsiClass, testCases: List&lt;TCRow&gt;) {
        // 오케스트레이션 레이어 판단
        // TC 책임 소재 분석
        // 통합 테스트 식별
    }
}</code></pre>
<p>예를 들어 <code>DisplayApiService</code> 클래스를 분석하면:</p>
<ul>
<li>현재 클래스: TC 분기 로직만 테스트</li>
<li><code>ProductSortService</code>: 상품 정렬 TC 분산</li>
<li><code>ProductFilterService</code>: 상품 필터링 TC 분산</li>
</ul>
<hr />
<h2>6. 결과: 실제 효과는?</h2>
<h3>6.1 정량적 성과</h3>
<p><strong>작업 시간 단축</strong></p>
<table>
<thead>
<tr>
<th>방식</th>
<th>클래스당 시간</th>
<th>100개 클래스</th>
</tr>
</thead>
<tbody>
<tr>
<td>Amazon Q만</td>
<td>10분</td>
<td>16.7시간</td>
</tr>
<tr>
<td>플러그인 + Amazon Q</td>
<td>3분</td>
<td>5시간</td>
</tr>
<tr>
<td>단축 효과</td>
<td>70%</td>
<td>11.7시간 절약</td>
</tr>
</tbody>
</table>
<p><strong>코드 품질 향상</strong></p>
<table>
<thead>
<tr>
<th>지표</th>
<th>Amazon Q만</th>
<th>플러그인 + Amazon Q</th>
</tr>
</thead>
<tbody>
<tr>
<td>컴파일 성공률</td>
<td>85%</td>
<td>95%</td>
</tr>
<tr>
<td>메서드 커버리지</td>
<td>67%</td>
<td>95%</td>
</tr>
<tr>
<td>빌드 오류 수정</td>
<td>필요 (15%)</td>
<td>거의 없음</td>
</tr>
</tbody>
</table>
<h3>6.2 정성적 효과</h3>
<p><strong>개발자 경험 개선</strong></p>
<ul>
<li>반복 작업 자동화로 피로도 감소</li>
<li>일관된 테스트 구조로 가독성 향상</li>
<li>컴파일 보장으로 안정감 증가</li>
</ul>
<p><strong>팀 협업 강화</strong></p>
<ul>
<li>팀 컨벤션 자동 적용으로 코드 리뷰 시간 단축</li>
<li>신규 팀원도 쉽게 테스트 작성 가능</li>
<li>레거시 코드 개선 동기 부여</li>
</ul>
<hr />
<h2>7. 맺음말</h2>
<p>&quot;AI가 테스트 코드를 자동으로 작성해준다면?&quot;</p>
<p>이 질문에 대한 우리의 답은 &quot;완벽한 자동화는 불가능하지만, 효율적인 보조는 가능하다&quot;입니다.</p>
<p>처음에는 Amazon Q만으로 충분하다고 생각했습니다. 하지만 반복 작업이 많아 플러그인으로 자동화를 시도했습니다. 첫 버전은 여러 문제가 있었습니다. 컴파일 오류, 기존 테스트 손실, 불완전한 커버리지 등 AI 완전 자동화의 한계가 명확했습니다. 여러 방식을 고민하다가 템플릿 방식으로 전환했고, Amazon Q와 연동하여 실용적인 해법을 찾았습니다.</p>
<p><strong>최종 성과</strong></p>
<ul>
<li>클래스당 작업 시간 70% 단축 (10분 → 3분)</li>
<li>컴파일 보장 템플릿으로 95% 컴파일 성공</li>
<li>실제 동작하는 테스트 코드 97% 통과</li>
<li>100개 클래스 기준 11.7시간 절약</li>
</ul>
<p><strong>핵심 교훈</strong></p>
<ol>
<li>
<p><strong>완벽한 자동화는 환상</strong>: AI는 &quot;보조 도구&quot;이지 &quot;대체 도구&quot;가 아닙니다. 사람의 검증과 판단이 반드시 필요합니다.</p>
</li>
<li>
<p><strong>도구 간 역할 분담</strong>: 플러그인은 반복 작업 제거와 정확한 구조 제공, Amazon Q는 구체적 구현 지원, 개발자는 최종 판단 및 검증을 담당합니다.</p>
</li>
<li>
<p><strong>팀과 함께 개선</strong>: 혼자 만들지 말고 팀과 함께 사용하며 개선하는 것이 중요합니다.</p>
</li>
</ol>
<p>이 프로젝트는 AI 도구를 실무에 적용하는 과정에서 얻은 실질적인 경험을 담고 있습니다. 완벽한 자동화보다는 개발자의 생산성을 높이는 실용적인 도구를 만드는 것이 목표였고, 그 목표를 달성할 수 있었습니다. 앞으로도 팀원들의 피드백을 반영하며 지속적으로 개선해 나갈 계획입니다.</p>The post <a href="https://techblog.woowahan.com/24568/">AI와 함께하는 테스트 자동화: 플러그인 개발기</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></content:encoded>

					<wfw:commentRss>https://techblog.woowahan.com/24568/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>


			</item>
		<item>
		<title>우아한형제들이 장애를 놓치지 않고 탐지하는 방법</title>
		<link>https://techblog.woowahan.com/24488/</link>
					<comments>https://techblog.woowahan.com/24488/#respond</comments>

		<dc:creator><![CDATA[위석철]]></dc:creator>
		<pubDate>Tue, 02 Dec 2025 02:26:34 +0000</pubDate>
				<category><![CDATA[Infra]]></category>
		<category><![CDATA[장애]]></category>
		<guid isPermaLink="false">https://techblog.woowa.in/?p=24488</guid>

					<description><![CDATA[<p>배달의민족을 사용하는 고객들은 늘 오늘의 식사를 기대합니다. 점심시간에 맞춰 미리 떡볶이를 주문하고, 저녁에는 치킨과 함께 축구 경기를 즐길 계획을 세우며 퇴근합니다. 하지만 주문을 하려는 순간 시스템 장애가 발생한다면 어떨까요? 단순히 메뉴를 바꾸는 번거로움에서 끝나는 게 아니라 기대했던 행복한 시간이 한순간에 무너져버릴 수 있습니다. 특히 월드컵 결승전을 치킨 없이 보는 것은 상상만으로도 괴로운 일이죠. 그래서 우리는 [&#8230;]</p>
The post <a href="https://techblog.woowahan.com/24488/">우아한형제들이 장애를 놓치지 않고 탐지하는 방법</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></description>
										<content:encoded><![CDATA[<p>배달의민족을 사용하는 고객들은 늘 오늘의 식사를 기대합니다. 점심시간에 맞춰 미리 떡볶이를 주문하고, 저녁에는 치킨과 함께 축구 경기를 즐길 계획을 세우며 퇴근합니다.</p>
<p>하지만 주문을 하려는 순간 시스템 장애가 발생한다면 어떨까요? 단순히 메뉴를 바꾸는 번거로움에서 끝나는 게 아니라 기대했던 행복한 시간이 한순간에 무너져버릴 수 있습니다. 특히 월드컵 결승전을 치킨 없이 보는 것은 상상만으로도 괴로운 일이죠.</p>
<p>그래서 우리는 그 <strong>누구보다 빠르게 장애를 탐지해야 하는 숙명</strong>을 갖습니다. <strong>빠르게 장애를 인지하고 피해가 커지기 전에 상황을 해결</strong>함으로써 고객의 계획된 일상을 지켜야 합니다. 오늘은 우리가 어떻게 장애를 놓치지 않고 신속하게 탐지해낼 수 있었는지 그 과정을 공유드리고자 합니다.</p>
<h3>장애는 왜 발생할까요?</h3>
<hr />
<p>서비스는 끊임없이 변화합니다. 기능 개선, 신규 기능 출시, 비즈니스 확장 등 고객의 필요에 따라 반응하며 이러한 변화는 멈출 수 없습니다. 그리고 이런 변화를 주도하는 것은 사람이기 때문에 실수 없이 완벽하게 운영하는 것은 불가능합니다.</p>
<p>따라서 장애 발생은 피할 수 없는 현실입니다. 그래서 우아한형제들 내부에서도 “<strong>장애는 내는 게 아니라 나는 것이다.</strong>”라는 표현을 사용하기도 합니다. 중요한 것은 <strong>장애가 발생했을 때 얼마나 빠르게 이를 발견하고 대응하는가</strong>입니다.</p>
<p align="center">
  <img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/11/%EC%9A%B0%EC%95%84%ED%95%9C%ED%98%95%EC%A0%9C%EB%93%A4%EC%9D%B4_%EC%9E%A5%EC%95%A0%EB%A5%BC_%EB%86%93%EC%B9%98%EC%A7%80_%EC%95%8A%EA%B3%A0_%ED%83%90%EC%A7%80%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95_%ED%99%94%EB%B6%88-359x750.png" width="359"></p>
<p align="center">일명 ‘화불’이라고 불리는 대표적인 장애</p>
<h3>장애는 어떻게 탐지하나요?</h3>
<hr />
<p>전통적으로 장애 탐지는 CPU 사용률, Memory 사용량과 같은 시스템 지표를 모니터링하며, 사전 정의한 임계 조건에 도달하면 경보를 발생시키는 방식으로 이루어집니다.</p>
<p align="center">
  <img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/11/%EC%9A%B0%EC%95%84%ED%95%9C%ED%98%95%EC%A0%9C%EB%93%A4%EC%9D%B4_%EC%9E%A5%EC%95%A0%EB%A5%BC_%EB%86%93%EC%B9%98%EC%A7%80_%EC%95%8A%EA%B3%A0_%ED%83%90%EC%A7%80%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95_%ED%83%90%EC%A7%80_%EB%88%84%EB%9D%BD-750x750.png" width="500"></p>
<p align="center">이미지 출처: ChatGPT 5</p>
<p>다만 장애 발생 가능성이 있는 <strong>모든 시스템 지표를 빠짐없이 모니터링하는 것은 현실적으로 불가능</strong>합니다. 어딘가에는 늘 모니터링이 닿지 않는 구간이 존재할 수밖에 없습니다. 그렇다고 놓치는 장애가 있어서는 안 됩니다. 놓친 장애는 곧바로 고객 피해로 이어지기 때문입니다.</p>
<p>그렇다면 <strong>장애를 놓치지 않고 탐지할 수 있는 방법</strong>이 있을까요?</p>
<h3>서비스 이상 탐지</h3>
<hr />
<p>장애에 빠르게 대응할 수 있도록 우아한형제들 SRE(Site Reliability Engineering)팀은 장애 탐지와 관제를 담당하는 여러 시스템을 직접 설계하고 운영하고 있는데요, 전통적인 모니터링 방법으로는 탐지할 수 없었던 장애를 놓치지 않기 위해 <strong>서비스 이상 탐지(Service Anomaly Detection) 시스템</strong>을 도입하기로 결정했습니다. </p>
<p>장애가 발생하면 그 즉시 장애 발생 사실을 알기는 어렵지만 분명 어디선가 사용자는 장애로 인한 영향을 받게 됩니다. 이런 사용자 영향은 결국 서비스 지표의 변화로 이어지게 되고, <strong>관련 서비스 지표를 모니터링하고 있다면 장애 발생 사실을 빠르게 탐지</strong>할 수 있습니다.</p>
<p>서비스 지표는 실시간 로그인 수, 주문 수, 결제 성공률과 같은 항목으로 구성되며, 사용자 경험을 직접적으로 반영하는 밀접한 관계를 갖습니다. 셀 수 없이 많은 시스템 지표와 달리 <strong>서비스 지표는 한정적이기 때문에 최소한의 지표로도 효과적인 모니터링이 가능</strong>합니다.</p>
<h4>요구사항</h4>
<p>그래서 서비스 지표를 모니터링할 수 있는 서비스 이상 탐지 시스템 구현을 결정했고, 설계에 앞서 세 가지 요구사항을 정의했습니다.</p>
<p><strong>1. 실시간 탐지가 가능해야 합니다.</strong></p>
<p>아무리 정확히 장애를 탐지한다고 하더라도 장애가 발생하고 한참 이후에 경보가 울린다면 아무런 효용이 없습니다. 장애가 발생한 즉시 실시간(아무리 늦어도 Near-Realtime)으로 경보가 울려야 의미 있는 대응을 할 수 있습니다.</p>
<p><strong>2. 경보가 울린 이유를 알 수 있어야 합니다.</strong></p>
<p>서비스 이상 탐지 시스템은 100% 정확할 수 없으며, 변화하는 서비스 환경 속에서 오탐은 언제든 발생할 수 있습니다. 따라서 원인 분석이 어려운 AI 기반 설계보다는 빠르게 원인을 분석하고, 개선할 수 있는 구조로 구현해야 합니다.</p>
<p><strong>3. 경보 이후의 프로세스도 제공해야 합니다.</strong></p>
<p>경보가 울려도 장애 대응이 신속하고 체계적으로 진행되지 않으면 목표 시간 내 장애를 해소할 수 없습니다. 장애 숙련도와 무관하게 누구나 빠르게 대응할 수 있도록 경보 이후의 대응 프로세스까지 제공하는 것을 핵심 요구사항으로 정의했습니다.</p>
<h4>탐지 기법 설계</h4>
<p>그러면 위의 요구사항을 충족하면서도 장애를 정확하게 탐지하기 위한 시스템은 어떻게 설계해야 할까요?</p>
<p>한 가지 다행인 점은 배달의민족 서비스는 대부분 점심과 저녁에 주문이 집중되는 구조로 패턴이 매우 선명하고 일정한 흐름을 갖습니다. 덕분에 과거 내역을 토대로 정상적인 상황에서의 서비스 지표를 쉽게 예측할 수 있고, 예측과 실적의 차이로 해당 서비스 지표의 장애 여부를 쉽게 판단할 수 있습니다.</p>
<p>구체적인 예측을 위해 우리는 IQR, 2-sigma 등 다양한 이상 감지 기법들을 검토했지만, 직관적이고 분석이 용이하며 이상치에도 강한 중앙값(Median) 방식을 선택했습니다. <strong>복잡한 기법을 활용하기보다는 빠르게 구현하고, 빠르게 검증하고, 빠르게 개선</strong>하고자 했습니다.</p>
<h3>서비스 이상 탐지 릴리즈</h3>
<hr />
<p>앞에서 정의한 요구사항을 준수하는 시스템을 설계, 구현하여 성공적으로 릴리즈를 완료했습니다. 다음 이미지는 서비스 이상 탐지 시스템에서 실제로 모니터링 중인 지표 그래프의 일부분입니다.</p>
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/11/우아한형제들이_장애를_놓치지_않고_탐지하는_방법_서비스_이상_탐지_샘플2-750x366.png" alt="" /></p>
<p align="center">‘주문 생성’ 서비스 지표에 대한 서비스 이상 탐지 그래프</p>
<p>과거 데이터의 중앙값을 토대로 예측 값(Prediction)을 생성하고, 현재 값(Actual)과 비교합니다. 만약 현재 값이 임계 값(Warning, Critical)에 도달하면 장애로 판단해 경보가 울리게 됩니다.</p>
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/11/우아한형제들이_장애를_놓치지_않고_탐지하는_방법_임계_도달_횟수-750x231.png" alt="" /></p>
<p>하지만 지표라는 게 언제든지 갑작스럽게 솟구치거나 꺼지는 이상 값이 발생할 수 있기 때문에 이로 인한 오탐을 방지하기 위해 임계 도달 횟수를 추가로 관리합니다. <strong>임계 값에 몇 회 이상 연속으로 도달했는지로 경보의 정확도를 관리</strong>합니다.</p>
<p>임계 도달 횟수를 높게 설정하면 경보의 정확도는 높아지지만 장애 탐지 속도는 느려지고, 횟수를 낮게 설정하면 장애 탐지 속도는 빨라지지만 오탐 발생 가능성이 높아집니다.</p>
<p>임계 값과 임계 도달 횟수는 각 지표마다 성격이 모두 다르기 때문에 과거 트렌드를 토대로 적정한 값을 찾는 충분한 안정화 기간이 필요합니다.</p>
<h4>장애 대응 프로세스</h4>
<p>임계 도달 횟수만큼 임계 값에 도달하게 되면 <strong>Slack 채널에 경보가 발송</strong>(좌측 이미지)됩니다. 경보 메시지에는 지표 현황이나 긴급도 등의 정보가 포함되어 있어 현재 상황을 빠르게 파악할 수 있습니다.</p>
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/11/우아한형제들이_장애를_놓치지_않고_탐지하는_방법_서비스_이상_탐지_슬랙-750x293.png" alt="" /></p>
<p align="center">장애 경보와 경보 이후의 프로세스</p>
<p>회의 중이거나 새벽 시간에는 Slack 메시지를 확인하기 어려울 수 있습니다. 각 서비스 지표별로 미리 <strong>정의된 Opsgenie On-Call 담당자를 즉시 호출</strong>(가운데 이미지)합니다. 더 이상 최초 발견자가 담당자를 찾을 필요도 없고, 전화로 잠을 깨우는 수고로움도 필요 없습니다.</p>
<p>평소에는 잘 알고 있던 프로세스도 갑작스러운 상황에서는 머리가 하얘질 수 있습니다. 특히 장애가 막 발생한 순간이라면 더욱 그렇습니다. ‘내가 지금 당장 뭐부터 해야 하지?&#8217; 기억을 떠올리는 사이에도 고객 피해는 계속해서 커지고 있습니다. 이런 부담을 없애고 즉시 장애에 대응할 수 있도록 <strong>장애 전파와 장애 채널 생성을 서비스 이상 탐지에서 자동으로 수행</strong>(우측 이미지)합니다. 담당자는 복잡한 프로세스를 생각할 필요 없이 바로 불을 끄러 가면 됩니다.</p>
<h3>도입 성과는 어떤가요?</h3>
<hr />
<p>올해 6월 서비스 이상 탐지를 도입하고, 남은 하반기 동안 안정화와 함께 계속해서 장애를 탐지해 내고 있습니다. 그동안의 성과는 어땠을까요? 처음 서비스 이상 탐지 도입을 결정했을 때 우리가 기대하는 것은 다음의 세 가지였습니다.</p>
<ul>
<li>
<p><strong>경보 정밀도</strong>: 오탐 경보(False Positive)를 최소화해야 합니다.</p>
</li>
<li>
<p><strong>장애 탐지율</strong>: 발생한 장애 대부분을 탐지해야 합니다.</p>
</li>
<li>
<p><strong>장애 전파 시간</strong>: 빠르게 장애가 전파돼야 합니다.</p>
</li>
</ul>
<p>실제 결과는 기대 이상이었습니다.</p>
<p align="center">
  <img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/11/%EC%9A%B0%EC%95%84%ED%95%9C%ED%98%95%EC%A0%9C%EB%93%A4%EC%9D%B4_%EC%9E%A5%EC%95%A0%EB%A5%BC_%EB%86%93%EC%B9%98%EC%A7%80_%EC%95%8A%EA%B3%A0_%ED%83%90%EC%A7%80%ED%95%98%EB%8A%94_%EB%B0%A9%EB%B2%95_%EC%84%B1%EA%B3%BC-750x386.png" width="700"></p>
<p align="center">아이콘 출처: flaticon.com</p>
<p><strong>경보 정밀도는 약 11배 향상</strong>됐습니다. 기존에는 경보가 발생해도 실제 장애인지 오탐인지 반신반의의 분위기가 있었습니다. 제발 오탐이길 기도했죠. 실제로 오탐인 경우도 자주 발생했습니다. 장애가 아니라서 다행이었지만, 주말이나 새벽에 갑작스러운 대응이 요구되며 구성원들의 피로는 커져갔습니다.</p>
<p>향상된 정밀도로 이제는 경보 대부분이 실제 장애에 해당합니다. 오탐이 줄어 갑작스러운 대응 상황이 많이 줄었고, 대신 경보가 발생했을 때 사실상 장애 상황으로 간주하여 빠른 대응이 가능해졌습니다.</p>
<p><strong>장애 탐지율은 약 70% 향상</strong>됐습니다. 사실상 대부분의 장애를 서비스 이상 탐지가 탐지하는 데 성공하면서 이제는 우리가 인지하지 못하는 사이에 장애로 인해 고객 피해가 급격히 증가하는 상황에 대한 걱정을 상당 부분 해소할 수 있었습니다.</p>
<p>대부분의 장애가 서비스 이상 탐지에 의해 탐지되고, 서비스 이상 탐지는 자동화된 전파 기능을 제공해 장애 전파 시간 역시 상당한 개선이 있었습니다. 이전 대비 <strong>약 74%의 전파 시간이 단축</strong>되면서 장애 해결을 위해 더욱 빠르게 리소스를 투입할 수 있었고, 단축된 시간만큼 장애 해소 역시 빠르게 이룰 수 있었습니다.</p>
<h4>서비스 지표 모니터링 통합</h4>
<p>정량적인 성과뿐 아니라 정성적인 측면에서도 큰 변화가 있었습니다. 서비스 이상 탐지 도입 이전에도 각 서비스팀에서 모니터링 중인 서비스 지표는 있었습니다. 다만 서비스팀 내부에서만 관리되는 경보들로 전사 장애를 관제하는 SRE팀에서는 어떤 지표가 모니터링되는지, 어느 채널에 경보가 울리는지 등 현황 파악이 어려웠고, 정책이나 프로세스를 전파하려고 해도 각 서비스팀마다 지표에 대한 정의나 구조가 달랐기 때문에 적용이 쉽지 않았습니다.</p>
<p>이번 서비스 이상 탐지를 도입하면서 이런 <strong>각 서비스팀의 서비스 지표 모니터링 대부분을 서비스 이상 탐지로 통합</strong>했습니다. 앞으로는 대부분의 서비스 지표 현황을 저희 팀에서 파악할 수 있게 됐고, 이는 앞으로 새로운 정책이나 프로세스 도입이 보다 효율적으로 적용됨으로써 유의미한 성과를 창출하는 데 큰 기반이 될 것입니다.</p>
<h3>앞으로의 계획</h3>
<hr />
<p>서비스 이상 탐지 도입으로 이제는 장애를 신속하게 탐지하고 대응을 시작하는 영역에서 많은 갈증이 해소되었습니다. 다음으로 집중할 부분은 발생한 장애의 원인을 신속하게 탐지해 내는 것입니다.</p>
<p><img decoding="async" src="https://techblog.woowa.in/wp-content/uploads/2025/11/우아한형제들이_장애를_놓치지_않고_탐지하는_방법_향후_계획-750x500.png" alt="" /></p>
<p align="center">이미지 출처 : ChatGPT 5</p>
<p>전사의 다양한 지표를 관리하고 운영하는 SRE팀의 <strong>수많은 데이터 더미 속에서 현재는 사람이 파악하고 있는 장애 원인 추적 과정을 빠르게 개선</strong>해 보고자 합니다. 워낙 광범위한 영역을 빠르게 분석해야 하기 때문에 서비스 이상 탐지 도입 때와는 다르게 AI를 활용하는 방안으로 해결책을 구상하고 있습니다.</p>
<p>기술이 발전하며 이제는 보다 적은 비용으로 많은 시도를 해볼 수 있게 되었습니다. 앞으로도 장애 대응을 더욱 발전시키기 위해 끊임없이 도전하고, 그 과정에서의 배움과 경험을 계속 공유드리겠습니다.</p>The post <a href="https://techblog.woowahan.com/24488/">우아한형제들이 장애를 놓치지 않고 탐지하는 방법</a> first appeared on <a href="https://techblog.woowahan.com">우아한형제들 기술블로그</a>.]]></content:encoded>

					<wfw:commentRss>https://techblog.woowahan.com/24488/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>


			</item>
	</channel>
</rss>
